Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 1
kernel.asm



      1					 ;
      2					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
      3					 ;
      4					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
      5					 ; modification,  are permitted	provided that the following conditions are
      6					 ; met:
      7					 ;
      8					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
      9					 ; notice, this	list of	conditions and the following disclaimer.
     10					 ;
     11					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
     12					 ; notice,  this  list of conditions and  the  following disclaimer in the
     13					 ; documentation and/or	other materials	provided with the distribution.
     14					 ;
     15					 ; 3. The end-user documentation included with the redistribution, if any,
     16					 ; must	include	the following acknowledgment:
     17					 ;
     18					 ; "This product uses DOS/32 Advanced DOS Extender technology."
     19					 ;
     20					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
     21					 ; and wherever	such third-party acknowledgments normally appear.
     22					 ;
     23					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
     24					 ; "DOS/32 Advanced".
     25					 ;
     26					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
     27					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
     28					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     29					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
     30					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
     31					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
     32					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
     33					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
     34					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
     35					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
     36					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     37					 ;
     38					 ;
     39
     40					 ;*****************************************************************************
     41					 ; DOS/32 Advanced DOS Extender	master Kernel file, includes kernel definitions
     42					 ; data	structures, and	files from .\TEXT\KERNEL\ implementing the kernel.
     43					 ;
     44					 ;	 Created on:	 Oct-30-1996
     45					 ;
     46					 ;*****************************************************************************
     47
     48							 .386p
     49							 .387
     50							 LOCALS
     51							 NOJUMPS
     52
     53		  =0008			 SELCODE	 = 08h			 ; KERNEL code selector
     54		  =0010			 SELDATA	 = 10h			 ; KERNEL data selector
     55		  =0018			 SELZERO	 = 18h			 ; ZERO	data selector
     56		  =0020			 SELVCPITSS	 = 20h			 ; TSS selector	for VCPI
     57		  =0028			 SELVCPICODE	 = 28h			 ; VCPI	call code selector
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 2
kernel.asm



     58		  =0030			 SELVCPICOD2	 = 30h			 ; VCPI	internal selector #2
     59		  =0038			 SELVCPICOD3	 = 38h			 ; VCPI	internal selector #3
     60		  =0040			 SELBIOSDATA	 = 40h			 ; BIOS	DATA Area 40h selector
     61		  =0048			 SELCALLBACK	 = 48h			 ; Callback DS selector
     62
     63		  =000A			 SYSSELECTORS	 = 10			 ; number of system selectors in GDT
     64
     65					 INCLUDE TEXT\include.asm
1    66					 ;
1    67					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1    68					 ;
1    69					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1    70					 ; modification,  are permitted	provided that the following conditions are
1    71					 ; met:
1    72					 ;
1    73					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1    74					 ; notice, this	list of	conditions and the following disclaimer.
1    75					 ;
1    76					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1    77					 ; notice,  this  list of conditions and  the  following disclaimer in the
1    78					 ; documentation and/or	other materials	provided with the distribution.
1    79					 ;
1    80					 ; 3. The end-user documentation included with the redistribution, if any,
1    81					 ; must	include	the following acknowledgment:
1    82					 ;
1    83					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1    84					 ;
1    85					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1    86					 ; and wherever	such third-party acknowledgments normally appear.
1    87					 ;
1    88					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1    89					 ; "DOS/32 Advanced".
1    90					 ;
1    91					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1    92					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1    93					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1    94					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1    95					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1    96					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
1    97					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1    98					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1    99					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
1   100					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1   101					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1   102					 ;
1   103					 ;
1   104
1   105		  = 0Dh, 0Ah		 cr	 equ 0Dh, 0Ah
1   106		  = 0Dh, 0Ah ,0		 cre	 equ 0Dh, 0Ah ,0
1   107					 offs	 equ offset
1   108		  = byte ptr		 bptr	 equ byte ptr
1   109		  = word ptr		 wptr	 equ word ptr
1   110		  = dword ptr		 dptr	 equ dword ptr
1   111
    112					 PUBLIC	 pm32_info
    113					 PUBLIC	 pm32_init
    114					 PUBLIC	 pm32_data
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 3
kernel.asm



    115					 PUBLIC	 @kernel_beg
    116					 PUBLIC	 @kernel_end
    117
    118
    119	    0000			 _KERNEL segment para public use16 'CODE1'
    120						 assume	 cs:_KERNEL, ds:_KERNEL
    121					 ;=============================================================================
    122	    0000			 pm32_data	 label byte	 ; data	area 12	bytes
    123	    0000  FF			 pm32_mode	 db	 -1	 ; mode	bits:
    124									 ;  bit0: 0=test DPMI/VCPI, 1=VCPI/DPMI
    125									 ;  bit1: 0=exception control off, 1=on
    126									 ;  bit2: 0=VCPI smart alloc pages off,	1=on
    127									 ;  bit3: 0=VCPI+XMS alloc sheme off, 1=on
    128									 ;  bit4: 0=trap software INTs off, 1=on
    129									 ;  bit5: 0=check ext blocks off, 1=on
    130									 ;  bit6: 0=invalid limit check	off, 1=on
    131									 ;  bit7: reserved
    132	    0001  FF			 pm32_maxpages	 db	 -1	 ; maximum number of VCPI page tables
    133	    0002  FF			 pm32_maxfpages	 db	 -1	 ; max.	of physical mem. map pages
    134	    0003  FF			 pm32_callbacks	 db	 -1	 ; number of real mode callbacks
    135	    0004  FFFF			 pm32_selectors	 dw	 -1	 ; max selectors under VCPI/XMS/raw
    136	    0006  FF			 pm32_rmstacks	 db	 -1	 ; real	mode stack nesting
    137	    0007  FF			 pm32_pmstacks	 db	 -1	 ; protected mode stack	nesting
    138	    0008  FFFF			 pm32_rmstacklen dw	 -1	 ; real	mode stack length, in para
    139	    000A  FFFF			 pm32_pmstacklen dw	 -1	 ; protected mode stack	length,	in para
    140	    000C  FFFFFFFF		 pm32_maxextmem	 dd	 -1	 ; maximum extended memory to allocate
    141
    142
    143
    144					 ;=============================================================================
    145					 ; GLOBAL DATA:
    146					 ;=============================================================================
    147
    148					 ;=============================================================================
    149					 ;*** MEMORY DATA ***
    150		  =_KERNEL:007C		 mem_ptr	 equ @area1_dd+00h	 ;dd 0;	pointer	to next	free mem block
    151		  =_KERNEL:0080		 mem_free	 equ @area1_dd+04h	 ;dd 0;	size of	largest	free mem block
    152		  =_KERNEL:0084		 mem_top	 equ @area1_dd+08h	 ;dd 0
    153		  =_KERNEL:0088		 mem_used	 equ @area1_dw+0Ch	 ;dw 0
    154		  =_KERNEL:008A		 segmentbases	 equ @area1_dw+0Eh	 ;dw 16*2 dup(0); for function 0002h
    155
    156
    157					 ;=============================================================================
    158					 ;*** Interrupt	Redirection DATA ***
    159		  =_KERNEL:00CA		 last_int	 equ @area1_db+4Eh	 ;db 0
    160		  =_KERNEL:00CB		 temp_int	 equ @area1_db+4Fh	 ;db 0
    161		  =_KERNEL:00CC		 irqset_rm	 equ @area1_dw+50h	 ;dw 0;	installed Real Mode IRQ	Vectors
    162		  =_KERNEL:00CE		 irqset_pm	 equ @area1_dw+52h	 ;dw 0;	installed Prot.	Mode IRQ Vectors
    163		  =_KERNEL:00D0		 excset_pm	 equ @area1_dw+54h	 ;dw 0;	installed Exception Vectors
    164		  =_KERNEL:00D2		 irqtab_rm	 equ @area1_dd+56h	 ;dd 16	dup(0);	16 Real	Mode IRQ Vectors
    165		  =_KERNEL:0112		 irqtab_pm	 equ @area1_dd+96h	 ;dd 32	dup(0);	16 Prot. Mode IRQ Vectors
    166		  =_KERNEL:0192		 exctab_pm	 equ @area1_dd+116h	 ;dd 32	dup(0);	16 Exception Vectors
    167
    168
    169					 ;=============================================================================
    170					 ;*** Misc. ***
    171		  =_KERNEL:0214		 tempw0		 equ @area1_dw+198h	 ;dw 0
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 4
kernel.asm



    172		  =_KERNEL:0216		 tempw1		 equ @area1_dw+19Ah	 ;dw 0
    173		  =_KERNEL:0218		 tempd1		 equ @area1_dd+19Ch	 ;label	dword
    174		  =_KERNEL:0218		 tempw2		 equ @area1_dw+19Ch	 ;dw 0
    175		  =_KERNEL:021A		 tempw3		 equ @area1_dw+19Eh	 ;dw 0
    176
    177		  =_KERNEL:021C		 oldcr0		 equ @area1_dd+1A0h	 ;dd 0	 ; preserved CR0
    178		  =_KERNEL:0220		 oldint15h	 equ @area1_dd+1A4h	 ;dd 0	 ; preserved INT 15h vector
    179		  =_KERNEL:0224		 oldint1Bh	 equ @area1_dd+1A8h	 ;dd 0
    180		  =_KERNEL:0228		 oldint1Ch	 equ @area1_dd+1ACh	 ;dd 0
    181		  =_KERNEL:022C		 oldint21h	 equ @area1_dd+1B0h	 ;dd 0
    182		  =_KERNEL:0230		 oldint23h	 equ @area1_dd+1B4h	 ;dd 0
    183		  =_KERNEL:0234		 oldint24h	 equ @area1_dd+1B8h	 ;dd 0
    184		  =_KERNEL:0238		 oldint2Fh	 equ @area1_dd+1BCh	 ;dd 0
    185		  =_KERNEL:023C		 newint1Bh	 equ @area1_dd+1C0h	 ;dd 0
    186		  =_KERNEL:0240		 newint1Ch	 equ @area1_dd+1C4h	 ;dd 0
    187		  =_KERNEL:0244		 newint23h	 equ @area1_dd+1C8h	 ;dd 0
    188		  =_KERNEL:0248		 newint24h	 equ @area1_dd+1CCh	 ;dd 0
    189		  =_KERNEL:024C		 id32_mem_free	 equ @area1_dd+1D0h
    190		  =_KERNEL:0250		 id32_mem_ptr	 equ @area1_dd+1D4h
    191		  =_KERNEL:0254		 id32_mem_vcpi	 equ @area1_dd+1D8h
    192		  =_KERNEL:0258		 id32_process_id equ @area1_dw+1DCh	 ; current process id when spawn
    193		  =_KERNEL:025C		 id32_spawned_id equ @area1_db+1E0h	 ; spawn mode flag (1=spawned)
    194		  =_KERNEL:025E		 id32_tsrmode_id equ @area1_db+1E2h	 ; TSR mode flag (1=TSR)
    195		  =_KERNEL:0260		 pagetablebase	 equ @area1_dd+1E4h	 ;dd 0;	base of	page table area
    196		  =_KERNEL:0264		 pagetabletop	 equ @area1_dd+1E8h	 ;dd 0;	top of page table area
    197		  =_KERNEL:0268		 pagetablefree	 equ @area1_dd+1ECh	 ;dd 0;	base of	available pagetab area
    198		  =_KERNEL:026C		 phystablebase	 equ @area1_dd+1F0h	 ;dd 0
    199		  =_KERNEL:0270		 phystabletop	 equ @area1_dd+1F4h	 ;dd 0
    200
    201					 ;=============================================================================
    202					 ; *** Performance Counters ***
    203		  =_KERNEL:027C		 _pc_base	 equ @area1_db+200h
    204		  =_KERNEL:027C		 _pc_intrmtopm	 equ @area1_dd+200h	 ;dd 0;	INT RM->PM switch counter
    205		  =_KERNEL:0280		 _pc_intpmtorm	 equ @area1_dd+204h	 ;dd 0;	INT PM->RM switch counter
    206		  =_KERNEL:0284		 _pc_irqrmtopm	 equ @area1_dd+208h	 ;dd 0;	IRQ RM->PM switch counter
    207		  =_KERNEL:0288		 _pc_irqpmtorm	 equ @area1_dd+20Ch	 ;dd 0;	IRQ PM->RM switch counter
    208		  =_KERNEL:028C		 _pc_irqcbrmtopm equ @area1_dd+210h	 ;dd 0;	IRQ Callback RM->PM counter
    209		  =_KERNEL:0290		 _pc_irqcbpmtorm equ @area1_dd+214h	 ;dd 0;	IRQ Callback PM->RM counter
    210		  =_KERNEL:0294		 _pc_cbrmtopm	 equ @area1_dd+218h	 ;dd 0;	Callback RM->PM	counter
    211		  =_KERNEL:0298		 _pc_cbpmtorm	 equ @area1_dd+21Ch	 ;dd 0;	Callback PM->RM	counter
    212		  =_KERNEL:029C		 pmstacklen	 equ @area1_dd+220h	 ;dd 0;	prot mode stack	length in bytes
    213		  =_KERNEL:02A0		 pmstackbase	 equ @area1_dd+224h	 ;dd 0;	bottom of prot mode stack area
    214		  =_KERNEL:02A4		 pmstacktop	 equ @area1_dd+228h	 ;dd 0;	top of prot mode stack area
    215		  =_KERNEL:02A8		 pmstacktop2	 equ @area1_dd+22Ch	 ;dd 0
    216		  =_KERNEL:02AC		 rmstacklen	 equ @area1_dw+230h	 ;dw 0;	real mode stack	size in	para
    217		  =_KERNEL:02AE		 rmstackbase	 equ @area1_dw+232h	 ;dw 0;	bottom of real mode stack area
    218		  =_KERNEL:02B0		 rmstacktop	 equ @area1_dw+234h	 ;dw 0;	top of real mode stack area
    219		  =_KERNEL:02B2		 rmstacktop2	 equ @area1_dw+236h	 ;dw 0
    220		  =_KERNEL:02BC		 rmstackesp	 equ @area1_dd+240h	 ;dd 0;	for functions 0300h,0301h,0302h
    221		  =_KERNEL:02C0		 rmstackss	 equ @area1_dw+244h	 ;dw 0
    222		  =_KERNEL:02C4		 callbackbase	 equ @area1_dd+248h	 ;dd 0;	base of	real mode callbacks
    223		  =_KERNEL:02C8		 callbackseg	 equ @area1_dw+24Ch	 ;dw 0;	segment	of callbacks
    224		  =_KERNEL:02CC		 irqcallbackptr	 equ @area1_dw+250h	 ;dw 0;	ptr to IRQ callback ESP	buffer
    225
    226							 evendata
    227	    0010  0000 0000		 client_call	 dw	 0,0		 ; client's critical handler offset
    228	    0014  0000			 client_version	 dw	 0		 ; extender version
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 5
kernel.asm



    229	    0016  0000			 kernel_code	 dw	 0		 ; kernel CS: segment
    230	    0018  00			 cputype	 db	 0		 ; processor type
    231	    0019  00			 fputype	 db	 0		 ; co-processor	type
    232	    001A  00			 pmodetype	 db	 0		 ; protected mode type
    233	    001B  00			 pagetables	 db	 0		 ; number of page tables under VCPI
    234	    001C  00			 picslave	 db	 0		 ; PIC slave base interrupt
    235	    001D  00			 picmaster	 db	 0		 ; PIC master base interrupt
    236	    001E  00			 virtualfpu	 db	 0		 ; INT 31h, func: 0E00h, virtual FPU
    237	    001F  00			 A20_state	 db	 0		 ; old A20 gate	state
    238
    239							 evendata
    240	    0020  00000000		 codebase	 dd	 0		 ; _KERNEL linear address
    241	    0024  00000000		 dpmiepmode	 dd	 0		 ; DPMI	enter pmode addx
    242
    243	    0028  0018			 selzero	 dw	 SELZERO	 ; for immediate segreg	loading
**Error** kernel.asm(197) Symbol already different kind: SELZERO
    244	    002A  0010			 seldata	 dw	 SELDATA	 ; for immediate segreg	loading
**Error** kernel.asm(198) Symbol already different kind: SELDATA
    245	    002C  0048			 selcallback	 dw	 SELCALLBACK	 ; for immediate segreg	loading
**Error** kernel.asm(199) Symbol already different kind: SELCALLBACK
    246	    002E  0000			 gdtseg		 dw	 0		 ; segment of GDT
    247	    0030  0000			 gdtlimit	 dw	 0		 ; GDT limit
    248	    0032  00000000		 gdtbase	 dd	 0		 ; GDT base
    249	    0036  0000			 idtseg		 dw	 0		 ; segment of IDT
    250	    0038  07FF			 idtlimit	 dw	 7FFh		 ; IDT limit
    251	    003A  00000000		 idtbase	 dd	 0		 ; IDT base
    252	    003E  03FF			 rmidtlimit	 dw	 3FFh		 ; real	mode IDT limit
    253	    0040  00000000		 rmidtbase	 dd	 0		 ; real	mode IDT base
    254	    0044  1090r			 rmtopmswrout	 dw	 offs v_rmtopmsw ; addx	of real	to protected routine
    255	    0046  000010D4r		 pmtormswrout	 dd	 offs v_pmtormsw ; addx	of protected to	real routine
    256
    257
    258					 ;=============================================================================
    259					 ;*** XMS DATA ***
    260							 evendata
    261	    004A  0000 0000		 xms_call	 dw	 0,0		 ; XMS driver offset, segment
    262	    004E  00000000		 xms_data	 dd	 0		 ; XMS 3.0 available memory
    263	    0052  0000			 xms_handle	 dw	 0		 ; memory handle
    264
    265
    266					 ;=============================================================================
    267					 ;*** VCPI DATA	***
    268							 evendata		 ; VCPI	structure, DO NOT MODIFY
    269	    0054  00000000		 vcpi_cr3	 dd	 0		 ; VCPI	CR3 value for protected	mode
    270	    0058  00000030r		 vcpi_gdtaddx	 dd	 offs gdtlimit	 ; linear addx of GDT limit and	base
    271	    005C  00000038r		 vcpi_idtaddx	 dd	 offs idtlimit	 ; linear addx of IDT limit and	base
    272	    0060  0000			 vcpi_selldt	 dw	 0		 ; LDT selector	for protected mode
    273	    0062  0020			 vcpi_seltss	 dw	 SELVCPITSS	 ; TSS selector	for protected mode
    274	    0064  000010ACr		 vcpi_eip	 dd	 offs v_rmtopmswpm; destination	EIP in protected mode
    275	    0068  0008			 vcpi_cs	 dw	 SELCODE	 ; destination CS in protected mode
    276
    277	    006A  00000000		 vcpi_calleip	 dd	 0		 ; VCPI	protected mode call offset
    278	    006E  0028			 vcpi_callcs	 dw	 SELVCPICODE	 ; VCPI	protected mode call selector
    279	    0070  0000			 vcpi_allocmem	 dw	 0		 ; VCPI	number of allocated pages
    280	    0072  00000054r		 vcpistrucaddx	 dd	 offs vcpi_cr3	 ; VCPI	switch structure linear	address
    281	    0076  00000000		 vcpiswitchstack dd	 0		 ; VCPI	temporary mode switch stack
    282
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 6
kernel.asm



    283
    284
    285
    286
    287
    288					 ;=============================================================================
    289					 ; PROTECTED MODE INIT/EXIT CODE
    290
    291					 include TEXT\KERNEL\detect.asm
1   292					 ;
1   293					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1   294					 ;
1   295					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1   296					 ; modification,  are permitted	provided that the following conditions are
1   297					 ; met:
1   298					 ;
1   299					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1   300					 ; notice, this	list of	conditions and the following disclaimer.
1   301					 ;
1   302					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1   303					 ; notice,  this  list of conditions and  the  following disclaimer in the
1   304					 ; documentation and/or	other materials	provided with the distribution.
1   305					 ;
1   306					 ; 3. The end-user documentation included with the redistribution, if any,
1   307					 ; must	include	the following acknowledgment:
1   308					 ;
1   309					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1   310					 ;
1   311					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1   312					 ; and wherever	such third-party acknowledgments normally appear.
1   313					 ;
1   314					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1   315					 ; "DOS/32 Advanced".
1   316					 ;
1   317					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1   318					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1   319					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1   320					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1   321					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1   322					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
1   323					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1   324					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1   325					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
1   326					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1   327					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1   328					 ;
1   329					 ;
1   330
1   331					 ;=============================================================================
1   332					 ; Get Protected Mode Info
1   333					 ;=========================
1   334					 ; In:	 Nothing
1   335					 ; Out:	 AX = return code:
1   336					 ;	  0000h	= DOS version below 4.00
1   337					 ;	  0001h	= no 80386+ detected
1   338					 ;	  0002h	= system already in protected mode and no VCPI or DPMI found
1   339					 ;	  0003h	= DPMI - host is not 32bit
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 7
kernel.asm



1   340					 ;	  0004h	= VCPI - incompatible PIC mappings
1   341					 ;	 CF = set on error, if no error:
1   342					 ;	  BX = number of paragraphs needed for protected mode data (may	be 0)
1   343					 ;	  CL = processor type
1   344					 ;	  CH = protected mode type:
1   345					 ;		 00h = raw
1   346					 ;		 01h = XMS
1   347					 ;		 02h = VCPI
1   348					 ;		 03h = DPMI
1   349					 ;	 DX = size of removable	Kernel body (in	bytes)
1   350					 ;	 DI = base of removable	Kernel body
1   351					 ;=============================================================================
1   352	    007A  01*(87 DB)			 Align 4
1   353	    007C			 @area1_db label byte
1   354	    007C			 @area1_dw label word
1   355	    007C			 @area1_dd label dword
1   356
1   357	    007C			 pm32_info:
1   358	    007C  FC				 cld
1   359	    007D  1E 06				 push ds es			 ; preserve registers
1   360	    007F  0E 0E				 push cs cs			 ; DS =	CS (_KERNEL)
1   361	    0081  1F 07				 pop ds	es
1   362
1   363					 If EXEC_TYPE eq 2
1   364						 call show_debug_string		 ; show	debug string
1   365					 EndIf
1   366	    0083  B4 30				 mov ah,30h			 ; get DOS version
1   367	    0085  CD 21				 int 21h
1   368	    0087  3C 04				 cmp al,4			 ; if DOS version is below 4.00
1   369	    0089  B8 0000			 mov ax,0			 ; return with error code 0
1   370	    008C  0F 82	00C7			 jb @@fail
1   371
1   372	    0090  E8 0213			 call cpu_detect		 ; get processor type
1   373	    0093  A2 0018r			 mov cputype,al			 ; store processor type
1   374	    0096  3C 03				 cmp al,3			 ; check if processor is 80386+
1   375	    0098  B8 0001			 mov ax,1			 ; error in case no 80386+
1   376	    009B  73 05	90 90			 jae @@0
1   377	    009F  E9 00B5			 jmp @@fail
1   378
1   379	    00A2  E8 0278		 @@0:	 call fpu_detect		 ; detect/initialize FPU
1   380	    00A5  A2 0019r			 mov fputype,al
1   381
1   382	    00A8  B8 4300			 mov ax,4300h			 ; check for XMS
1   383	    00AB  CD 2F				 int 2Fh
1   384	    00AD  3C 80				 cmp al,80h
1   385	    00AF  75 31	90 90			 jnz @@1			 ; jump	if XMS not found
1   386
1   387	    00B3  06				 push es
1   388	    00B4  B8 4310			 mov ax,4310h
1   389	    00B7  CD 2F				 int 2Fh
1   390	    00B9  89 1E	004Ar			 mov xms_call[0],bx		 ; store XMS driver address
1   391	    00BD  8C 06	004Cr			 mov xms_call[2],es
1   392	    00C1  B4 30				 mov ah,30h
1   393	    00C3  CD 21				 int 21h			 ; HIMEM.SYS bug fix
1   394	    00C5  B4 88				 mov ah,88h
1   395	    00C7  33 DB				 xor bx,bx
1   396	    00C9  FF 1E	004Ar			 call dword ptr	xms_call	 ; get XMS v3.0	free mem in KB
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 8
kernel.asm



1   397	    00CD  84 DB				 test bl,bl			 ; if no XMS v3.0, use v2.0
1   398	    00CF  74 0C	90 90			 jz @@0001
1   399	    00D3  B4 08				 mov ah,08h
1   400	    00D5  FF 1E	004Ar			 call dword ptr	xms_call	 ; get XMS v2.0	free mem in KB
1   401	    00D9  66| 0F B7 C0			 movzx eax,ax
1   402	    00DD  66| A3 004Er		 @@0001: mov xms_data,eax
1   403	    00E1  07				 pop es
1   404
1   405	    00E2  F6 06	0000r 01	 @@1:	 test pm32_mode,00000001b	 ; check order of DPMI/VCPI detection
1   406	    00E7  74 0B	90 90			 jz @@2
1   407	    00EB  E8 0097			 call @@detect_VCPI		 ; check for VCPI first
1   408	    00EE  E8 0069			 call @@detect_DPMI		 ; check for DPMI second
1   409	    00F1  EB 07	90			 jmp @@3			 ; neither found, go on	to raw check
1   410	    00F4  E8 0063		 @@2:	 call @@detect_DPMI		 ; check for DPMI first
1   411	    00F7  E8 008B			 call @@detect_VCPI		 ; check for VCPI second
1   412
1   413	    00FA  0F 01	E0		 @@3:	 smsw ax			 ; AX =	machine	status word
1   414	    00FD  24 01				 and al,1			 ; is system in	protected mode?
1   415	    00FF  B8 0002			 mov ax,2			 ; error code in case in protected mode
1   416	    0102  75 53	90 90			 jnz @@fail			 ; if in protected mode, fail
1   417
1   418	    0106  66| 83 3E 004Er 00		 cmp xms_data,0			 ; check if XMS_mem is present
1   419	    010C  0F 95	C5			 setnz ch			 ; if yes, pmode type is XMS
1   420	    010F  BB 0080			 mov bx,80h			 ; BX =	memory requirement (IDT)
1   421
1   422	    0112  0F B6	06 0006r	 @@4:	 movzx ax,pm32_rmstacks		 ; size	of real	mode stack area
1   423	    0117  0F AF	06 0008r		 imul ax,pm32_rmstacklen
1   424	    011C  03 D8				 add bx,ax
1   425
1   426	    011E  0F B6	06 0007r		 movzx ax,pm32_pmstacks		 ; size	of protected mode stack	area
1   427	    0123  0F AF	06 000Ar		 imul ax,pm32_pmstacklen
1   428	    0128  03 D8				 add bx,ax
1   429
1   430	    012A  0F B6	06 0003r		 movzx ax,pm32_callbacks	 ; size	of callbacks
1   431	    012F  6B C0	19			 imul ax,25
1   432	    0132  05 000F			 add ax,0Fh
1   433	    0135  C1 E8	04			 shr ax,4
1   434	    0138  03 D8				 add bx,ax
1   435
1   436	    013A  A1 0004r			 mov ax,pm32_selectors		 ; size	of GDT
1   437	    013D  05 000B			 add ax,SYSSELECTORS+1
1   438	    0140  D1 E8				 shr ax,1
1   439	    0142  03 D8				 add bx,ax
1   440
1   441	    0144  33 C0			 @@done: xor ax,ax			 ; success code, also clear carry flag
1   442	    0146  8A 0E	0018r			 mov cl,cputype
1   443	    014A  88 2E	001Ar			 mov pmodetype,ch		 ; store pmode type
1   444
1   445	    014E  BA 2880			 mov dx,offs @kernel_end - offs	@kernel_beg
1   446	    0151  BF 0540r			 mov di,offs @kernel_beg
1   447
1   448	    0154  07 1F			 @@exit: pop es	ds			 ; restore other registers
1   449	    0156  CB				 retf				 ; return
1   450	    0157  F9			 @@fail: stc				 ; carry set, failed
1   451	    0158  EB FA				 jmp @@exit
1   452
1   453
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 9
kernel.asm



1   454
1   455
1   456					 ;=============================================================================
1   457	    015A			 @@detect_DPMI:				 ; detect a DPMI host
1   458	    015A  5D				 pop bp
1   459
1   460	    015B  B8 1687			 mov ax,1687h			 ; check for DPMI
1   461	    015E  CD 2F				 int 2Fh
1   462	    0160  85 C0				 test ax,ax			 ; DPMI	present?
1   463	    0162  75 1F	90 90			 jnz @@d0			 ; if no, exit routine
1   464
1   465	    0166  B8 0001			 mov ax,1			 ; error code in case no processor 386+
1   466	    0169  80 F9	03			 cmp cl,3			 ; is processor	386+? (redundant)
1   467	    016C  72 E9				 jb @@fail			 ; if no, fail
1   468
1   469	    016E  B0 03				 mov al,3			 ; error code in case DPMI not 32bit
1   470	    0170  F6 C3	01			 test bl,1			 ; is DPMI 32bit?
1   471	    0173  74 E2				 jz @@fail			 ; if no, fail
1   472
1   473	    0175  89 3E	0024r			 mov word ptr dpmiepmode[0],di	 ; store DPMI initial mode switch addx
1   474	    0179  8C 06	0026r			 mov word ptr dpmiepmode[2],es
1   475	    017D  8B DE				 mov bx,si			 ; BX =	number of paragraphs needed
1   476	    017F  B5 03				 mov ch,3			 ; pmode type is 3 (DPMI)
1   477	    0181  EB C1				 jmp @@done			 ; go to done ok
1   478	    0183  FF E5			 @@d0:	 jmp bp				 ; return to calling routine
1   479
1   480
1   481					 ;=============================================================================
1   482	    0185			 @@detect_VCPI:				 ; detect a VCPI server
1   483	    0185  5D				 pop bp
1   484
1   485	    0186  33 C0				 xor ax,ax			 ; get INT 67h vector
1   486	    0188  8E C0				 mov es,ax
1   487	    018A  26: A1 019C			 mov ax,es:[67h*4]
1   488	    018E  26: 0B 06 019E		 or ax,es:[67h*4+2]		 ; is vector NULL
1   489	    0193  74 EE				 jz @@d0			 ; if yes, no VCPI
1   490	    0195  B8 DE00			 mov ax,0DE00h			 ; call	VCPI installation check
1   491	    0198  CD 67				 int 67h
1   492	    019A  84 E4				 test ah,ah			 ; AH returned as 0?
1   493	    019C  75 E5				 jnz @@d0			 ; if no, no VCPI
1   494	    019E  B8 DE0A			 mov ax,0DE0Ah			 ; get PIC mappings
1   495	    01A1  CD 67				 int 67h
1   496	    01A3  88 1E	001Dr			 mov picmaster,bl
1   497	    01A7  88 0E	001Cr			 mov picslave,cl
1   498	    01AB  B8 0004			 mov ax,0004h			 ; error code 4	in case	of exit
1   499	    01AE  3A D9				 cmp bl,cl			 ; BL=CL, only one PIC available
1   500	    01B0  74 A5				 je @@fail
1   501	    01B2  80 FB	30			 cmp bl,30h			 ; PICs	mapped on system vectors?
1   502	    01B5  74 A0				 je @@fail
1   503	    01B7  80 F9	30			 cmp cl,30h
1   504	    01BA  74 9B				 je @@fail
1   505	    01BC  84 DB				 test bl,bl			 ; should not be mapped	on INT 00h
1   506	    01BE  74 97				 je @@fail
1   507	    01C0  84 C9				 test cl,cl
1   508	    01C2  74 93				 je @@fail
1   509
1   510	    01C4  66| 8B 16 004Er		 mov edx,xms_data		 ; EDX=get free	XMS memory
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 10
kernel.asm



1   511	    01C9  66| 8B CA			 mov ecx,edx			 ; ECX=free XMS	memory in KB
1   512	    01CC  67| E3 16			 jecxz @@v1			 ; skip	if none
1   513
1   514	    01CF  F6 06	0000r 08		 test pm32_mode,00001000b	 ; check if VCPI+XMS alloc scheme
1   515	    01D4  74 0C	90 90			 jz @@vA			 ; if not, jump	(save some DOS memory)
1   516	    01D8  E8 0AC5			 call xms_allocmem		 ; alloc XMS memory in EDX
1   517	    01DB  8B FA				 mov di,dx			 ; DI=handle
1   518	    01DD  48				 dec ax				 ; if AX=0001, no error	occured
1   519	    01DE  74 05	90 90			 jz @@v1
1   520	    01E2  66| 33 C9		 @@vA:	 xor ecx,ecx			 ; if error, XMS memory	in ECX = 0
1   521
1   522	    01E5  B8 DE03		 @@v1:	 mov ax,0DE03h
1   523	    01E8  CD 67				 int 67h			 ; EDX=free VCPI pages
1   524
1   525	    01EA  06 66| 51 66|	52 57		 push es ecx edx di
1   526	    01F0  F6 06	0000r 04		 test pm32_mode,00000100b	 ; check if VCPI smart pagetable alloc
1   527	    01F5  74 34	90 90			 jz @@v1a			 ; no, use standard detection
1   528
1   529	    01F9  B4 48				 mov ah,48h			 ; allocate 4K block of	memory
1   530	    01FB  BB 0100			 mov bx,0100h			 ;  for	VCPI pagetable
1   531	    01FE  CD 21				 int 21h
1   532	    0200  72 29	90 90			 jc @@v1a			 ; INT 21h failed, use standard	alloc
1   533
1   534	    0204  8E C0				 mov es,ax			 ; ES=returned segment
1   535	    0206  33 FF				 xor di,di			 ; DI=zero pointer
1   536	    0208  83 EC	18			 sub sp,8*3			 ; DS:SI=pointer to structure
1   537	    020B  8B F4				 mov si,sp
1   538	    020D  1E				 push ds
1   539	    020E  16				 push ss
1   540	    020F  1F				 pop ds
1   541	    0210  B8 DE01			 mov ax,0DE01h			 ; get PM interface
1   542	    0213  CD 67				 int 67h
1   543	    0215  1F				 pop ds
1   544	    0216  83 C4	18			 add sp,8*3			 ; discard structure on	stack
1   545	    0219  B4 49				 mov ah,49h			 ; discard pagetable and free DOS mem
1   546	    021B  CD 21				 int 21h
1   547	    021D  66| B8 00001000		 mov eax,1000h			 ; pagetable limit 4K
1   548	    0223  2B C7				 sub ax,di			 ; minus used part
1   549	    0225  C1 E8	02			 shr ax,2			 ; convert to 4K pages
1   550	    0228  EB 04	90			 jmp @@v1b
1   551
1   552	    022B  66| 33 C0		 @@v1a:	 xor eax,eax
1   553	    022E  5F 66| 5A 66|	59 07	 @@v1b:	 pop di	edx ecx	es
1   554
1   555	    0234  66| 8B F1			 mov esi,ecx			 ; ECX=XMS free	mem,EDX=VCPI free pages
1   556	    0237  66| C1 EE 02			 shr esi,2			 ; ESI=XMS_freemem/4 (to match 4Kpages)
1   557	    023B  66| 67| 8D B4	32    +		 lea esi,[edx+esi+3FFh]		 ; ESI=XMS_4Kmem+VCPI_4Kpages+4M_align
    558		  000003FF
1   559	    0244  66| 2B F0			 sub esi,eax			 ; minus free 0th pagetable space
1   560	    0247  73 05	90 90			 jnc @@v1c			 ; just	in case...
1   561	    024B  66| 13 F0			 adc esi,eax
1   562	    024E  66| C1 EE 0A		 @@v1c:	 shr esi,10			 ; ESI=ESI/1024
1   563	    0252  67| E3 08			 jecxz @@v2
1   564
1   565	    0255  8B D7				 mov dx,di
1   566	    0257  B4 0A				 mov ah,0Ah			 ; free	what was allocated
1   567	    0259  FF 1E	004Ar			 call dword ptr	xms_call
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 11
kernel.asm



1   568	    025D  0F B6	06 0001r	 @@v2:	 movzx ax,pm32_maxpages
1   569	    0262  3B C6				 cmp ax,si
1   570	    0264  76 04	90 90			 jbe @@v3
1   571	    0268  8B C6				 mov ax,si
1   572
1   573	    026A  85 C0			 @@v3:	 test ax,ax			 ; now if no pages, check for
1   574	    026C  75 1A	90 90			 jnz @@v5			 ; DOS/32A, and	if present, use	its
1   575	    0270  66| 60			 pushad				 ; pages and pagetables
1   576	    0272  8B EC				 mov bp,sp
1   577	    0274  B8 FF88			 mov ax,0FF88h			 ; check if running under DOS/32A
1   578	    0277  CD 21				 int 21h
1   579	    0279  66| 3D 49443332		 cmp eax,'ID32'
1   580	    027F  75 05	90 90			 jnz @@v4
1   581	    0283  89 76	1C			 mov [bp+1Ch],si		 ; if yes, store pagetables in AX
1   582	    0286  66| 61		 @@v4:	 popad
1   583	    0288  3C 40			 @@v5:	 cmp al,64			 ; limit the number of pagetables to
1   584	    028A  76 04	90 90			 jbe @@v6			 ; maximum 64, = 256MB
1   585	    028E  B0 40				 mov al,64
1   586	    0290  A2 001Br		 @@v6:	 mov pagetables,al		 ; BX =	VCPI page tables needed
1   587	    0293  02 06	0002r			 add al,pm32_maxfpages		 ; + physical memory mappable pages
1   588	    0297  C1 E0	08			 shl ax,8			 ; 100h	paragraphs per page table
1   589	    029A  05 0386			 add ax,100h+100h+0FFh+7+80h	 ; +page_dir+0th_page+align_buf+TSS+IDT
1   590	    029D  8B D8				 mov bx,ax
1   591	    029F  B5 02				 mov ch,2			 ; pmode type is 2 (VCPI)
1   592	    02A1  E9 FE6E			 jmp @@4			 ; go to figure	other memory needed
1   593	    02A4  FF E5			 @@v0:	 jmp bp				 ; return to calling routine
1   594
1   595
1   596
1   597
1   598
1   599					 ;=============================================================================
1   600	    02A6			 cpu_detect:				 ; detect: 286,	386, 486, 586 etc
1   601	    02A6  FA				 cli
1   602	    02A7  B1 02				 mov	 cl,2			 ; CL: cputype=2 (80286)
1   603	    02A9  9C				 pushf
1   604	    02AA  58				 pop	 ax
1   605	    02AB  0D F000			 or	 ax,0F000h
1   606	    02AE  50				 push	 ax
1   607	    02AF  9D				 popf
1   608	    02B0  9C				 pushf
1   609	    02B1  58				 pop	 ax
1   610	    02B2  25 F000			 and	 ax,0F000h
1   611	    02B5  75 05	90 90			 jne	 @@l2
1   612	    02B9  EB 5E	90			 jmp	 @@x1
1   613	    02BC  FE C1			 @@l2:	 inc	 cl			 ; CPU = 80386
1   614	    02BE  66| 9C			 pushfd
1   615	    02C0  66| 58			 pop	 eax
1   616	    02C2  66| 8B D0			 mov	 edx,eax
1   617	    02C5  66| 35 00040000		 xor	 eax,00040000h
1   618	    02CB  66| 50			 push	 eax
1   619	    02CD  66| 9D			 popfd
1   620	    02CF  66| 9C			 pushfd
1   621	    02D1  66| 58			 pop	 eax
1   622	    02D3  66| 33 C2			 xor	 eax,edx
1   623	    02D6  75 05	90 90			 jne	 @@l3
1   624	    02DA  EB 3D	90			 jmp	 @@x1
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 12
kernel.asm



1   625	    02DD  FE C1			 @@l3:	 inc	 cl			 ; CPU = 80486
1   626	    02DF  66| 52			 push	 edx
1   627	    02E1  66| 9D			 popfd
1   628	    02E3  66| 9C			 pushfd
1   629	    02E5  66| 9C			 pushfd
1   630	    02E7  66| 58			 pop	 eax
1   631	    02E9  66| 8B D0			 mov	 edx,eax
1   632	    02EC  66| 35 00200000		 xor	 eax,00200000h
1   633	    02F2  66| 50			 push	 eax
1   634	    02F4  66| 9D			 popfd
1   635	    02F6  66| 9C			 pushfd
1   636	    02F8  66| 58			 pop	 eax
1   637	    02FA  66| 33 C2			 xor	 eax,edx
1   638	    02FD  75 05	90 90			 jne	 @@l4
1   639	    0301  EB 0E	90			 jmp	 @@x2
1   640	    0304  66| B8 00000001	 @@l4:	 mov	 eax,1
1   641	    030A  0F A2				 db	 0Fh, 0A2h		 ; CPUID
1   642	    030C  80 E4	0F			 and	 ah,0Fh
1   643	    030F  8A CC				 mov	 cl,ah
1   644	    0311  66| 9D		 @@x2:	 popfd
1   645	    0313  66| 33 C0			 xor	 eax,eax
1   646	    0316  66| 33 D2			 xor	 edx,edx
1   647	    0319  8A C1			 @@x1:	 mov	 al,cl
1   648	    031B  FB				 sti
1   649	    031C  C3				 ret
1   650
1   651	    031D			 fpu_detect:				 ; detect 8087,	287, 387, 487 etc
1   652	    031D  66| 6A 00			 push	 large 0
1   653	    0320  8B EC				 mov	 bp,sp
1   654	    0322  DB E3				 fninit
1   655	    0324  D9 7E	02			 fnstcw	 word ptr [bp+2]
1   656	    0327  8B 46	02			 mov	 ax,word ptr [bp+2]
1   657	    032A  80 FC	03			 cmp	 ah,03h
1   658	    032D  75 57	90 90			 jnz	 @@done			 ; done: no FPU	present
1   659	    0331  C7 46	00 0001			 mov	 word ptr [bp],1
1   660	    0336  81 66	02 FF7F			 and	 word ptr [bp+2],0FF7Fh
1   661	    033B  9B				 wait
1   662	    033C  D9 6E	02			 fldcw	 word ptr [bp+2]
1   663	    033F  9B DB	E1			 fdisi
1   664	    0342  9B D9	7E 02			 fstcw	 word ptr [bp+2]
1   665	    0346  9B				 wait
1   666	    0347  F7 46	02 0080			 test	 word ptr [bp+2],0080h
1   667	    034C  75 38	90 90			 jnz	 @@done			 ; done: 8087 is present
1   668	    0350  C7 46	00 0002			 mov	 word ptr [bp],2
1   669	    0355  DB E3				 fninit
1   670	    0357  9B				 wait
1   671	    0358  D9 E8				 fld1
1   672	    035A  9B				 wait
1   673	    035B  D9 EE				 fldz
1   674	    035D  9B				 wait
1   675	    035E  DE F9				 fdivp	 st(1),st
1   676	    0360  9B				 wait
1   677	    0361  D9 C0				 fld	 st(0)
1   678	    0363  9B				 wait
1   679	    0364  D9 E0				 fchs
1   680	    0366  9B				 wait
1   681	    0367  DE D9				 fcompp
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 13
kernel.asm



1   682	    0369  9B				 wait
1   683	    036A  DF E0				 fnstsw	 ax
1   684	    036C  9B				 wait
1   685	    036D  DB E2				 fnclex
1   686	    036F  9B				 wait
1   687	    0370  9E				 sahf
1   688	    0371  74 13	90 90			 jz	 @@done			 ; done: 80287 is present
1   689	    0375  C7 46	00 0003			 mov	 word ptr [bp],3
1   690	    037A  A0 0018r			 mov	 al,cputype
1   691	    037D  3C 04				 cmp	 al,4
1   692	    037F  72 05	90 90			 jb	 @@done			 ; done: 80387 is present
1   693	    0383  88 46	00			 mov	 byte ptr [bp],al	 ; done: 80487+	(build-in)
1   694	    0386  66| 58		 @@done: pop	 eax
1   695	    0388  66| 83 E0 07			 and	 eax,7
1   696	    038C  74 0C	90 90			 jz	 @@exit
1   697	    0390  B9 0008			 mov	 cx,8
1   698	    0393  D9 EE			 @@loop: fldz				 ; set ST(0) to	ST(7) to +ZERO
1   699	    0395  E2 FC				 loop	 @@loop
1   700	    0397  9B DB	E3			 finit				 ; reinitialize	FPU
1   701	    039A  C3			 @@exit: ret
1   702
1   703	    039B  90				 Align 4
1   704	    039C			 @area1_end label byte
1   705
1   706
    707					 include TEXT\KERNEL\init.asm
1   708					 ;
1   709					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1   710					 ;
1   711					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1   712					 ; modification,  are permitted	provided that the following conditions are
1   713					 ; met:
1   714					 ;
1   715					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1   716					 ; notice, this	list of	conditions and the following disclaimer.
1   717					 ;
1   718					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1   719					 ; notice,  this  list of conditions and  the  following disclaimer in the
1   720					 ; documentation and/or	other materials	provided with the distribution.
1   721					 ;
1   722					 ; 3. The end-user documentation included with the redistribution, if any,
1   723					 ; must	include	the following acknowledgment:
1   724					 ;
1   725					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1   726					 ;
1   727					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1   728					 ; and wherever	such third-party acknowledgments normally appear.
1   729					 ;
1   730					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1   731					 ; "DOS/32 Advanced".
1   732					 ;
1   733					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1   734					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1   735					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1   736					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1   737					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1   738					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 14
kernel.asm



1   739					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1   740					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1   741					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
1   742					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1   743					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1   744					 ;
1   745					 ;
1   746
1   747					 ;=============================================================================
1   748					 ; Initialize Protected	Mode
1   749					 ;===========================
1   750					 ; In:	 BX = client version
1   751					 ;	 DX = offset of	Client's Safe Exit Routine (used by exception handler)
1   752					 ;	 ES = real mode	segment	for protected mode data	(ignored if not	needed)
1   753					 ;
1   754					 ; Out:	 AX = return code:
1   755					 ;	  0005h	= DPMI - could not enter 32bit protected mode
1   756					 ;	  0006h	= DPMI - could not allocate needed selectors
1   757					 ;	  0007h	= could	not enable A20 gate
1   758					 ;	 BX = kernel code selector
1   759					 ;	 ECX = amount of allocated memory (in bytes)
1   760					 ;	 EDX = pointer to allocated memory (from 0)
1   761					 ;	 SI = current process ID (when spawned)
1   762					 ;	 DI = version of the previously	installed DOS/32A (0 if	none)
1   763					 ;	 CF = set on error, if no error:
1   764					 ;	  ESP =	high word clear
1   765					 ;	  CS = 16bit selector for real mode CS with limit of 64k
1   766					 ;	  SS = selector	for real mode SS with limit of 64k
1   767					 ;	  DS = selector	for real mode DS with limit of 64k
1   768					 ;	  ES = selector	for PSP	with limit of 100h
1   769					 ;	  FS = 0 (NULL selector)
1   770					 ;	  GS = 0 (NULL selector)
1   771					 ;=============================================================================
1   772
1   773	    039C			 pm32_init:
1   774	    039C  FC				 cld
1   775	    039D  66| 60			 pushad
1   776	    039F  1E				 push ds
1   777	    03A0  0E				 push cs			 ; DS =	_KERNEL
1   778	    03A1  1F				 pop ds
1   779
1   780	    03A2  66| 33 C0			 xor eax,eax
1   781	    03A5  8C 0E	0016r			 mov kernel_code,cs
1   782	    03A9  89 1E	0014r			 mov client_version,bx
1   783	    03AD  89 16	0010r			 mov client_call[0],dx
1   784	    03B1  8C C8				 mov ax,cs			 ; set base addx of _KERNEL
1   785	    03B3  66| C1 E0 04			 shl eax,4
1   786	    03B7  66| A3 0020r			 mov codebase,eax
1   787	    03BB  66| 01 06 0058r		 add vcpi_gdtaddx,eax		 ; adjust addresses for	VCPI structure
1   788	    03C0  66| 01 06 005Cr		 add vcpi_idtaddx,eax
1   789	    03C5  66| 01 06 0072r		 add vcpistrucaddx,eax
1   790	    03CA  66| 0F BA 36 000Cr  +		 btr pm32_maxextmem,31		 ; limit extended memory to 2GB
    791		  1F
1   792
1   793	    03D1  06				 push es
1   794	    03D2  0E				 push cs
1   795	    03D3  07				 pop es
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 15
kernel.asm



1   796	    03D4  BF 007Cr			 mov di,offs @area1_db
1   797	    03D7  B9 0190			 mov cx,(offs @area1_end - offs	@area1_db) /2
1   798	    03DA  33 C0				 xor ax,ax
1   799	    03DC  F3> AB			 rep stosw
1   800	    03DE  07				 pop es
1   801
1   802	    03DF  8B EC				 mov bp,sp
1   803	    03E1  89 46	02			 mov [bp+02h],ax		 ; set DI to 0 (prev D32A version)
1   804	    03E4  B8 FF88			 mov ax,0FF88h			 ; detect if DOS/32A is	present
1   805	    03E7  CD 21				 int 21h
1   806	    03E9  66| 3D 49443332		 cmp eax,'ID32'			 ; check if we were spawned
1   807	    03EF  75 2E	90 90			 jnz @@1			 ; if not, jump
1   808	    03F3  89 5E	02			 mov [bp+02h],bx		 ; set DI to prev. version of D32A
1   809	    03F6  3B 1E	0014r			 cmp bx,client_version		 ; check versions
1   810	    03FA  75 23	90 90			 jnz @@1			 ; if not equal, jump
1   811	    03FE  66| 89 0E 024Cr		 mov id32_mem_free,ecx
1   812	    0403  66| 89 16 0250r		 mov id32_mem_ptr,edx
1   813	    0408  66| 89 3E 0254r		 mov id32_mem_vcpi,edi
1   814	    040D  66| C1 EE 10			 shr esi,16			 ; get previous	process	id
1   815	    0411  46				 inc si				 ; increment (make it this process id)
1   816	    0412  89 36	0258r			 mov id32_process_id,si		 ; store the new, current process id
1   817	    0416  66| C7 06 000Cr     +		 mov pm32_maxextmem,0		 ; use already allocated memory
    818		  00000000
1   819
1   820	    041F  0F B6	1E 001Ar	 @@1:	 movzx bx,pmodetype		 ; jump	to appropriate init code
1   821	    0424  03 DB				 add bx,bx
1   822	    0426  FF A7	042Ar			 jmp @@init[bx]
1   823
1   824	    042A  082Ar			 @@init	 dw r_init
1   825	    042C  07B7r				 dw x_init
1   826	    042E  0540r				 dw v_init
1   827	    0430  0523r				 dw d_init
1   828
1   829
1   830					 ;=============================================================================
1   831	    0432			 dvxr_init:				 ; DPMI/VCPI/XMS/raw common init tail
1   832	    0432  33 C0				 xor ax,ax			 ; allocate selector for return	code
1   833	    0434  B9 0001			 mov cx,1
1   834	    0437  CD 31				 int 31h
1   835	    0439  73 07	90 90			 jnc @@0
1   836	    043D  B8 4CFF		 @@err:	 mov ax,4CFFh			 ; could not allocate selector
1   837	    0440  CD 21				 int 21h			 ; terminate immediately
1   838
1   839	    0442  8B EC			 @@0:	 mov bp,sp
1   840	    0444  8B D8				 mov bx,ax			 ; new code descriptor for return
1   841	    0446  B8 0007			 mov ax,0007h			 ; set base address of calling segment
1   842	    0449  8B 56	24			 mov dx,[bp+36]
1   843	    044C  8B CA				 mov cx,dx
1   844	    044E  C1 E2	04			 shl dx,4
1   845	    0451  C1 E9	0C			 shr cx,12
1   846	    0454  CD 31				 int 31h
1   847	    0456  72 E5				 jc @@err
1   848
1   849	    0458  40				 inc ax				 ; set selector	limit to 64k
1   850	    0459  33 C9				 xor cx,cx
1   851	    045B  BA FFFF			 mov dx,0FFFFh
1   852	    045E  CD 31				 int 31h
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 16
kernel.asm



1   853	    0460  72 DB				 jc @@err
1   854
1   855	    0462  40				 inc ax				 ; set selector	type and access	rights
1   856	    0463  8C CA				 mov dx,cs			 ; get DPL from	current	CPL, and access
1   857	    0465  0F 02	CA			 lar cx,dx			 ;  rights and type from current CS
1   858	    0468  C1 E9	08			 shr cx,8			 ; type	is already 16bit code segment
1   859	    046B  CD 31				 int 31h
1   860	    046D  72 CE				 jc @@err
1   861
1   862	    046F  89 5E	24			 mov [bp+36],bx			 ; store selector in return address
1   863
1   864	    0472  2E: 80 3E 001Ar 03		 cmp cs:pmodetype,3		 ; if DPMI, no need in client_addx
1   865	    0478  74 0D	90 90			 jz @@1				 ;  DPMI will handle all the exceptions
1   866	    047C  1E				 push ds			 ; store client's code selector
1   867	    047D  2E: 8E 1E 0010		 mov ds,cs:seldata
1   868	    0482  89 1E	0012r			 mov client_call[2],bx
1   869	    0486  1F				 pop ds
1   870
1   871	    0487  33 DB			 @@1:	 xor bx,bx			 ; init	successful, carry clear
1   872
1   873					 ;-----------------------------------------------------------------------------
1   874	    0489			 init_done:				 ; return with return code
1   875	    0489  89 5E	1E			 mov [bp+1Eh],bx		 ; set AX=return code
1   876	    048C  72 1F	90 90			 jc @@1
1   877	    0490  66| 2E: A1 0080r		 mov eax,cs:mem_free
1   878	    0495  66| 2E: 8B 16	007Cr		 mov edx,cs:mem_ptr
1   879	    049B  66| 89 46 1A			 mov [bp+1Ah],eax		 ; set ECX=amount of allocated memory
1   880	    049F  66| 89 56 16			 mov [bp+16h],edx		 ; set EDX=pointer to allocated	memory
1   881	    04A3  66| 0B C2			 or eax,edx			 ; if allocated	some memory, exit
1   882	    04A6  75 05	90 90			 jnz @@1
1   883	    04AA  E8 000C			 call init_done_id32
1   884	    04AD  1F			 @@1:	 pop ds
1   885	    04AE  66| 61			 popad
1   886	    04B0  8C CB				 mov bx,cs			 ; return BX=kernel code selector
1   887	    04B2  2E: 8B 36 0258r		 mov si,cs:id32_process_id	 ; return SI=current process ID
1   888	    04B7  FC				 cld
1   889	    04B8  CB				 retf
1   890
1   891	    04B9			 init_done_id32:
1   892	    04B9  2E: 80 3E 001Ar 03		 cmp cs:pmodetype,3		 ; if under DPMI, exit
1   893	    04BF  74 61	90 90			 jz @@done
1   894	    04C3  2E: 8E 1E 0010		 mov ds,cs:seldata
1   895	    04C8  83 3E	0258r 00		 cmp id32_process_id,0		 ; if this is the first	process	(mom)
1   896	    04CD  74 53	90 90			 jz @@done			 ; then	we're done
1   897
1   898	    04D1  66| A1 024Cr			 mov eax,id32_mem_free
1   899	    04D5  66| 8B 16 0250r		 mov edx,id32_mem_ptr
1   900	    04DA  66| 89 46 1A			 mov [bp+1Ah],eax		 ; set ECX=amount of allocated memory
1   901	    04DE  66| 89 56 16			 mov [bp+16h],edx		 ; set EDX=pointer to allocated	memory
1   902	    04E2  66| A3 0080r			 mov mem_free,eax
1   903	    04E6  66| 89 16 007Cr		 mov mem_ptr,edx
1   904	    04EB  66| 67| 8D 48	10		 lea ecx,[eax+10h]		 ; size	of memory + 16 bytes
1   905	    04F0  66| 67| 8D 04	11		 lea eax,[ecx+edx]		 ; top of memory
1   906	    04F5  66| A3 0084r			 mov mem_top,eax
1   907
1   908	    04F9  A0 001Ar			 mov al,pmodetype		 ; now check if	running	under VCPI
1   909	    04FC  3C 00				 cmp al,0
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 17
kernel.asm



1   910	    04FE  74 22	90 90			 jz @@done
1   911	    0502  3C 01				 cmp al,1
1   912	    0504  74 1C	90 90			 jz @@done
1   913	    0508  06				 push es
1   914	    0509  66| 8B 36 0254r		 mov esi,id32_mem_vcpi		 ; import pagetables from prev process
1   915	    050E  66| 8B 3E 0268r		 mov edi,pagetablefree
1   916	    0513  B8 0018			 mov es,selzero
**Error** TEXT\KERNEL\init.asm(207) Illegal use	of segment register
1   917	    0516  B8 0018			 mov ds,selzero
**Error** TEXT\KERNEL\init.asm(208) Illegal use	of segment register
1   918	    0519  66| C1 E9 0C			 shr ecx,12
1   919	    051D  F3> 66| 67| A5		 rep movs dword	ptr es:[edi],[esi]
1   920	    0521  07				 pop es
1   921	    0522  C3			 @@done: ret
1   922
1   923
1   924
1   925
1   926
1   927					 ;=============================================================================
1   928					 ;****** NOTE:	 DPMI host will	provide	all INT	31h functions and
1   929					 ;		 will be responsible for any memory allocation.
1   930
1   931	    0523  1F			 d_init: pop ds				 ; get original	caller DS from stack
1   932	    0524  B8 0001			 mov ax,1			 ; enter DPMI protected	mode
1   933	    0527  2E: FF 1E 0024r		 call cs:dpmiepmode
1   934	    052C  1E				 push ds			 ; put DS back onto stack
1   935	    052D  0F 83	FF01			 jnc dvxr_init			 ; error? if not, go on	with init
1   936	    0531  BB 0006			 mov bx,6			 ; error entering protected mode, set
1   937	    0534  3D 8011			 cmp ax,8011h			 ;  error code and abort
1   938	    0537  F9				 stc
1   939	    0538  0F 84	FF4D			 jz init_done
1   940	    053C  4B				 dec bx				 ; error code 5, not 6
1   941	    053D  E9 FF49			 jmp init_done
1   942
1   943
1   944
1   945
1   946
1   947						 Align 16
1   948	    0540			 @kernel_beg	 label byte		 ;** Begin of kernel code
1   949	    0540			 @callback_data	 label byte		 ;** CALLBACK DATA Structure
1   950
1   951					 ;=============================================================================
1   952	    0540  66| 33 C0		 v_init: xor eax,eax
1   953	    0543  8C C0				 mov ax,es			 ; align data area on page boundary
1   954	    0545  05 00FF			 add ax,00FFh
1   955	    0548  32 C0				 xor al,al
1   956	    054A  8E C0				 mov es,ax
1   957	    054C  8B D0				 mov dx,ax			 ; set base and	top of page table area
1   958
1   959	    054E  66| C1 E0 04			 shl eax,4
1   960	    0552  66| 05 00001000		 add eax,1000h			 ; skip	Page Directory
1   961	    0558  66| A3 0260r			 mov pagetablebase,eax		 ; 0th PageTable linear	address
1   962	    055C  66| 05 00001000		 add eax,1000h			 ; skip	0th PageTable
1   963	    0562  66| 0F B6 0E 001Br		 movzx ecx,pagetables
1   964	    0568  66| C1 E1 0C			 shl ecx,12
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 18
kernel.asm



1   965	    056C  66| 03 C1			 add eax,ecx
1   966	    056F  66| A3 0264r			 mov pagetabletop,eax		 ; Nth PageTable linear	adress
1   967	    0573  66| A3 026Cr			 mov phystablebase,eax		 ; set base and	top of physical	pages
1   968	    0577  66| 0F B6 0E 0002r		 movzx ecx,pm32_maxfpages
1   969	    057D  66| C1 E1 0C			 shl ecx,12
1   970	    0581  66| 03 C1			 add eax,ecx
1   971	    0584  66| A3 0270r			 mov phystabletop,eax
1   972
1   973	    0588  33 FF				 xor di,di
1   974	    058A  66| 33 C0			 xor eax,eax			 ; clear PageDir and 0th PageTable
1   975	    058D  B9 0800			 mov cx,0800h
1   976	    0590  F3> 66| AB			 rep stos dword	ptr es:[di]
1   977
1   978	    0593  8E EA				 mov gs,dx			 ; GS =	segment	of Page	Directory
1   979	    0595  8B C2				 mov ax,dx
1   980	    0597  05 0100			 add ax,0100h
1   981	    059A  8E C0				 mov es,ax			 ; ES =	segment	of 0th Page Table
1   982	    059C  8E E0				 mov fs,ax			 ; FS =	segment	of 0th Page Table
1   983
1   984	    059E  83 EC	18			 sub sp,8*3			 ;***NOTE: stack will be restored later
1   985	    05A1  8B F4				 mov si,sp			 ; DS:SI = ptr to VCPI structure
1   986	    05A3  33 FF				 xor di,di			 ; ES:DI = ptr to imported 0th PageTab
1   987	    05A5  1E				 push ds
1   988	    05A6  16				 push ss
1   989	    05A7  1F				 pop ds
1   990	    05A8  B8 DE01			 mov ax,0DE01h			 ; get VCPI protected mode interface
1   991	    05AB  CD 67				 int 67h
1   992	    05AD  1F				 pop ds
1   993
1   994	    05AE  57				 push di			 ;** store DI =	ptr to free entry
1   995	    05AF  66| 89 1E 006Ar		 mov vcpi_calleip,ebx		 ; store protected mode	VCPI call EIP
1   996	    05B4  26: 80 65 01 F1	 @@1:	 and byte ptr es:[di+1],0F1h	 ; clear bits 9-11 in imported PageTab
1   997	    05B9  83 EF	04			 sub di,4
1   998	    05BC  73 F6				 jnc @@1
1   999
1  1000	    05BE  8B CA				 mov cx,dx			 ; get physical	address	of PageDir
1  1001	    05C0  C1 E9	08			 shr cx,8
1  1002	    05C3  B8 DE06			 mov ax,0DE06h
1  1003	    05C6  CD 67				 int 67h
1  1004	    05C8  81 E2	F000			 and dx,0F000h
1  1005	    05CC  66| 89 16 0054r		 mov vcpi_cr3,edx		 ; set VCPI CR3	register
1  1006
1  1007					 ;
1  1008					 ; Map VCPI 0th	PageTable into our PageDir
1  1009					 ;
1  1010	    05D1  8C C1				 mov cx,es			 ; CX =	0th PageTable addr
1  1011	    05D3  C1 E9	08			 shr cx,8			 ; convert to PageTable	number
1  1012	    05D6  B8 DE06			 mov ax,0DE06h			 ; VCPI	get pagetable Physical Addr
1  1013	    05D9  CD 67				 int 67h
1  1014	    05DB  80 E6	F0			 and dh,0F0h
1  1015	    05DE  B2 07				 mov dl,07h
1  1016	    05E0  66| 65: 89 16	0000		 mov gs:[0000h],edx		 ; store address in PageDir
1  1017
1  1018					 ;
1  1019					 ; Map the rest	of our custom PageTables into our PageDir
1  1020					 ;
1  1021	    05E6  8C C0				 mov ax,es			 ; advance to the 1st PageTable
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 19
kernel.asm



1  1022	    05E8  05 0100			 add ax,0100h
1  1023	    05EB  8E C0				 mov es,ax
1  1024
1  1025	    05ED  8B F0				 mov si,ax			 ; SI =	segment	of 1st PageTable
1  1026	    05EF  A0 001Br			 mov al,pagetables		 ; AL =	PageTables to alloc
1  1027	    05F2  66| BB 00000001		 mov ebx,1			 ; EBX = index ptr into	PageDir
1  1028	    05F8  E8 0066			 call vcpi_setup_pagetables	 ; initialize VCPI PageDir and PageTabs
1  1029
1  1030					 ;
1  1031					 ; Map PageTables for phys. mapping into PageDir
1  1032					 ;
1  1033	    05FB  8C E8				 mov ax,gs			 ; advance PageDir to 8000_0000h addr
1  1034	    05FD  05 0080			 add ax,80h
1  1035	    0600  8E E8				 mov gs,ax
1  1036
1  1037	    0602  A0 0002r			 mov al,pm32_maxfpages		 ; phystables to allocate
1  1038	    0605  66| 33 DB			 xor ebx,ebx			 ; EBX = index ptr into	PageDir
1  1039	    0608  E8 0056			 call vcpi_setup_pagetables	 ; initialize VCPI PageDir and PageTabs
1  1040	    060B  5F				 pop di				 ;** restore DI	= ptr to free entry
1  1041
1  1042	    060C  66| 33 C0			 xor eax,eax
1  1043	    060F  F6 06	0000r 04		 test pm32_mode,00000100b	 ; if smart pagetables is off
1  1044	    0614  75 05	90 90			 jnz @@2			 ;  then align pagetablefree to
1  1045	    0618  BF 1000			 mov di,1000h			 ;  first allocated free pagetable
1  1046	    061B  8B C7			 @@2:	 mov ax,di			 ; set base of usable page table area
1  1047	    061D  66| 03 06 0260r		 add eax,pagetablebase
1  1048	    0622  66| A3 0268r			 mov pagetablefree,eax
1  1049
1  1050	    0626  56 06				 push si es
1  1051	    0628  E8 0070			 call vcpi_alloc_ems		 ; allocate VCPI memory
1  1052	    062B  07 5E				 pop es	si
1  1053
1  1054	    062D  56				 push si			 ; SI =	segment	of TSS (for later use)
1  1055	    062E  33 FF				 xor di,di			 ; clear TSS with all 0, not really
1  1056	    0630  B9 0034			 mov cx,34h			 ;  needed, but	just to	be safe
1  1057	    0633  33 C0				 xor ax,ax
1  1058	    0635  F3> AB			 rep stos word ptr es:[di]
1  1059	    0637  66| A1 0054r			 mov eax,vcpi_cr3		 ; set CR3 in TSS
1  1060	    063B  66| 26: A3 001C		 mov es:[1Ch],eax
1  1061	    0640  66| 26: C7 06	0064  +		 mov dword ptr es:[64h],680000h	 ; set offset of I/O permission	bitmap
   1062		  00680000
1  1063										 ;  and	clear T	bit
1  1064	    064A  83 C6	07			 add si,7			 ; increment next data area ptr
1  1065	    064D  8E C6				 mov es,si
1  1066	    064F  C7 06	0044r 1090r		 mov rmtopmswrout,offs v_rmtopmsw	 ; set VCPI mode switch	addresses
1  1067	    0655  66| C7 06 0046r     +		 mov pmtormswrout,offs v_pmtormsw
   1068		  000010D4r
1  1069	    065E  E9 022D			 jmp vxr_init			 ; go to VCPI/XMS/raw continue init
1  1070
1  1071
1  1072	    0661			 vcpi_setup_pagetables:
1  1073	    0661  55				 push bp
1  1074	    0662  0F B6	E8			 movzx bp,al			 ; BP =	PageTables to alloc
1  1075	    0665  85 ED				 test bp,bp
1  1076	    0667  74 30	90 90			 jz @@done
1  1077	    066B  8B CE			 @@1:	 mov cx,si			 ; CX =	PageTable segment
1  1078	    066D  C1 E9	08			 shr cx,8			 ; convert to PageTable	number
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 20
kernel.asm



1  1079	    0670  B8 DE06			 mov ax,0DE06h			 ; VCPI	get PageTable Physical Addr
1  1080	    0673  CD 67				 int 67h
1  1081	    0675  80 E6	F0			 and dh,0F0h
1  1082	    0678  B2 07				 mov dl,07h
1  1083	    067A  66| 65: 67| 89 14 9D+		 mov gs:[ebx*4],edx		 ; store address in PageDir
   1084		  00000000
1  1085	    0684  81 C6	0100			 add si,0100h			 ; increment pagetable segment (4K)
1  1086	    0688  8E C6				 mov es,si
1  1087	    068A  33 FF				 xor di,di			 ; clear PageTable
1  1088	    068C  66| 33 C0			 xor eax,eax
1  1089	    068F  B9 0400			 mov cx,0400h
1  1090	    0692  F3> 66| AB			 rep stos dword	ptr es:[di]
1  1091	    0695  43				 inc bx				 ; increment index in PageDir
1  1092	    0696  4D				 dec bp				 ; decrement PageTable counter
1  1093	    0697  75 D2				 jnz @@1			 ; if no, loop
1  1094	    0699  5D			 @@done: pop bp
1  1095	    069A  C3				 ret
1  1096
1  1097	    069B			 vcpi_alloc_ems:
1  1098	    069B  0F A0				 push fs
1  1099	    069D  07				 pop es				 ; ES:DI ptr to	free entry in 0th page
1  1100	    069E  66| 0F B6 06 001Br		 movzx eax,pagetables		 ; calculate free linear space
1  1101	    06A4  66| C1 E0 16			 shl eax,22			 ; convert PageTables to bytes (*4M)
1  1102	    06A8  66| B9 00001000		 mov ecx,1000h
1  1103	    06AE  2B CF				 sub cx,di			 ; ECX = unused	space in 0th PageTable
1  1104	    06B0  80 E1	FC			 and cl,0FCh
1  1105	    06B3  66| C1 E1 0A			 shl ecx,10			 ; convert 4K pages to bytes
1  1106	    06B7  66| 03 C1			 add eax,ecx			 ; EAX = available linear space	(bytes)
1  1107	    06BA  66| 8B 0E 000Cr		 mov ecx,pm32_maxextmem		 ; ECX = memory	to allocate (bytes)
1  1108	    06BF  66| 3B C8			 cmp ecx,eax			 ; choose smallest value
1  1109	    06C2  76 05	90 90			 jbe @@0
1  1110	    06C6  66| 8B C8			 mov ecx,eax
1  1111	    06C9  66| 33 DB		 @@0:	 xor ebx,ebx			 ; EBX = counter of allocated pages
1  1112	    06CC  67| E3 6B			 jecxz @@done			 ; if no memory	to be allocated, done
1  1113
1  1114	    06CF  81 FF	1000		 @@1:	 cmp di,1000h			 ; if NOT overflowing page (DX>4096)
1  1115	    06D3  72 0B	90 90			 jb @@2				 ;  then jump
1  1116	    06D7  8C C0				 mov ax,es			 ; else	adjust ES:DI pointer to	next PG
1  1117	    06D9  05 0100			 add ax,0100h
1  1118	    06DC  8E C0				 mov es,ax
1  1119	    06DE  33 FF				 xor di,di
1  1120
1  1121	    06E0  B8 DE04		 @@2:	 mov ax,0DE04h			 ; allocate 4K VCPI page
1  1122	    06E3  CD 67				 int 67h
1  1123	    06E5  84 E4				 test ah,ah			 ; check if error
1  1124	    06E7  75 18	90 90			 jnz @@3			 ; if yes, then	we are done
1  1125	    06EB  80 E6	F0			 and dh,0F0h			 ; clear avail bits
1  1126	    06EE  B2 07				 mov dl,07h			 ; set page as user/writeable/present
1  1127	    06F0  66| 26: 89 15			 mov es:[di],edx		 ; store page addr in PageTable
1  1128	    06F4  83 C7	04			 add di,4			 ; increment ptr into PageTable
1  1129	    06F7  43				 inc bx				 ; increment allocated page counter
1  1130	    06F8  66| 81 E9 00001000		 sub ecx,4096
1  1131	    06FF  77 CE				 ja @@1				 ; loop	until no more pages to allocate
1  1132
1  1133	    0701  89 1E	0070r		 @@3:	 mov vcpi_allocmem,bx		 ; store alloc pages for deallocation
1  1134	    0705  66| 81 F9 00001000		 cmp ecx,4096			 ; is there memory left	to allocate
1  1135	    070C  72 0E	90 90			 jb @@4				 ; no, then done
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 21
kernel.asm



1  1136	    0710  F6 06	0000r 08		 test pm32_mode,00001000b	 ; check if VCPI+XMS allocation	scheme
1  1137	    0715  74 05	90 90			 jz @@4				 ;  enabled, if	not jump
1  1138	    0719  E8 001F			 call vcpi_alloc_xms		 ; try XMS memory allocation
1  1139
1  1140	    071C  66| C1 E3 0C		 @@4:	 shl ebx,12			 ; convert allocated pages to bytes
1  1141	    0720  74 18	90 90			 jz @@done			 ; allocated any memory? if no,	jump
1  1142	    0724  66| 89 1E 0080r		 mov mem_free,ebx		 ; store amount	of allocated memory
1  1143	    0729  66| A1 0268r			 mov eax,pagetablefree		 ; figure out address of memory
1  1144	    072D  66| 2B 06 0260r		 sub eax,pagetablebase
1  1145	    0732  66| C1 E0 0A			 shl eax,10
1  1146	    0736  66| A3 007Cr			 mov mem_ptr,eax
1  1147	    073A  C3			 @@done: ret
1  1148
1  1149	    073B			 vcpi_alloc_xms:
1  1150	    073B  66| 53			 push ebx			 ; save	EBX counter
1  1151	    073D  66| C1 E9 0A			 shr ecx,10			 ; convert bytes to KB
1  1152	    0741  80 E1	FC			 and cl,0FCh			 ; mask	ECX to match 4KB pages
1  1153
1  1154	    0744  66| 8B D1		 @@1:	 mov edx,ecx
1  1155	    0747  67| E3 6A			 jecxz @@done			 ; if EDX=0, no	mem to be allocated
1  1156	    074A  E8 0553			 call xms_allocmem		 ; XMS allocate	extended memory
1  1157	    074D  48				 dec ax
1  1158	    074E  74 0B	90 90			 jz @@2				 ; if got memory, jump
1  1159	    0752  66| 83 E9 04			 sub ecx,4			 ; try less memory, subtract 4K	page
1  1160	    0756  73 EC				 jnc @@1			 ; loop	til there is no	memory to alloc
1  1161	    0758  EB 5A	90			 jmp @@done			 ; no memory allocated,	done
1  1162
1  1163	    075B  89 16	0052r		 @@2:	 mov xms_handle,dx		 ; store handle
1  1164	    075F  B4 0C				 mov ah,0Ch			 ; XMS lock extended memory
1  1165	    0761  FF 1E	004Ar			 call dword ptr	xms_call
1  1166	    0765  48				 dec ax
1  1167	    0766  74 11	90 90			 jz @@3				 ; if locked memory, jump
1  1168	    076A  33 D2				 xor dx,dx
1  1169	    076C  87 16	0052r			 xchg dx,xms_handle		 ; reset xms_handle: no	mem allocated
1  1170	    0770  B4 0A				 mov ah,0Ah			 ; free	allocated XMS memory
1  1171	    0772  FF 1E	004Ar			 call dword ptr	xms_call
1  1172	    0776  EB 3C	90			 jmp @@done
1  1173
1  1174	    0779  66| C1 E2 10		 @@3:	 shl edx,16			 ; convert DX:BX to EDX	pointer
1  1175	    077D  8B D3				 mov dx,bx
1  1176	    077F  66| C1 E9 02			 shr ecx,2			 ; ECX=memory allocated	in 4K blocks
1  1177	    0783  66| 0F B7 C1			 movzx eax,cx
1  1178	    0787  66| 5B			 pop ebx
1  1179	    0789  66| 03 D8			 add ebx,eax			 ; adjust allocated page number
1  1180	    078C  66| 53			 push ebx
1  1181
1  1182	    078E  81 FF	1000		 @@4:	 cmp di,1000h			 ; if NOT overflowing page (DX>4096)
1  1183	    0792  72 0B	90 90			 jb @@5				 ;  then jump
1  1184	    0796  8C C0				 mov ax,es			 ; else	adjust ES:DI pointer to	next PG
1  1185	    0798  05 0100			 add ax,0100h
1  1186	    079B  8E C0				 mov es,ax
1  1187	    079D  33 FF				 xor di,di
1  1188
1  1189	    079F  80 E6	F0		 @@5:	 and dh,0F0h			 ; clear avail bits
1  1190	    07A2  B2 07				 mov dl,07h			 ; set page as user/writeable/present
1  1191	    07A4  66| 26: 89 15			 mov es:[di],edx		 ; set linear memory addr
1  1192	    07A8  83 C7	04			 add di,4			 ; increment pointer
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 22
kernel.asm



1  1193	    07AB  66| 81 C2 00001000		 add edx,4096			 ; increment address
1  1194	    07B2  E2 DA				 loop @@4
1  1195
1  1196	    07B4  66| 5B		 @@done: pop ebx			 ; restore EBX counter
1  1197	    07B6  C3				 ret
1  1198
1  1199
1  1200
1  1201
1  1202
1  1203					 ;=============================================================================
1  1204	    07B7  B4 07			 x_init: mov ah,07h			 ; query A20
1  1205	    07B9  FF 1E	004Ar			 call dword ptr	xms_call
1  1206	    07BD  A2 001Fr			 mov A20_state,al
1  1207	    07C0  B4 03				 mov ah,03h			 ; global enable A20
1  1208	    07C2  FF 1E	004Ar			 call dword ptr	xms_call
1  1209	    07C6  BB 0007			 mov bx,0007h			 ; error code 0007h in case of error
1  1210	    07C9  48				 dec ax				 ; error enabling A20?
1  1211	    07CA  F9				 stc
1  1212	    07CB  0F 85	FCBA			 jnz init_done			 ; if yes, exit	with error 0007h
1  1213
1  1214	    07CF  66| A1 004Er			 mov eax,xms_data		 ; get KB of free XMS memory
1  1215	    07D3  66| 8B 16 000Cr		 mov edx,pm32_maxextmem		 ; get requested amount	of memory
1  1216	    07D8  66| C1 EA 0A			 shr edx,10			 ; convert to KB
1  1217	    07DC  66| 3B D0			 cmp edx,eax
1  1218	    07DF  76 05	90 90			 jbe @@1
1  1219	    07E3  66| 8B D0			 mov edx,eax
1  1220
1  1221	    07E6  66| 8B F2		 @@1:	 mov esi,edx
1  1222	    07E9  66| 85 D2			 test edx,edx			 ; check if no extended	memory is to
1  1223	    07EC  74 39	90 90			 jz @@done			 ;  be allocated, if so, then jump
1  1224
1  1225	    07F0  E8 04AD			 call xms_allocmem		 ; allocate EDX	KB memory
1  1226	    07F3  48				 dec ax
1  1227	    07F4  75 31	90 90			 jnz @@done			 ; no memory has been allocated
1  1228	    07F8  89 16	0052r			 mov xms_handle,dx		 ; store handle
1  1229
1  1230	    07FC  B4 0C				 mov ah,0Ch			 ; lock	extended memory
1  1231	    07FE  FF 1E	004Ar			 call dword ptr	xms_call
1  1232	    0802  48				 dec ax
1  1233	    0803  74 11	90 90			 jz @@2				 ; if no error,	jump
1  1234	    0807  33 D2				 xor dx,dx
1  1235	    0809  87 16	0052r			 xchg dx,xms_handle		 ; reset handle: no mem	allocated
1  1236	    080D  B4 0A				 mov ah,0Ah			 ; free	allocated extended memory
1  1237	    080F  FF 1E	004Ar			 call dword ptr	xms_call
1  1238	    0813  EB 12	90			 jmp @@done
1  1239
1  1240	    0816  89 1E	007Cr		 @@2:	 mov word ptr mem_ptr[0],bx	 ; store linear	pointer	to memory
1  1241	    081A  89 16	007Er			 mov word ptr mem_ptr[2],dx
1  1242	    081E  66| C1 E6 0A			 shl esi,10			 ; convert to bytes
1  1243	    0822  66| 89 36 0080r		 mov dword ptr mem_free,esi	 ; store amount	of memory allocated
1  1244	    0827  EB 50	90		 @@done: jmp xr_init			 ; go to XMS/raw continue init
1  1245
1  1246
1  1247
1  1248
1  1249
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 23
kernel.asm



1  1250					 ;=============================================================================
1  1251	    082A  E8 076C		 r_init: call enable_A20		 ; enable A20
1  1252	    082D  BB 0007			 mov bx,0007h			 ; error code 0007h
1  1253	    0830  0F 82	FC55			 jc init_done			 ; exit	if error enabling A20
1  1254
1  1255	    0834  66| 33 C0			 xor eax,eax
1  1256	    0837  B4 88				 mov ah,88h			 ; how much extended memory free
1  1257	    0839  CD 15				 int 15h
1  1258	    083B  85 C0				 test ax,ax			 ; if none, done with raw init
1  1259	    083D  74 3A	90 90			 jz xr_init
1  1260
1  1261	    0841  66| C1 E0 0A			 shl eax,10			 ; EAX = size of memory	(bytes)
1  1262	    0845  66| 67| 8D 90	      +		 lea edx,[eax+100000h]		 ; EDX = base of memory
   1263		  00100000
1  1264
1  1265	    084D  66| 3B 06 000Cr		 cmp eax,pm32_maxextmem		 ; check how much memory to alloc
1  1266	    0852  76 06	90 90			 jbe @@1			 ; pick	lowest value
1  1267	    0856  66| A1 000Cr			 mov eax,pm32_maxextmem
1  1268
1  1269	    085A  66| 05 000003FF	 @@1:	 add eax,000003FFh		 ; align memory	to KB
1  1270	    0860  66| 25 0FFFFC00		 and eax,0FFFFC00h
1  1271	    0866  66| 2B D0			 sub edx,eax
1  1272	    0869  66| 89 16 007Cr		 mov mem_ptr,edx		 ; store extended memory base
1  1273	    086E  66| A3 0080r			 mov mem_free,eax		 ; store size of extended memory
1  1274	    0872  66| C1 E8 0A			 shr eax,10			 ; convert to KB
1  1275	    0876  A3 0088r			 mov mem_used,ax		 ; set used memory
1  1276
1  1277	    0879			 xr_init:				 ; XMS/raw common init tail
1  1278	    0879  C7 06	001Cr 0870		 mov word ptr picslave,0870h
1  1279	    087F  C7 06	0044r 1144r		 mov rmtopmswrout,offs xr_rmtopmsw; set	XMS/raw	mode switch addresses
1  1280	    0885  66| C7 06 0046r     +		 mov pmtormswrout,offs xr_pmtormsw
   1281		  00001180r
1  1282
1  1283
1  1284
1  1285
1  1286					 ;=============================================================================
1  1287	    088E			 vxr_init:				 ; VCPI/XMS/raw	common init tail
1  1288	    088E  E8 02DB			 call install_ints		 ; install interrupts and except handl.
1  1289
1  1290	    0891  66| 33 C0			 xor eax,eax
1  1291	    0894  8C C0				 mov ax,es
1  1292	    0896  A3 0036r			 mov idtseg,ax			 ; set IDT segment base	address
1  1293	    0899  66| 8B D8			 mov ebx,eax
1  1294	    089C  66| C1 E3 04			 shl ebx,4
1  1295	    08A0  66| 89 1E 003Ar		 mov idtbase,ebx		 ; set IDT linear base address
1  1296
1  1297	    08A5  05 0080			 add ax,80h			 ; size	of IDT
1  1298	    08A8  A3 02AEr			 mov rmstackbase,ax
1  1299
1  1300	    08AB  0F B6	1E 0006r		 movzx bx,pm32_rmstacks		 ; set top and base of real mode stack
1  1301	    08B0  8B 0E	0008r			 mov cx,pm32_rmstacklen
1  1302	    08B4  89 0E	02ACr			 mov rmstacklen,cx
1  1303	    08B8  0F AF	D9			 imul bx,cx			 ;  area for interrupt redirection
1  1304	    08BB  03 C3				 add ax,bx
1  1305	    08BD  A3 02B0r			 mov rmstacktop,ax
1  1306	    08C0  A3 02B2r			 mov rmstacktop2,ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 24
kernel.asm



1  1307
1  1308	    08C3  66| C1 E0 04			 shl eax,4
1  1309	    08C7  66| A3 02A0r			 mov pmstackbase,eax		 ; set next data area to end of	RM stk
1  1310
1  1311	    08CB  66| 0F B6 1E 0007r		 movzx ebx,pm32_pmstacks	 ; set protected mode stack area top
1  1312	    08D1  66| 0F B7 0E 000Ar		 movzx ecx,pm32_pmstacklen	 ;  for	callbacks
1  1313	    08D7  66| C1 E1 04			 shl ecx,4
1  1314	    08DB  66| 89 0E 029Cr		 mov pmstacklen,ecx		 ; protected mode stack	size in	bytes
1  1315	    08E0  66| 0F AF D9			 imul ebx,ecx
1  1316	    08E4  66| 03 C3			 add eax,ebx
1  1317	    08E7  66| A3 02A4r			 mov pmstacktop,eax		 ; protected mode stack	area top
1  1318	    08EB  66| A3 02A8r			 mov pmstacktop2,eax
1  1319
1  1320	    08EF  66| A3 02C4r			 mov callbackbase,eax		 ; top of stacks is base of callbacks
1  1321	    08F3  66| C1 E8 04			 shr eax,4			 ; BX =	seg of callback	area
1  1322	    08F7  A3 02C8r			 mov callbackseg,ax
1  1323	    08FA  8E C0				 mov es,ax			 ; ES =	seg of callback	area
1  1324
1  1325	    08FC  E8 033F			 call allocate_callbacks	 ; allocate callbacks
1  1326
1  1327	    08FF  66| 33 C0			 xor eax,eax
1  1328	    0902  8C C0				 mov ax,es			 ; set GDT base	address
1  1329	    0904  A3 002Er			 mov gdtseg,ax			 ; store segment of GDT
1  1330	    0907  66| C1 E0 04			 shl eax,4
1  1331	    090B  66| A3 0032r			 mov gdtbase,eax
1  1332	    090F  66| 0F B7 0E 0004r		 movzx ecx,pm32_selectors	 ; set GDT limit
1  1333	    0915  66| 67| 8D 0C	CD    +		 lea ecx,[8*ecx+8*SYSSELECTORS-1]
   1334		  0000004F
1  1335	    091E  89 0E	0030r			 mov gdtlimit,cx
1  1336	    0922  33 FF				 xor di,di			 ; clear GDT with all 0
1  1337	    0924  41				 inc cx
1  1338	    0925  D1 E9				 shr cx,1
1  1339	    0927  66| 33 C0			 xor eax,eax
1  1340	    092A  F3> AB			 rep stos word ptr es:[di]
1  1341
1  1342	    092C  80 3E	001Ar 02		 cmp pmodetype,2		 ; if under VCPI, do VCPI GDT set up
1  1343	    0931  75 2D	90 90			 jne @@f0
1  1344	    0935  58				 pop ax				 ; restore TSS seg from	stack
1  1345	    0936  66| C1 E0 04			 shl eax,4			 ; set up TSS selector in GDT
1  1346	    093A  66| 26: A3 0022		 mov es:[SELVCPITSS+2],eax
1  1347	    093F  26: C6 06 0020 67		 mov byte ptr es:[SELVCPITSS],67h	 ; limit
1  1348	    0945  26: C6 06 0025 89		 mov byte ptr es:[SELVCPITSS+5],89h	 ; access rights
1  1349	    094B  66| 83 C0 40			 add eax,64h-4*9		 ; unused part of TSS is also
1  1350	    094F  66| A3 0076r			 mov vcpiswitchstack,eax	 ;  temporary switch stack
1  1351	    0953  BF 0028			 mov di,SELVCPICODE		 ; copy	3 VCPI descriptors from	stack
1  1352	    0956  8B F4				 mov si,sp			 ;  to GDT
1  1353	    0958  B1 0C				 mov cl,4*3
1  1354	    095A  F3> 36: A5			 rep movs word ptr es:[di],ss:[si]
1  1355	    095D  83 C4	18			 add sp,8*3			 ;***NOTE: (VCPI) adjust stack
1  1356
1  1357	    0960  B8 FFFF		 @@f0:	 mov ax,0FFFFh
1  1358	    0963  26: A3 0018			 mov word ptr es:[SELZERO],ax		 ; set SELZERO limit
1  1359	    0967  26: A3 0048			 mov word ptr es:[SELCALLBACK],ax	 ; set callback	DS limit
1  1360	    096B  B8 DF92			 mov ax,0DF92h
1  1361	    096E  26: A3 001D			 mov word ptr es:[SELZERO+5],ax		 ; set SELZERO rights
1  1362	    0972  26: A3 004D			 mov word ptr es:[SELCALLBACK+5],ax	 ; set callback	DS rights
1  1363
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 25
kernel.asm



1  1364	    0976  8C C8				 mov ax,cs			 ; AX =	base
1  1365	    0978  BB 0008			 mov bx,SELCODE			 ; BX =	index to SELCODE descriptor
1  1366	    097B  B9 FFFF			 mov cx,0FFFFh			 ; CX =	limit (64k)
1  1367	    097E  BA 109A			 mov dx,109Ah			 ; DX =	access rights
1  1368	    0981  E8 0302			 call vxr_initsetdsc
1  1369	    0984  BB 0010			 mov bx,SELDATA			 ; BX =	index to SELDATA descriptor
1  1370	    0987  BA 1092			 mov dx,1092h			 ; DX =	access rights
1  1371	    098A  E8 02F9			 call vxr_initsetdsc
1  1372	    098D  B8 0040			 mov ax,0040h
1  1373	    0990  BB 0040			 mov bx,SELBIOSDATA
1  1374	    0993  E8 02F0			 call vxr_initsetdsc
1  1375
1  1376	    0996  BB 0050			 mov bx,8*SYSSELECTORS		 ; BX =	base of	free descriptors
1  1377	    0999  53				 push bx			 ; store selector
1  1378	    099A  8C D0				 mov ax,ss			 ; set caller SS descriptor
1  1379	    099C  BA 5092			 mov dx,5092h
1  1380	    099F  E8 02E4			 call vxr_initsetdsc
1  1381	    09A2  8B 46	00			 mov ax,[bp]			 ; set caller DS descriptor
1  1382	    09A5  89 5E	00			 mov [bp],bx			 ; put DS selector on stack for	exit
1  1383	    09A8  E8 02DB			 call vxr_initsetdsc
1  1384
1  1385	    09AB  53				 push bx			 ; get PSP segment
1  1386	    09AC  B4 51				 mov ah,51h
1  1387	    09AE  CD 21				 int 21h
1  1388	    09B0  8B F3				 mov si,bx			 ; SI =	PSP segment
1  1389	    09B2  5B				 pop bx
1  1390
1  1391	    09B3  1E				 push ds
1  1392	    09B4  8E DE				 mov ds,si			 ; set caller environment descriptor
1  1393	    09B6  A1 002C			 mov ax,ds:[002Ch]
1  1394	    09B9  85 C0				 test ax,ax			 ; is environment seg 0?
1  1395	    09BB  74 0B	90 90			 jz @@f1			 ; if yes, dont	convert	to descriptor
1  1396	    09BF  89 1E	002C			 mov ds:[002Ch],bx		 ; store selector value	in PSP
1  1397	    09C3  E8 02C0			 call vxr_initsetdsc
1  1398	    09C6  8B C6				 mov ax,si			 ; set caller PSP descriptor
1  1399	    09C8  B9 00FF		 @@f1:	 mov cx,0FFh			 ; limit is 100h bytes
1  1400	    09CB  E8 02B8			 call vxr_initsetdsc
1  1401	    09CE  1F				 pop ds
1  1402
1  1403	    09CF  83 EB	08			 sub bx,8
1  1404	    09D2  8B CB				 mov cx,bx			 ; CX =	ES descriptor, PSP
1  1405	    09D4  5A				 pop dx				 ; DX =	SS descriptor, from stack
1  1406	    09D5  B8 0018			 mov ax,SELZERO			 ; AX =	DS descriptor, SELZERO
1  1407	    09D8  66| 0F B7 DC			 movzx ebx,sp			 ; EBX = SP, current SP	- same stack
1  1408	    09DC  BE 0008			 mov si,SELCODE			 ; target CS is	SELCODE, same segment
1  1409	    09DF  66| BF 000009E9r		 mov edi,offs @@swpm		 ; target EIP
1  1410	    09E5  FF 26	0044r			 jmp rmtopmswrout		 ; jump	to mode	switch routine
1  1411					 ;
1  1412					 ; now we are in protected mode
1  1413					 ;
1  1414	    09E9  FA			 @@swpm: cli
1  1415	    09EA  66| 2E: 8B 3E	0020r		 mov edi,cs:codebase		 ; EDI = offset	of _KERNEL from	0
1  1416	    09F0  66| 2E: A1 0054r		 mov eax,cs:vcpi_cr3		 ; EAX = CR3
1  1417	    09F5  0F 22	D8			 mov cr3,eax			 ; reload CR3 register to flush	TLB
1  1418	    09F8  66| 33 C0			 xor eax,eax
1  1419	    09FB  0F 22	D0			 mov cr2,eax			 ; reset CR2 page fault	addr register
1  1420	    09FE  0F 20	C0			 mov eax,cr0
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 26
kernel.asm



1  1421	    0A01  66| 67| 89 87	      +		 mov oldcr0[edi],eax		 ; preserve original CR0
   1422		  0000021Cr
1  1423
1  1424	    0A09  2E: 80 3E 0019r 00		 cmp cs:fputype,0
1  1425	    0A0F  67| 0F 95 87	      +		 setnz virtualfpu[edi]		 ; set client fpu status
   1426		  0000001Er
1  1427	    0A17  66| A1 006C			 mov eax,ds:[4*1Bh]		 ; preserve INT	1Bh - (CTRL-Break)
1  1428	    0A1B  66| 67| 89 87	      +		 mov oldint1Bh[edi],eax
   1429		  00000224r
1  1430	    0A23  66| A1 0070			 mov eax,ds:[4*1Ch]		 ; preserve INT	1Ch - (timer ticks)
1  1431	    0A27  66| 67| 89 87	      +		 mov oldint1Ch[edi],eax
   1432		  00000228r
1  1433	    0A2F  66| A1 0084			 mov eax,ds:[4*21h]		 ; preserve INT	21h - (DOS API)
1  1434	    0A33  66| 67| 89 87	      +		 mov oldint21h[edi],eax
   1435		  0000022Cr
1  1436	    0A3B  66| A1 008C			 mov eax,ds:[4*23h]		 ; preserve INT	23h - (DOS CTRL-C)
1  1437	    0A3F  66| 67| 89 87	      +		 mov oldint23h[edi],eax
   1438		  00000230r
1  1439	    0A47  66| A1 0090			 mov eax,ds:[4*24h]		 ; preserve INT	24h - (DOS Critical)
1  1440	    0A4B  66| 67| 89 87	      +		 mov oldint24h[edi],eax
   1441		  00000234r
1  1442	    0A53  66| A1 00BC			 mov eax,ds:[4*2Fh]		 ; preserve INT	2Fh - (Multiplex)
1  1443	    0A57  66| 67| 89 87	      +		 mov oldint2Fh[edi],eax
   1444		  00000238r
1  1445	    0A5F  2E: A1 0016r			 mov ax,cs:kernel_code		 ; install real	mode INT 21h
1  1446	    0A63  66| C1 E0 10			 shl eax,16
1  1447	    0A67  B8 0E29r			 mov ax,offs int21h
1  1448	    0A6A  66| A3 0084			 mov ds:[4*21h],eax
1  1449
1  1450	    0A6E  66| A1 0054			 mov eax,ds:[4*15h]		 ; get INT 15h vector
1  1451	    0A72  66| 67| 89 87	      +		 mov oldint15h[edi],eax		 ; store old INT 15h vector
   1452		  00000220r
1  1453	    0A7A  2E: 80 3E 001Ar 00		 cmp cs:pmodetype,0		 ; is system raw
1  1454	    0A80  75 1B	90 90			 jnz @@1			 ; if not, we are done
1  1455	    0A84  2E: 83 3E 0258r 00		 cmp cs:id32_process_id,0
1  1456	    0A8A  75 11	90 90			 jnz @@1
1  1457	    0A8E  2E: A1 0016r			 mov ax,cs:kernel_code
1  1458	    0A92  66| C1 E0 10			 shl eax,16
1  1459	    0A96  B8 0E09r			 mov ax,offs int15h
1  1460	    0A99  66| A3 0054			 mov ds:[4*15h],eax		 ; install new INT 15h handler
1  1461
1  1462	    0A9D  1E 06	66| 57		 @@1:	 push ds es edi
1  1463	    0AA1  0E				 push cs
1  1464	    0AA2  1F				 pop ds				 ; DS =	code base (executable)
1  1465	    0AA3  B8 0010			 mov es,seldata			 ; ES =	code base (writeable)
**Error** TEXT\KERNEL\init.asm(741) Illegal use	of segment register
1  1466	    0AA6  B8 0303			 mov ax,0303h
1  1467	    0AA9  66| BE 00000EFAr		 mov esi,offs int1Bh		 ;** NOTE: EDI points to init_code
1  1468	    0AAF  66| BF 00000540r		 mov edi,offs @callback_data+00h ;** EDI = callback data structure
1  1469	    0AB5  CD 31				 int 31h			 ;** which will	be used	only once
1  1470	    0AB7  51 52				 push cx dx			 ;** at	startup.
1  1471	    0AB9  BE 0F04r			 mov si,offs int1Ch
1  1472	    0ABC  BF 0572r			 mov di,offs @callback_data+32h
1  1473	    0ABF  CD 31				 int 31h
1  1474	    0AC1  51 52				 push cx dx
1  1475	    0AC3  BE 0F2Er			 mov si,offs int23h
1  1476	    0AC6  BF 05A4r			 mov di,offs @callback_data+64h
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 27
kernel.asm



1  1477	    0AC9  CD 31				 int 31h
1  1478	    0ACB  51 52				 push cx dx
1  1479	    0ACD  BE 0F50r			 mov si,offs int24h
1  1480	    0AD0  BF 05D6r			 mov di,offs @callback_data+96h
1  1481	    0AD3  CD 31				 int 31h
1  1482	    0AD5  51 52				 push cx dx
1  1483	    0AD7  B8 0010			 mov ds,seldata			 ; DS =	data selector
**Error** TEXT\KERNEL\init.asm(759) Illegal use	of segment register
1  1484	    0ADA  66| 8F 06 0248r		 pop newint24h
**Error** TEXT\KERNEL\init.asm(760) Forward reference needs override
1  1485	    0ADE  66| 8F 06 0244r		 pop newint23h
**Error** TEXT\KERNEL\init.asm(761) Forward reference needs override
1  1486	    0AE2  66| 8F 06 0240r		 pop newint1Ch
**Error** TEXT\KERNEL\init.asm(762) Forward reference needs override
1  1487	    0AE6  66| 8F 06 023Cr		 pop newint1Bh
**Error** TEXT\KERNEL\init.asm(763) Forward reference needs override
1  1488	    0AEA  66| 5F 07 1F			 pop edi es ds
1  1489
1  1490	    0AEE  66| 33 C0			 xor eax,eax
1  1491	    0AF1  66| 2E: 8B 1E	007Cr		 mov ebx,cs:mem_ptr		 ; EBX = base of extended memory
1  1492	    0AF7  66| 2E: 8B 0E	0080r		 mov ecx,cs:mem_free		 ; ECX = size of extended memory
1  1493	    0AFD  66| 8B D3			 mov edx,ebx			 ; align ptr to	memory on para boundary
1  1494	    0B00  66| 83 C3 0F			 add ebx,0Fh
1  1495	    0B04  80 E3	F0			 and bl,0F0h
1  1496	    0B07  66| 8B F3			 mov esi,ebx
1  1497	    0B0A  66| 2B F2			 sub esi,edx			 ; get the difference
1  1498	    0B0D  66| 83 C6 10			 add esi,10h			 ; plus	16 bytes for 1st block header
1  1499	    0B11  66| 2B CE			 sub ecx,esi			 ; reduce size of free memory
1  1500	    0B14  77 15	90 90			 ja @@2				 ; if no error,	jump
1  1501	    0B18  66| 67| 89 87	      +		 mov mem_ptr[edi],eax		 ; not enough memory even for one
   1502		  0000007Cr
1  1503	    0B20  66| 67| 89 87	      +		 mov mem_free[edi],eax		 ; memory block	header,	done now
   1504		  00000080r
1  1505	    0B28  EB 3E	90			 jmp @@done
1  1506
1  1507	    0B2B  66| B8 12345678	 @@2:	 mov eax,12345678h		 ; header id
1  1508	    0B31  66| 67| 89 03			 mov [ebx+00h],eax
1  1509	    0B35  66| 67| 89 43	0C		 mov [ebx+0Ch],eax
1  1510	    0B3A  66| 0F B7 06 0258r		 movzx eax,id32_process_id
1  1511	    0B40  66| 67| 89 43	08		 mov [ebx+08h],eax		 ; set current process id
1  1512	    0B45  66| 67| 89 4B	04		 mov [ebx+04h],ecx		 ; set first block unused/currentsize
1  1513	    0B4A  66| 67| 8D 54	0B 10		 lea edx,[ebx+ecx+10h]		 ; get pointer to next block (mem_top)
1  1514	    0B50  66| 67| 89 97	      +		 mov mem_top[edi],edx		 ; set top of memory
   1515		  00000084r
1  1516	    0B58  66| 67| 89 9F	      +		 mov mem_ptr[edi],ebx		 ; set base of memory
   1517		  0000007Cr
1  1518	    0B60  66| 67| 89 8F	      +		 mov mem_free[edi],ecx		 ; set size of memory
   1519		  00000080r
1  1520
1  1521	    0B68  FB			 @@done: sti
1  1522	    0B69  E9 F8C6			 jmp dvxr_init			 ; go to DPMI/VCPI/XMS/raw init	tail
1  1523
1  1524
1  1525
1  1526
1  1527
1  1528
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 28
kernel.asm



1  1529
1  1530					 ;-----------------------------------------------------------------------------
1  1531	    0B6C			 install_ints:
1  1532	    0B6C  33 FF				 xor di,di			 ; set up IDT
1  1533	    0B6E  66| 33 C9			 xor ecx,ecx
1  1534	    0B71  8B 16	001Cr			 mov dx,word ptr picslave
1  1535
1  1536	    0B75  66| 67| 8D 04	8D    +	 @@1:	 lea eax,[SELCODE*10000h+ecx*4+offs int_matrix]
   1537		  000811D0r
1  1538	    0B7E  66| AB			 stos dword ptr	es:[di]
1  1539	    0B80  66| B8 00008E00		 mov eax,8E00h			 ; interrupt gate type (IF=0)
1  1540	    0B86  8A D9				 mov bl,cl			 ; isolate high	5 bits of int num
1  1541	    0B88  80 E3	F8			 and bl,0F8h
1  1542	    0B8B  F6 C1	F0			 test cl,0F0h			 ; one of the low 16 interrupts?
1  1543	    0B8E  74 11	90 90			 jz @@2				 ; if yes, store as interrupt gate
1  1544	    0B92  3A DA				 cmp bl,dl			 ; one of the high IRQs?
1  1545	    0B94  74 0B	90 90			 je @@2				 ; if yes, store as interrupt gate
1  1546	    0B98  3A DE				 cmp bl,dh			 ; one of the low IRQs?
1  1547	    0B9A  74 05	90 90			 je @@2				 ; if yes, store as interrupt gate
1  1548	    0B9E  B8 8F00			 mov ax,8F00h			 ; set to trap gate type (IF=unchanged)
1  1549	    0BA1  66| AB		 @@2:	 stos dword ptr	es:[di]
1  1550	    0BA3  FE C1				 inc cl				 ; increment interrupt number
1  1551	    0BA5  75 CE				 jnz @@1			 ; loop	if more	interrupts to go
1  1552
1  1553	    0BA7  26: C7 06 0108 0CBDr		 mov word ptr es:[8*21h],offs int21 ; protected	mode INT 21h
1  1554	    0BAE  26: C7 06 0188 1C76r		 mov word ptr es:[8*31h],offs int31 ; protected	mode INT 31h
1  1555
1  1556	    0BB5  1E 06				 push ds es			 ; copy	IRQ vectors into table
1  1557	    0BB7  1E				 push ds
1  1558	    0BB8  07				 pop es
1  1559	    0BB9  33 C0				 xor ax,ax
1  1560	    0BBB  8E D8				 mov ds,ax
1  1561	    0BBD  BF 00D2r			 mov di,offs irqtab_rm
1  1562	    0BC0  0F B6	F6			 movzx si,dh
1  1563	    0BC3  C1 E6	02			 shl si,2
1  1564	    0BC6  B9 0008			 mov cx,8
1  1565	    0BC9  F3> 66| A5			 rep movs dword	ptr es:[di],ds:[si]
1  1566	    0BCC  0F B6	F2			 movzx si,dl
1  1567	    0BCF  C1 E6	02			 shl si,2
1  1568	    0BD2  B1 08				 mov cl,8
1  1569	    0BD4  F3> 66| A5			 rep movs dword	ptr es:[di],ds:[si]
1  1570	    0BD7  07 1F				 pop es	ds
1  1571
1  1572	    0BD9  F6 06	0000r 02		 test pm32_mode,00000010b	 ; if exception	handling is off
1  1573	    0BDE  74 36	90 90			 jz @@done			 ; we are done
1  1574					 ;
1  1575					 ; install INT 00h-0Eh exceptions
1  1576					 ;
1  1577	    0BE2  B8 1871r			 mov ax,offs irq_fail		 ; offset of fail routine
1  1578	    0BE5  2D 11D4r			 sub ax,offs int_matrix+4	 ; calculate offset displacement
1  1579	    0BE8  BF 11D2r			 mov di,offs int_matrix+2	 ; DI =	pointer	into CALL matrix
1  1580	    0BEB  B1 0F				 mov cl,15
1  1581	    0BED  89 05			 @@l1:	 mov ds:[di],ax			 ; modify CALL address
1  1582	    0BEF  2D 0004			 sub ax,4			 ; PUSH	+ CALL = 4 byte
1  1583	    0BF2  83 C7	04			 add di,4
1  1584	    0BF5  E2 F6				 loop @@l1
1  1585					 ;
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 29
kernel.asm



1  1586					 ; install IRQ 0-15 (PIC dependent)
1  1587					 ;
1  1588	    0BF7  0F B6	16 001Dr		 movzx dx,picmaster		 ; install IRQ 0-7 (INT	08-0Fh)
1  1589	    0BFC  E8 0018			 call setup_irqs
1  1590	    0BFF  0F B6	16 001Cr		 movzx dx,picslave		 ; install IRQ 8-15 (INT 70-77h)
1  1591	    0C04  E8 0010			 call setup_irqs
1  1592
1  1593	    0C07  80 3E	001Dr 10		 cmp picmaster,10h		 ; setup IRQ 7 (damn it!)
1  1594	    0C0C  73 08	90 90			 jae @@done
1  1595	    0C10  B8 05BC			 mov ax,(offs irq_normal) - (offs int_matrix+4)	- 0Fh*4
1  1596	    0C13  A3 120Er			 mov word ptr int_matrix[0Fh*4+2],ax	 ; restore INT 0Fh (IRQ	7)
1  1597
1  1598	    0C16  C3			 @@done: ret
1  1599
1  1600
1  1601	    0C17			 setup_irqs:
1  1602	    0C17  80 FA	10			 cmp dl,10h
1  1603	    0C1A  B8 17D7r			 mov ax,offs irq_tester		 ; if DX is in range INT 00h - 0Fh
1  1604	    0C1D  72 05	90 90			 jb @@4				 ;  install as IRQ check handler
1  1605	    0C21  B8 17CCr			 mov ax,offs irq_normal		 ; else	no IRQ check is	needed
1  1606	    0C24  C1 E2	02		 @@4:	 shl dx,2
1  1607	    0C27  2D 11D4r			 sub ax,offs int_matrix+4
1  1608	    0C2A  2B C2				 sub ax,dx
1  1609	    0C2C  BF 11D2r			 mov di,offs int_matrix+2
1  1610	    0C2F  03 FA				 add di,dx
1  1611	    0C31  B1 08				 mov cl,8			 ; 8 IRQs to go
1  1612	    0C33  89 05			 @@l3:	 mov ds:[di],ax
1  1613	    0C35  2D 0004			 sub ax,4			 ; PUSH	+ CALL is 4 bytes
1  1614	    0C38  83 C7	04			 add di,4			 ; next	entry in IDT
1  1615	    0C3B  E2 F6				 loop @@l3			 ; loop
1  1616	    0C3D  C3				 ret
1  1617
1  1618
1  1619					 ;-----------------------------------------------------------------------------
1  1620	    0C3E			 allocate_callbacks:
1  1621	    0C3E  0F B6	0E 0003r		 movzx cx,pm32_callbacks	 ; CL =	number of callbacks
1  1622	    0C43  E3 40				 jcxz @@done			 ; if no, done with this part
1  1623	    0C45  33 FF				 xor di,di			 ; location within callback seg
1  1624	    0C47  B8 6866			 mov ax,6866h
1  1625	    0C4A  8B 16	0016r			 mov dx,kernel_code
1  1626
1  1627	    0C4E  1E				 push ds
1  1628	    0C4F  06				 push es
1  1629	    0C50  1F				 pop ds
1  1630	    0C51  C7 05	6066		 @@1:	 mov word ptr ds:[di],6066h	 ; PUSHAD instruction
1  1631	    0C55  88 65	02			 mov byte ptr ds:[di+2],ah	 ; PUSH	WORD instruction
1  1632	    0C58  C7 45	03 0000			 mov word ptr ds:[di+3],0	 ; immediate 0 used as free flag
1  1633	    0C5D  89 45	05			 mov word ptr ds:[di+5],ax	 ; PUSH	DWORD instruction
1  1634	    0C60  C6 45	0B B9			 mov byte ptr ds:[di+11],0B9h	 ; MOV CX,? instruction
1  1635	    0C64  89 45	0E			 mov word ptr ds:[di+14],ax	 ; PUSH	DWORD instruction
1  1636	    0C67  C6 45	14 EA			 mov byte ptr ds:[di+20],0EAh	 ; JMP FAR PTR ?:? intruction
1  1637	    0C6B  C7 45	15 1A6Br		 mov word ptr ds:[di+21],offs callback
1  1638	    0C70  89 55	17			 mov word ptr ds:[di+23],dx
1  1639	    0C73  83 C7	19			 add di,25			 ; increment ptr to callback
1  1640	    0C76  E2 D9				 loop @@1			 ; if more callbacks to	do, loop
1  1641	    0C78  1F				 pop ds
1  1642
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 30
kernel.asm



1  1643	    0C79  83 C7	0F			 add di,0Fh			 ; align next data area	on paragraph
1  1644	    0C7C  C1 EF	04			 shr di,4
1  1645	    0C7F  8C C0				 mov ax,es
1  1646	    0C81  03 C7				 add ax,di
1  1647	    0C83  8E C0				 mov es,ax			 ; set ES to base of next data area
1  1648	    0C85  C3			 @@done: ret
1  1649
1  1650
1  1651					 ;-----------------------------------------------------------------------------
1  1652	    0C86			 vxr_initsetdsc:			 ; set descriptor for VCPI/XMS/raw init
1  1653	    0C86  50				 push ax
1  1654	    0C87  66| 0F B7 C0			 movzx eax,ax			 ; EAX = base of segment
1  1655	    0C8B  66| C1 E0 04			 shl eax,4
1  1656	    0C8F  26: 89 0F			 mov word ptr es:[bx],cx	 ; limit = CX
1  1657	    0C92  66| 26: 89 47	02		 mov dword ptr es:[bx+2],eax	 ; base	address	= EAX
1  1658	    0C97  26: 89 57 05			 mov word ptr es:[bx+5],dx	 ; access rights = DX
1  1659	    0C9B  83 C3	08			 add bx,8			 ; increment descriptor	index
1  1660	    0C9E  58				 pop ax
1  1661	    0C9F  C3				 ret
1  1662
1  1663
1  1664					 ;-----------------------------------------------------------------------------
1  1665	    0CA0			 xms_allocmem:
1  1666	    0CA0  66| 57			 push edi
1  1667	    0CA2  66| 8B FA			 mov edi,edx
1  1668	    0CA5  B4 89				 mov ah,89h
1  1669	    0CA7  FF 1E	004Ar			 call dword ptr	xms_call
1  1670	    0CAB  3D 0001			 cmp ax,0001h
1  1671	    0CAE  74 0A	90 90			 jz @@ok
1  1672	    0CB2  8B D7				 mov dx,di
1  1673	    0CB4  B4 09				 mov ah,09h
1  1674	    0CB6  FF 1E	004Ar			 call dword ptr	xms_call
1  1675	    0CBA  66| 5F		 @@ok:	 pop edi
1  1676	    0CBC  C3				 ret
1  1677
1  1678
1  1679
   1680					 include TEXT\KERNEL\exit.asm
1  1681					 ;
1  1682					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1  1683					 ;
1  1684					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1  1685					 ; modification,  are permitted	provided that the following conditions are
1  1686					 ; met:
1  1687					 ;
1  1688					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1  1689					 ; notice, this	list of	conditions and the following disclaimer.
1  1690					 ;
1  1691					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1  1692					 ; notice,  this  list of conditions and  the  following disclaimer in the
1  1693					 ; documentation and/or	other materials	provided with the distribution.
1  1694					 ;
1  1695					 ; 3. The end-user documentation included with the redistribution, if any,
1  1696					 ; must	include	the following acknowledgment:
1  1697					 ;
1  1698					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1  1699					 ;
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 31
kernel.asm



1  1700					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1  1701					 ; and wherever	such third-party acknowledgments normally appear.
1  1702					 ;
1  1703					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1  1704					 ; "DOS/32 Advanced".
1  1705					 ;
1  1706					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1  1707					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1  1708					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1  1709					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1  1710					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1  1711					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
1  1712					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1  1713					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1  1714					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
1  1715					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1  1716					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1  1717					 ;
1  1718					 ;
1  1719
1  1720					 ;=============================================================================
1  1721					 ; Exit	Protected Mode
1  1722					 ;=============================================================================
1  1723
1  1724	    0CBD  80 FC	4C		 int21:	 cmp ah,4Ch			 ; watch for INT 21h AH=4Ch
1  1725	    0CC0  74 05	90 90			 je @@0
1  1726	    0CC4  E9 058D			 jmp int_matrix+4*21h		 ; go to INT 21h redirection
1  1727	    0CC7  FA			 @@0:	 cli
1  1728	    0CC8  FC				 cld
1  1729	    0CC9  50				 push ax			 ; preserve AX error code
1  1730	    0CCA  2E: 8E 1E 0010		 mov ds,cs:seldata
1  1731	    0CCF  B8 0018			 mov es,selzero
**Error** TEXT\KERNEL\exit.asm(51) Illegal use of segment register
1  1732	    0CD2  66| A1 021Cr			 mov eax,oldcr0
1  1733	    0CD6  0F 22	C0			 mov cr0,eax
1  1734
1  1735	    0CD9  66| A1 0224r			 mov eax,oldint1Bh		 ; restore critical INTs
1  1736	    0CDD  66| 26: A3 006C		 mov es:[4*1Bh],eax
1  1737	    0CE2  66| A1 0228r			 mov eax,oldint1Ch
1  1738	    0CE6  66| 26: A3 0070		 mov es:[4*1Ch],eax
1  1739	    0CEB  66| A1 022Cr			 mov eax,oldint21h
1  1740	    0CEF  66| 26: A3 0084		 mov es:[4*21h],eax
1  1741	    0CF4  66| A1 0230r			 mov eax,oldint23h
1  1742	    0CF8  66| 26: A3 008C		 mov es:[4*23h],eax
1  1743	    0CFD  66| A1 0234r			 mov eax,oldint24h
1  1744	    0D01  66| 26: A3 0090		 mov es:[4*24h],eax
1  1745	    0D06  66| A1 0238r			 mov eax,oldint2Fh
1  1746	    0D0A  66| 26: A3 00BC		 mov es:[4*2Fh],eax
1  1747	    0D0F  E8 0017			 call mem_dealloc		 ; dealloc memory for current process
1  1748	    0D12  0F B6	1E 001Ar		 movzx bx,pmodetype		 ; appropriate exit routine
1  1749	    0D17  03 DB				 add bx,bx
1  1750	    0D19  FF 97	0D21r			 call @@exit[bx]		 ; call	cleanup	routine	on exit
1  1751	    0D1D  58				 pop ax				 ; restore AX
1  1752	    0D1E  E9 0533		 @@done: jmp int_matrix+4*21h		 ; go to INT 21h redirection
1  1753
1  1754	    0D21  0D77r			 @@exit	 dw r_exit
1  1755	    0D23  0D81r				 dw x_exit
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 32
kernel.asm



1  1756	    0D25  0D94r				 dw v_exit
1  1757	    0D27  0DDEr				 dw d_exit
1  1758
1  1759
1  1760
1  1761					 ;=============================================================================
1  1762	    0D29			 mem_dealloc:
1  1763	    0D29  83 3E	0258r 00		 cmp id32_process_id,0		 ; no need in freeing memory when
1  1764	    0D2E  74 46	90 90			 jz @@done			 ;  only one process is	running
1  1765	    0D32  66| 8B 36 007Cr		 mov esi,mem_ptr
1  1766	    0D37  66| A1 0080r			 mov eax,mem_free
1  1767	    0D3B  66| 0B C6			 or eax,esi			 ; check if memory was allocated
1  1768	    0D3E  74 36	90 90			 jz @@done			 ; if not, we are done
1  1769	    0D42  66| 26: 67| 8B 46 04	 @@1:	 mov eax,es:[esi+04h]
1  1770	    0D48  66| 26: 67| 8B 56 08		 mov edx,es:[esi+08h]
1  1771	    0D4E  66| 0F BA F0 1F		 btr eax,31
1  1772	    0D53  66| 3B 16 0258r		 cmp edx,dptr id32_process_id	 ; block allocated from	this process
1  1773	    0D58  75 08	90 90			 jnz @@2			 ; if not, jump
1  1774	    0D5C  66| 26: 67| 89 46 04		 mov es:[esi+04h],eax		 ; otherwise set this block as free
1  1775	    0D62  66| 67| 8D 74	06 10	 @@2:	 lea esi,[esi+eax+10h]		 ; get ptr to next memory block
1  1776	    0D68  66| 3B 36 0084r		 cmp esi,mem_top		 ; check if at top of memory
1  1777	    0D6D  72 D3				 jb @@1				 ; if not, loop
1  1778	    0D6F  1E 06				 push ds es
1  1779	    0D71  1F				 pop ds
1  1780	    0D72  E8 1D9A			 call int31_linkfreeblocks
1  1781	    0D75  1F				 pop ds
1  1782	    0D76  C3			 @@done: ret
1  1783
1  1784
1  1785					 ;=============================================================================
1  1786	    0D77  66| A1 0220r		 r_exit: mov eax,oldint15h		 ; put back old	INT 15h	handler
1  1787	    0D7B  66| 26: A3 0054		 mov es:[4*15h],eax
1  1788	    0D80  C3				 ret
1  1789
1  1790					 ;=============================================================================
1  1791	    0D81  E8 0013		 x_exit: call xms_dealloc
1  1792	    0D84  8A 26	001Fr			 mov ah,A20_state		 ; reset A20 gate to initial state
1  1793	    0D88  80 E4	01			 and ah,1
1  1794	    0D8B  80 F4	01			 xor ah,1			 ; calculate appropriate function num
1  1795	    0D8E  80 C4	03			 add ah,3
1  1796	    0D91  EB 15	90			 jmp xms_call_pm
1  1797
1  1798					 ;=============================================================================
1  1799	    0D94  E8 0048		 v_exit: call vcpi_dealloc
1  1800						 ;jmp xms_dealloc
1  1801
1  1802
1  1803					 ;-----------------------------------------------------------------------------
1  1804	    0D97			 xms_dealloc:				 ; XMS deallocate memory
1  1805	    0D97  8B 16	0052r			 mov dx,xms_handle		 ; check if memory was allocated
1  1806	    0D9B  85 D2				 test dx,dx
1  1807	    0D9D  74 3F	90 90			 jz d_exit			 ; if not, done
1  1808	    0DA1  B4 0D			 @@0:	 mov ah,0Dh			 ; unlock XMS memory
1  1809	    0DA3  E8 0002			 call xms_call_pm
1  1810	    0DA6  B4 0A				 mov ah,0Ah			 ; free	XMS memory
1  1811	    0DA8			 xms_call_pm:
1  1812	    0DA8  16				 push ss
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 33
kernel.asm



1  1813	    0DA9  07				 pop es
1  1814	    0DAA  66| 83 EC 32			 sub esp,32h
1  1815	    0DAE  66| 8B FC			 mov edi,esp
1  1816	    0DB1  66| 33 C9			 xor ecx,ecx
1  1817	    0DB4  67| 89 54 24 14		 mov [esp+14h],dx		 ; DX
1  1818	    0DB9  67| 89 44 24 1C		 mov [esp+1Ch],ax		 ; AX
1  1819	    0DBE  66| A1 004Ar			 mov eax,dword ptr xms_call	 ; real	mode CS:IP
1  1820	    0DC2  67| 89 4C 24 20		 mov [esp+20h],cx		 ; clear flags
1  1821	    0DC7  66| 67| 89 4C	24 2E		 mov [esp+2Eh],ecx		 ; clear SS:SP
1  1822	    0DCD  66| 67| 89 44	24 2A		 mov [esp+2Ah],eax		 ; put in structure
1  1823	    0DD3  33 DB				 xor bx,bx
1  1824	    0DD5  B8 0301			 mov ax,0301h
1  1825	    0DD8  CD 31				 int 31h
1  1826	    0DDA  66| 83 C4 32			 add esp,32h
1  1827	    0DDE  C3			 d_exit: ret
1  1828
1  1829	    0DDF			 vcpi_dealloc:				 ; VCPI	deallocate memory
1  1830	    0DDF  8B 0E	0070r			 mov cx,vcpi_allocmem		 ; check if memory was allocated
1  1831	    0DE3  66| 8B 36 0268r		 mov esi,pagetablefree
1  1832	    0DE8  E3 1E				 jcxz @@2			 ; if no memory	was allocated, done
1  1833	    0DEA  66| 26: 67| 8B 16	 @@1:	 mov edx,es:[esi]
1  1834	    0DEF  66| 83 C6 04			 add esi,4
1  1835	    0DF3  81 E2	F000			 and dx,0F000h
1  1836	    0DF7  B8 DE05			 mov ax,0DE05h
1  1837	    0DFA  66| FF 1E 006Ar		 call fword ptr	vcpi_calleip
1  1838	    0DFF  E2 E9				 loop @@1
1  1839	    0E01  66| A1 0054r			 mov eax,vcpi_cr3		 ; reload CR3 to flush page cache
1  1840	    0E05  0F 22	D8			 mov cr3,eax
1  1841	    0E08  C3			 @@2:	 ret
1  1842
1  1843
1  1844
   1845					 include TEXT\KERNEL\misc.asm
1  1846					 ;
1  1847					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1  1848					 ;
1  1849					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1  1850					 ; modification,  are permitted	provided that the following conditions are
1  1851					 ; met:
1  1852					 ;
1  1853					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1  1854					 ; notice, this	list of	conditions and the following disclaimer.
1  1855					 ;
1  1856					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1  1857					 ; notice,  this  list of conditions and  the  following disclaimer in the
1  1858					 ; documentation and/or	other materials	provided with the distribution.
1  1859					 ;
1  1860					 ; 3. The end-user documentation included with the redistribution, if any,
1  1861					 ; must	include	the following acknowledgment:
1  1862					 ;
1  1863					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1  1864					 ;
1  1865					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1  1866					 ; and wherever	such third-party acknowledgments normally appear.
1  1867					 ;
1  1868					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1  1869					 ; "DOS/32 Advanced".
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 34
kernel.asm



1  1870					 ;
1  1871					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1  1872					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1  1873					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1  1874					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1  1875					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1  1876					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
1  1877					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1  1878					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1  1879					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
1  1880					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1  1881					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1  1882					 ;
1  1883					 ;
1  1884
1  1885					 ;=============================================================================
1  1886	    0E09  80 FC	88		 int15h: cmp ah,88h			 ; Real	mode INT 15h
1  1887	    0E0C  74 07	90 90			 jz @@0				 ; if func: 88h, need to process
1  1888	    0E10  2E: FF 2E 0220r		 jmp cs:oldint15h		 ; no, go on to	old INT	15h handler
1  1889	    0E15  9C			 @@0:	 pushf				 ; call	old int	15h handler
1  1890	    0E16  2E: FF 1E 0220r		 call cs:oldint15h
1  1891	    0E1B  2E: 2B 06 0088r		 sub ax,cs:mem_used		 ; adjust AX by	extended memory	used
1  1892	    0E20  55				 push bp
1  1893	    0E21  8B EC				 mov bp,sp
1  1894	    0E23  80 66	06 FE			 and byte ptr [bp+6],0FEh	 ; clear carry flag on stack for IRET
1  1895	    0E27  5D				 pop bp
1  1896	    0E28  CF				 iret				 ; return with new AX extended memory
1  1897
1  1898
1  1899					 ;=============================================================================
1  1900	    0E29  2E: 80 3E 025Er 00	 int21h: cmp cs:id32_tsrmode_id,0	 ; if we are TSR, ignore 0FF88h	calls
1  1901	    0E2F  75 28	90 90			 jnz @@1
1  1902	    0E33  3D FF88			 cmp ax,0FF88h
1  1903	    0E36  74 64	90 90			 jz int21h_call
1  1904	    0E3A  2E: 80 3E 025Cr 00		 cmp cs:id32_spawned_id,0	 ; check if it is the mother process
1  1905	    0E40  75 17	90 90			 jnz @@1			 ; if not, chain to the	previous handlr
1  1906	    0E44  80 FC	4C			 cmp ah,4Ch			 ; Real	mode INT 21h
1  1907	    0E47  74 15	90 90			 jz int21h_exit
1  1908	    0E4B  80 FC	4B			 cmp ah,4Bh
1  1909	    0E4E  74 32	90 90			 jz int21h_spawn
1  1910	    0E52  80 FC	31			 cmp ah,31h
1  1911	    0E55  74 74	90 90			 jz int21h_tsr
1  1912	    0E59  2E: FF 2E 022Cr	 @@1:	 jmp cs:oldint21h		 ; go to original real mode INT	21h
1  1913
1  1914
1  1915					 ;-----------------------------------------------------------------------------
1  1916	    0E5E			 int21h_exit:
1  1917	    0E5E  FA				 cli
1  1918	    0E5F  8B E8				 mov bp,ax			 ; preserve AX=exit code
1  1919	    0E61  B8 0010			 mov ax,SELDATA			 ; DS selector for protected mode
1  1920	    0E64  8B C8				 mov cx,ax
1  1921	    0E66  BA 0018			 mov dx,SELZERO			 ; SS selector = zero selector
1  1922	    0E69  66| 2E: 8B 1E	02A4r		 mov ebx,cs:pmstacktop		 ; EBX = ESP for protected mode
1  1923	    0E6F  BE 0008			 mov si,SELCODE			 ; target protected mode CS:EIP
1  1924	    0E72  66| BF 00000E7Dr		 mov edi,offs @@1
1  1925	    0E78  2E: FF 26 0044r		 jmp cs:rmtopmswrout		 ; switch to protected mode
1  1926	    0E7D  8B C5			 @@1:	 mov ax,bp			 ; restore AX=exit code
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 35
kernel.asm



1  1927	    0E7F  E9 FE3B			 jmp int21
1  1928
1  1929					 ;-----------------------------------------------------------------------------
1  1930	    0E82			 int21h_spawn:
1  1931	    0E82  2E: C6 06 025Cr 01  +		 mov cs:id32_spawned_id,1	 ; disable memory deallocation
   1932		  90
1  1933	    0E89  9C				 pushf
1  1934	    0E8A  2E: FF 1E 022Cr		 call cs:oldint21h
1  1935	    0E8F  2E: C6 06 025Cr 00  +		 mov cs:id32_spawned_id,0
   1936		  90
1  1937	    0E96  5B 59	5A			 pop bx	cx dx			 ; pop IP, CS, FLG
1  1938	    0E99  51 53				 push cx bx			 ; push	CS, IP
1  1939	    0E9B  CB				 retf
1  1940
1  1941					 ;-----------------------------------------------------------------------------
1  1942	    0E9C			 int21h_call:				 ; DOS/32A functional call (real mode)
1  1943	    0E9C  66| B8 49443332		 mov eax,'ID32'			 ; EAX = "ID32"
1  1944	    0EA2  66| 2E: 0F B7	1E    +		 movzx ebx,cs:client_version	 ; EBX = client	version
   1945		  0014r
1  1946	    0EA9  66| 2E: 8B 0E	0080r		 mov ecx,cs:mem_free		 ; ECX = size of free memory
1  1947	    0EAF  66| 2E: 8B 16	007Cr		 mov edx,cs:mem_ptr		 ; EDX = base of free memory
1  1948	    0EB5  2E: 8B 36 0258r		 mov si,cs:id32_process_id	 ; SI(hi) = previous process id
1  1949	    0EBA  66| C1 E6 10			 shl esi,16
1  1950	    0EBE  2E: 0F B6 36 001Br		 movzx si,cs:pagetables		 ; SI(lo) = pagetables allocated
1  1951	    0EC4  66| 2E: 8B 3E	0268r		 mov edi,cs:pagetablefree	 ; EDI = base of free pagetable	space
1  1952	    0ECA  CF				 iret
1  1953
1  1954					 ;-----------------------------------------------------------------------------
1  1955	    0ECB			 int21h_tsr:
1  1956	    0ECB  2E: C6 06 025Er 01  +		 mov cs:id32_tsrmode_id,1	 ; indicate that we are	going TSR
   1957		  90
1  1958	    0ED2  2E: FF 2E 022Cr		 jmp cs:oldint21h
1  1959
1  1960
1  1961
1  1962
1  1963					 ;=============================================================================
1  1964	    0ED7			 intold_save:
1  1965	    0ED7  5D				 pop bp
1  1966	    0ED8  67| 8B 46 04			 mov ax,ds:[esi+04h]		 ; update FLAGS	in structure
1  1967	    0EDC  26: 67| 89 47	20		 mov es:[edi+20h],ax
1  1968	    0EE1  66| 67| 8B 06			 mov eax,ds:[esi+00h]		 ; update CS:IP	in structure
1  1969	    0EE5  66| 26: 67| 89 47 2A		 mov es:[edi+2Ah],eax
1  1970	    0EEB  06 66| 57			 push es edi
1  1971	    0EEE  FF E5				 jmp bp
1  1972
1  1973	    0EF0			 intold_restore:
1  1974	    0EF0  66| 5F 07			 pop edi es
1  1975	    0EF3  26: 67| 01 47	2E		 add es:[edi+2Eh],ax
1  1976	    0EF8  66| CF			 iretd
1  1977
1  1978
1  1979
1  1980					 ;-----------------------------------------------------------------------------
1  1981	    0EFA  E8 FFDA		 int1Bh: call intold_save
1  1982	    0EFD  CD 1B				 int 1Bh			 ; call	protected mode INT 1Bh
1  1983	    0EFF  B8 0006			 mov ax,6
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 36
kernel.asm



1  1984	    0F02  EB EC				 jmp intold_restore
1  1985
1  1986					 ;-----------------------------------------------------------------------------
1  1987	    0F04  E8 FFD0		 int1Ch: call intold_save
1  1988	    0F07  1E				 push ds
1  1989	    0F08  2E: 8E 1E 0018		 mov ds,cs:selzero		 ; restore default INT 1Ch
1  1990	    0F0D  66| 2E: A1 0228r		 mov eax,cs:oldint1Ch
1  1991	    0F12  66| A3 0070			 mov ds:[4*1Ch],eax
1  1992	    0F16  1F				 pop ds
1  1993	    0F17  CD 1C				 int 1Ch			 ; call	protected mode INT 1Ch
1  1994	    0F19  1E				 push ds
1  1995	    0F1A  2E: 8E 1E 0018		 mov ds,cs:selzero		 ; restore callback INT	1Ch
1  1996	    0F1F  66| 2E: A1 0240r		 mov eax,cs:newint1Ch
1  1997	    0F24  66| A3 0070			 mov ds:[4*1Ch],eax
1  1998	    0F28  1F				 pop ds
1  1999	    0F29  B8 0006			 mov ax,6
1  2000	    0F2C  EB C2				 jmp intold_restore
1  2001
1  2002					 ;-----------------------------------------------------------------------------
1  2003	    0F2E  E8 FFA6		 int23h: call intold_save
1  2004	    0F31  F8				 clc
1  2005	    0F32  66| 8B EC			 mov ebp,esp
1  2006	    0F35  CD 23				 int 23h			 ; call	protected mode INT 23h
1  2007	    0F37  66| 8B E5			 mov esp,ebp
1  2008	    0F3A  0F 92	C4			 setc ah
1  2009	    0F3D  26: 67| 8A 47	20		 mov al,es:[edi+20h]
1  2010	    0F42  24 FE				 and al,0FEh
1  2011	    0F44  02 C4				 add al,ah
1  2012	    0F46  26: 67| 88 47	20		 mov es:[edi+20h],al
1  2013	    0F4B  B8 0004			 mov ax,4
1  2014	    0F4E  EB A0				 jmp intold_restore
1  2015
1  2016					 ;-----------------------------------------------------------------------------
1  2017	    0F50  E8 FF84		 int24h: call intold_save
1  2018	    0F53  66| 57			 push edi
1  2019	    0F55  66| 67| FF 76	1A		 push dword ptr	ds:[esi+1Ah]	 ; CS, FLG
1  2020	    0F5A  66| 67| FF 76	16		 push dword ptr	ds:[esi+16h]	 ; ES, IP
1  2021	    0F5F  66| 67| FF 76	12		 push dword ptr	ds:[esi+12h]	 ; BP, DS
1  2022	    0F64  66| 67| FF 76	0E		 push dword ptr	ds:[esi+0Eh]	 ; SI, DI
1  2023	    0F69  66| 67| FF 76	0A		 push dword ptr	ds:[esi+0Ah]	 ; CX, DX
1  2024	    0F6E  66| 67| FF 76	06		 push dword ptr	ds:[esi+06h]	 ; AX, BX
1  2025	    0F73  26: 67| 8B 47	1C		 mov ax,word ptr es:[edi+1Ch]	 ; get register	AX
1  2026	    0F78  26: 67| 8B 6F	08		 mov bp,word ptr es:[edi+08h]	 ; get register	BP
1  2027	    0F7D  26: 67| 8B 77	04		 mov si,word ptr es:[edi+04h]	 ; get register	SI
1  2028	    0F82  26: 67| 8B 3F			 mov di,word ptr es:[edi+00h]	 ; get register	DI
1  2029	    0F86  CD 24				 int 24h			 ; call	protected mode INT 24h
1  2030	    0F88  66| 83 C4 18			 add esp,18h
1  2031	    0F8C  66| 5F			 pop edi
1  2032	    0F8E  26: 67| 88 47	1C		 mov es:[edi+1Ch],al
1  2033	    0F93  B8 0006			 mov ax,6
1  2034	    0F96  E9 FF57			 jmp intold_restore
1  2035
1  2036
1  2037
1  2038					 ;=============================================================================
1  2039					 ; Enable/Disable A20 Line
1  2040					 ;=============================================================================
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 37
kernel.asm



1  2041	    0F99			 enable_A20:				 ; hardware enable gate	A20
1  2042	    0F99  9C				 pushf
1  2043	    0F9A  FA				 cli
1  2044	    0F9B  E8 0071			 call enablea20test		 ; is A20 already enabled?
1  2045	    0F9E  0F 94	C0			 setz al			 ; AL =	00h (OFF),  AL = 01h (ON)
1  2046	    0FA1  A2 001Fr			 mov A20_state,al
1  2047	    0FA4  74 57	90 90			 jz @@done			 ; if yes, done
1  2048	    0FA8  E4 92				 in al,92h			 ; PS/2	A20 enable
1  2049	    0FAA  0C 02				 or al,02h
1  2050	    0FAC  EB 00				 jmp short $+2
1  2051	    0FAE  EB 00				 jmp short $+2
1  2052	    0FB0  EB 00				 jmp short $+2
1  2053	    0FB2  E6 92				 out 92h,al
1  2054	    0FB4  E8 0058			 call enablea20test
1  2055	    0FB7  74 44	90 90			 jz @@done
1  2056	    0FBB  E8 0042			 call enablea20kbwait		 ; AT A20 enable
1  2057	    0FBE  75 14	90 90			 jnz @@f0
1  2058	    0FC2  B0 D1				 mov al,0D1h
1  2059	    0FC4  E6 64				 out 64h,al
1  2060	    0FC6  E8 0037			 call enablea20kbwait
1  2061	    0FC9  75 09	90 90			 jnz @@f0
1  2062	    0FCD  B0 DF				 mov al,0DFh
1  2063	    0FCF  E6 60				 out 60h,al
1  2064	    0FD1  E8 002C			 call enablea20kbwait
1  2065	    0FD4  B9 0800		 @@f0:	 mov cx,800h			 ; wait	for A20	to enable do 800h tries
1  2066	    0FD7  E8 0035		 @@l0:	 call enablea20test		 ; is A20 enabled?
1  2067	    0FDA  74 21	90 90			 jz @@done			 ; if yes, done
1  2068	    0FDE  E4 40				 in al,40h			 ; get current tick counter
1  2069	    0FE0  EB 00				 jmp short $+2
1  2070	    0FE2  EB 00				 jmp short $+2
1  2071	    0FE4  EB 00				 jmp short $+2
1  2072	    0FE6  E4 40				 in al,40h
1  2073	    0FE8  8A E0				 mov ah,al
1  2074	    0FEA  E4 40			 @@l1:	 in al,40h			 ; wait	a single tick
1  2075	    0FEC  EB 00				 jmp short $+2
1  2076	    0FEE  EB 00				 jmp short $+2
1  2077	    0FF0  EB 00				 jmp short $+2
1  2078	    0FF2  E4 40				 in al,40h
1  2079	    0FF4  3A C4				 cmp al,ah
1  2080	    0FF6  74 F2				 je @@l1
1  2081	    0FF8  E2 DD				 loop @@l0			 ; loop	for another try
1  2082	    0FFA  9D				 popf
1  2083	    0FFB  F9				 stc				 ; error: set carry flag
1  2084	    0FFC  C3				 ret
1  2085	    0FFD  9D			 @@done: popf
1  2086	    0FFE  F8				 clc				 ; success: clear carry
1  2087	    0FFF  C3				 ret
1  2088
1  2089
1  2090					 ;-----------------------------------------------------------------------------
1  2091					 comment~
1  2092					 disable_A20:				 ; hardware disable gate A20
1  2093						 pushf
1  2094						 cli
1  2095						 mov al,cs:A20_state		 ; check if A20	was enabled from
1  2096						 test al,al			 ;  the	beginning
1  2097						 jnz @@done			 ; yes,	do not disable it, jump
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 38
kernel.asm



1  2098						 call disablea20test		 ; is A20 already disabled?
1  2099						 jnz @@done			 ; if yes, done
1  2100						 in al,92h			 ; PS/2	A20 disable
1  2101						 and al,0FDh
1  2102						 jmp short $+2
1  2103						 jmp short $+2
1  2104						 jmp short $+2
1  2105						 out 92h,al
1  2106						 call disablea20test
1  2107						 jnz @@done
1  2108						 call enablea20kbwait		 ; AT A20 disable
1  2109						 jnz @@f0
1  2110						 mov al,0D1h
1  2111						 out 64h,al
1  2112						 call enablea20kbwait
1  2113						 jnz @@f0
1  2114						 mov al,0DDh
1  2115						 out 60h,al
1  2116						 call enablea20kbwait
1  2117					 @@f0:	 mov cx,800h			 ; wait	for A20	to disable, 800h tries
1  2118					 @@l0:	 call disablea20test		 ; is A20 disabled?
1  2119						 jnz @@done			 ; if yes, done
1  2120						 in al,40h			 ; get current tick counter
1  2121						 jmp short $+2
1  2122						 jmp short $+2
1  2123						 jmp short $+2
1  2124						 in al,40h
1  2125						 mov ah,al
1  2126					 @@l1:	 in al,40h			 ; wait	a single tick
1  2127						 jmp short $+2
1  2128						 jmp short $+2
1  2129						 jmp short $+2
1  2130						 in al,40h
1  2131						 cmp al,ah
1  2132						 je @@l1
1  2133						 loop @@l0			 ; loop	for another try
1  2134						 popf
1  2135						 stc				 ; error: set carry flag
1  2136						 ret
1  2137					 @@done: popf
1  2138						 clc				 ; success: clear carry
1  2139						 ret
1  2140					 ~
1  2141
1  2142	    1000			 enablea20kbwait:			 ; wait	for safe to write to 8042
1  2143	    1000  33 C9				 xor cx,cx
1  2144	    1002  EB 00			 @@l0:	 jmp short $+2
1  2145	    1004  EB 00				 jmp short $+2
1  2146	    1006  EB 00				 jmp short $+2
1  2147	    1008  E4 64				 in al,64h			 ; read	8042 status
1  2148	    100A  A8 02				 test al,2			 ; buffer full?
1  2149	    100C  E0 F4				 loopnz	@@l0			 ; if yes, loop
1  2150	    100E  C3				 ret
1  2151
1  2152	    100F			 enablea20test:				 ; test	for enabled A20
1  2153	    100F  0F A0	0F A8			 push fs gs
1  2154	    1013  33 C0				 xor ax,ax			 ; set A20 test	segments 0 and 0ffffh
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 39
kernel.asm



1  2155	    1015  8E E0				 mov fs,ax
1  2156	    1017  48				 dec ax
1  2157	    1018  8E E8				 mov gs,ax
1  2158	    101A  64: A0 0000			 mov al,fs:[0000h]		 ; get byte from 0:0
1  2159	    101E  8A E0				 mov ah,al			 ; preserve old	byte
1  2160	    1020  F6 D0				 not al				 ; modify byte
1  2161	    1022  65: 86 06 0010		 xchg al,gs:[0010h]		 ; put modified	byte to	0ffffh:10h
1  2162	    1027  64: 3A 26 0000		 cmp ah,fs:[0000h]		 ; set zero if byte at 0:0 not modified
1  2163	    102C  65: A2 0010			 mov gs:[0010h],al		 ; put back old	byte at	0ffffh:10h
1  2164	    1030  0F A9	0F A1			 pop gs	fs
1  2165	    1034  C3				 ret				 ; return, zero	if A20 enabled
1  2166
1  2167					 comment~
1  2168					 disablea20test:			 ; test	for disabled A20
1  2169						 push ds esi edi
1  2170						 mov ds,cs:selzero
1  2171						 xor esi,esi
1  2172						 mov edi,100000h
1  2173						 mov al,[esi]
1  2174						 mov ah,al
1  2175						 not al
1  2176						 xchg al,[edi]
1  2177						 cmp ah,[esi]
1  2178						 mov [edi],al
1  2179						 pop edi esi ds
1  2180						 ret
1  2181					 ~
1  2182
1  2183
1  2184
1  2185					 ;=============================================================================
1  2186	    1035			 critical_error_rm:			 ; error in Protected Mode
1  2187	    1035  FA				 cli				 ; not enough space on real mode stack
1  2188	    1036  2E: 8E 1E 0010		 mov ds,cs:seldata
1  2189	    103B  B8 0018			 mov es,selzero
**Error** TEXT\KERNEL\misc.asm(340) Illegal use	of segment register
1  2190	    103E  66| A1 0228r			 mov eax,oldint1Ch		 ; restore INT 1Ch
1  2191	    1042  66| 26: A3 0070		 mov es:[4*1Ch],eax
1  2192	    1047  A1 02B2r			 mov ax,rmstacktop2		 ; restore RM stack
1  2193	    104A  A3 02B0r			 mov rmstacktop,ax
1  2194	    104D  B8 0081			 mov ax,0081h			 ; AX =	error code
1  2195	    1050  FF 2E	0010r			 jmp dword ptr client_call
1  2196
1  2197	    1054			 critical_error_pm:			 ; error in Real mode
1  2198	    1054  FA				 cli				 ; not enough space on prot. mode stack
1  2199	    1055  2E: 8E 1E 0016r		 mov ds,cs:kernel_code
1  2200	    105A  33 C0				 xor ax,ax
1  2201	    105C  8E C0				 mov es,ax
1  2202	    105E  66| A1 0228r			 mov eax,oldint1Ch
1  2203	    1062  66| 26: A3 0070		 mov es:[4*1Ch],eax
1  2204	    1067  66| A1 02A8r			 mov eax,pmstacktop2
1  2205	    106B  66| A3 02A4r			 mov pmstacktop,eax
1  2206	    106F  66| 8B D8			 mov ebx,eax			 ; EBX = ESP for protected mode
1  2207	    1072  B8 0010			 mov ax,SELDATA			 ; DS selector for protected mode
1  2208	    1075  8B C8				 mov cx,ax
1  2209	    1077  BA 0018			 mov dx,SELZERO			 ; SS selector = zero selector
1  2210	    107A  BE 0008			 mov si,SELCODE			 ; target protected mode CS:EIP
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 40
kernel.asm



1  2211	    107D  66| BF 00001087r		 mov edi,offs @@0
1  2212	    1083  FF 26	0044r			 jmp rmtopmswrout		 ; switch to protected mode
1  2213	    1087  B8 0082		 @@0:	 mov ax,0082h			 ; AX =	error code
1  2214	    108A  FF 2E	0010r			 jmp dword ptr client_call
1  2215
1  2216
   2217
   2218
   2219					 ;=============================================================================
   2220					 ; PROTECTED MODE KERNEL CODE
   2221
   2222					 include TEXT\KERNEL\mode.asm
1  2223					 ;
1  2224					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1  2225					 ;
1  2226					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1  2227					 ; modification,  are permitted	provided that the following conditions are
1  2228					 ; met:
1  2229					 ;
1  2230					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1  2231					 ; notice, this	list of	conditions and the following disclaimer.
1  2232					 ;
1  2233					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1  2234					 ; notice,  this  list of conditions and  the  following disclaimer in the
1  2235					 ; documentation and/or	other materials	provided with the distribution.
1  2236					 ;
1  2237					 ; 3. The end-user documentation included with the redistribution, if any,
1  2238					 ; must	include	the following acknowledgment:
1  2239					 ;
1  2240					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1  2241					 ;
1  2242					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1  2243					 ; and wherever	such third-party acknowledgments normally appear.
1  2244					 ;
1  2245					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1  2246					 ; "DOS/32 Advanced".
1  2247					 ;
1  2248					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1  2249					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1  2250					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1  2251					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1  2252					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1  2253					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
1  2254					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1  2255					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1  2256					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
1  2257					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1  2258					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1  2259					 ;
1  2260					 ;
1  2261
1  2262					 ;=============================================================================
1  2263					 ; Mode	Switching Routines
1  2264					 ;=============================================================================
1  2265
1  2266	    108E  01*(87 DB)			 Align 4
1  2267	    1090			 v_rmtopmsw:				 ; VCPI	real to	protected switch
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 41
kernel.asm



1  2268	    1090  9C				 pushf				 ; store FLAGS
1  2269	    1091  FA				 cli
1  2270	    1092  2E: 8E 1E 0016r		 mov ds,cs:kernel_code		 ; DS =	_KERNEL
1  2271	    1097  8F 06	0214r			 pop tempw0			 ; move	FLAGS from stack to temp
1  2272	    109B  A3 0216r			 mov tempw1,ax			 ; store AX (protected mode DS)
1  2273	    109E  89 36	0218r			 mov tempw2,si			 ; store SI (protected mode CS)
1  2274	    10A2  66| 8B 36 0072r		 mov esi,vcpistrucaddx		 ; ESI = linear	addx of	VCPI structure
1  2275	    10A7  B8 DE0C			 mov ax,0DE0Ch			 ; VCPI	switch to protected mode
1  2276	    10AA  CD 67				 int 67h
1  2277	    10AC			 v_rmtopmswpm:
1  2278	    10AC  8E D2				 mov ss,dx			 ; load	protected mode SS:ESP
1  2279	    10AE  66| 8B E3			 mov esp,ebx
1  2280	    10B1  2E: 8E 1E 0216r		 mov ds,cs:tempw1		 ; load	protected mode DS
1  2281	    10B6  8E C1				 mov es,cx			 ; load	protected mode ES
1  2282	    10B8  33 C0				 xor ax,ax
1  2283	    10BA  8E E0				 mov fs,ax			 ; load	protected mode FS with NULL
1  2284	    10BC  8E E8				 mov gs,ax			 ; load	protected mode GS with NULL
1  2285	    10BE  66| 9C			 pushfd				 ; store EFLAGS
1  2286	    10C0  2E: A1 0214r			 mov ax,cs:tempw0		 ; move	bits 0-11 of old FLAGS onto
1  2287	    10C4  80 E4	0F			 and ah,0Fh			 ;  stack for IRETD
1  2288	    10C7  67| 89 04 24			 mov [esp],ax
1  2289	    10CB  66| 2E: FF 36	0218r		 push cs:tempd1			 ; store protected mode	target CS
**Error** TEXT\KERNEL\mode.asm(67) Forward reference needs override
1  2290	    10D0  66| 57			 push edi			 ; store protected mode	target EIP
1  2291	    10D2  66| CF			 iretd				 ; go to targed	addx in	protected mode
1  2292
1  2293
1  2294					 ;-----------------------------------------------------------------------------
1  2295						 Align 4
1  2296	    10D4			 v_pmtormsw:				 ; VCPI	protected to real switch
1  2297	    10D4  9C				 pushf				 ; store FLAGS
1  2298	    10D5  FA				 cli
1  2299	    10D6  50				 push ax			 ; store AX (real mode DS)
1  2300	    10D7  2E: 8E 1E 0018		 mov ds,cs:selzero		 ; DS -> 0 (beginning of memory)
1  2301	    10DC  66| 81 E3 0000FFFF		 and ebx,0FFFFh			 ; clear high word of EBX, real	mode SP
1  2302	    10E3  66| 2E: A1 0076r		 mov eax,cs:vcpiswitchstack	 ; EAX -> top of temporary switch stack
1  2303	    10E8  66| 81 E2 0000FFFF		 and edx,0FFFFh			 ; clear high word of EDX, real	mode SS
1  2304	    10EF  66| 67| C7 40	20    +		 mov dword ptr ds:[eax+32],0	 ; store real mode GS
   2305		  00000000
1  2306	    10F8  66| 81 E1 0000FFFF		 and ecx,0FFFFh			 ; clear high word of ECX, real	mode ES
1  2307	    10FF  66| 67| C7 40	1C    +		 mov dword ptr ds:[eax+28],0	 ; store real mode FS
   2308		  00000000
1  2309	    1108  66| 67| 89 48	14		 mov ds:[eax+20],ecx		 ; store real mode ES
1  2310	    110D  59				 pop cx				 ; move	real mode DS from protected
1  2311	    110E  66| 67| 89 48	18		 mov ds:[eax+24],ecx		 ;  mode stack to VCPI call stack
1  2312	    1113  66| 67| 89 50	10		 mov ds:[eax+16],edx		 ; store real mode SS
1  2313	    1118  66| 67| 89 58	0C		 mov ds:[eax+12],ebx		 ; store real mode SP
1  2314	    111D  66| 67| C7 40	04    +		 mov dword ptr ds:[eax+4],_KERNEL	 ; store real mode CS
   2315		  00000000s
1  2316	    1126  66| 67| C7 00	      +		 mov dword ptr ds:[eax+0],offs @@0	 ; store real mode IP
   2317		  00001140r
1  2318	    112E  5B				 pop bx				 ; restore FLAGS from stack
1  2319	    112F  2E: 8E 16 0018		 mov ss,cs:selzero		 ; SS -> 0 (beginning of memory)
1  2320	    1134  66| 8B E0			 mov esp,eax			 ; ESP = stack ptr for VCPI call
1  2321	    1137  B8 DE0C			 mov ax,0DE0Ch			 ; VCPI	switch to real mode (V86)
1  2322	    113A  66| 2E: FF 1E	006Ar		 call fword ptr	cs:vcpi_calleip
1  2323	    1140  53			 @@0:	 push bx			 ; store old FLAGS
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 42
kernel.asm



1  2324	    1141  56				 push si			 ; store target	CS in real mode
1  2325	    1142  57				 push di			 ; store target	IP in real mode
1  2326	    1143  CF				 iret				 ; go to target	addx in	real mode
1  2327
1  2328
1  2329
1  2330
1  2331					 ;=============================================================================
1  2332						 Align 4
1  2333	    1144			 xr_rmtopmsw:				 ; XMS/raw real	to protected switch
1  2334	    1144  66| 9C			 pushfd				 ; store EFLAGS
1  2335	    1146  FA				 cli
1  2336	    1147  50				 push ax			 ; store AX (protected mode DS)
1  2337	    1148  2E: 0F 01 1E 0038r		 lidt fword ptr	cs:idtlimit	 ; load	protected mode IDT
1  2338	    114E  2E: 0F 01 16 0030r		 lgdt fword ptr	cs:gdtlimit	 ; load	protected mode GDT
1  2339	    1154  0F 01	E0			 smsw ax			 ; switch to protected mode
1  2340	    1157  0C 01				 or al,1
1  2341	    1159  0F 01	F0			 lmsw ax
1  2342	    115C  EA				 db 0EAh			 ; JMP FAR PTR SELCODE:$+4
1  2343	    115D  1161r	0008			 dw $+4,SELCODE			 ;  (clear prefetch que)
1  2344	    1161  1F				 pop ds				 ; load	protected mode DS
1  2345	    1162  8E C1				 mov es,cx			 ; load	protected mode ES
1  2346	    1164  33 C0				 xor ax,ax
1  2347	    1166  8E E0				 mov fs,ax			 ; load	protected mode FS with NULL
1  2348	    1168  8E E8				 mov gs,ax			 ; load	protected mode GS with NULL
1  2349	    116A  66| 58			 pop eax
1  2350	    116C  8E D2				 mov ss,dx			 ; load	protected mode SS:ESP
1  2351	    116E  66| 8B E3			 mov esp,ebx
1  2352	    1171  80 E4	BF			 and ah,0BFh			 ; set NT=0 in old EFLAGS
1  2353	    1174  50				 push ax			 ; set current FLAGS
1  2354	    1175  9D				 popf
1  2355	    1176  66| 50			 push eax			 ; store old EFLAGS
1  2356	    1178  66| 56			 push esi			 ; store protected mode	target CS
1  2357	    117A  66| 57			 push edi			 ; store protected mode	target EIP
1  2358	    117C  66| CF			 iretd				 ; go to targed	addx in	protected mode
1  2359
1  2360					 ;-----------------------------------------------------------------------------
1  2361	    117E  01*(87 DB)			 Align 4
1  2362	    1180			 xr_pmtormsw:				 ; XMS/raw protected to	real switch
1  2363	    1180  9C				 pushf				 ; store FLAGS
1  2364	    1181  FA				 cli
1  2365	    1182  50				 push ax			 ; store AX (real mode DS)
1  2366	    1183  2E: 8E 1E 0010		 mov ds,cs:seldata		 ; DS -> 0 (beginning of memory)
1  2367	    1188  8F 06	0214r			 pop tempw0			 ; move	real mode DS from stack	to temp
1  2368	    118C  8F 06	0216r			 pop tempw1			 ; move	FLAGS from stack to temp
1  2369	    1190  66| 33 E4			 xor esp,esp
1  2370	    1193  B8 0010			 mov ax,SELDATA			 ; load	descriptors with real mode seg
1  2371	    1196  8E D8				 mov ds,ax			 ;  attributes
1  2372	    1198  8E C0				 mov es,ax
1  2373	    119A  8E E0				 mov fs,ax
1  2374	    119C  8E E8				 mov gs,ax
1  2375	    119E  8E D0				 mov ss,ax			 ; load	descriptor with	real mode attr
1  2376	    11A0  8B E3				 mov sp,bx			 ; load	real mode SP, high word	0
1  2377	    11A2  0F 01	1E 003Er		 lidt fword ptr	rmidtlimit	 ; load	real mode IDT
1  2378	    11A7  0F 20	C0			 mov eax,cr0			 ; switch to real mode
1  2379	    11AA  24 FE				 and al,0FEh
1  2380	    11AC  0F 22	C0			 mov cr0,eax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 43
kernel.asm



1  2381	    11AF  EA				 db 0EAh			 ; JMP FAR PTR _KERNEL:$+4
1  2382	    11B0  11B4r	0000s			 dw $+4,_KERNEL			 ;  (clear prefetch que)
1  2383	    11B4  8E D2				 mov ss,dx			 ; load	real mode SS
1  2384	    11B6  2E: 8E 1E 0214r		 mov ds,cs:tempw0		 ; load	real mode DS
1  2385	    11BB  8E C1				 mov es,cx			 ; load	real mode ES
1  2386	    11BD  33 C0				 xor ax,ax
1  2387	    11BF  8E E0				 mov fs,ax			 ; load	real mode FS with NULL
1  2388	    11C1  8E E8				 mov gs,ax			 ; load	real mode GS with NULL
1  2389	    11C3  2E: FF 36 0216r		 push cs:tempw1			 ; store old FLAGS
1  2390	    11C8  56				 push si			 ; store real mode target CS
1  2391	    11C9  57				 push di			 ; store real mode target IP
1  2392	    11CA  CF				 iret				 ; go to target	addx in	real mode
1  2393
1  2394
1  2395
1  2396					 ;=============================================================================
1  2397	    11CB			 vxr_saverestorepm:			 ; VCPI/XMS/raw	save/restore status
1  2398	    11CB  66				 db 66h				 ; no save/restore needed, 32bit RETF
1  2399	    11CC			 vxr_saverestorerm:			 ; VCPI/XMS/raw	save/restore status
1  2400	    11CC  CB				 retf				 ; no save/restore needed, 16bit RETF
1  2401
1  2402
   2403					 include TEXT\KERNEL\intr.asm
1  2404					 ;
1  2405					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1  2406					 ;
1  2407					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1  2408					 ; modification,  are permitted	provided that the following conditions are
1  2409					 ; met:
1  2410					 ;
1  2411					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1  2412					 ; notice, this	list of	conditions and the following disclaimer.
1  2413					 ;
1  2414					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1  2415					 ; notice,  this  list of conditions and  the  following disclaimer in the
1  2416					 ; documentation and/or	other materials	provided with the distribution.
1  2417					 ;
1  2418					 ; 3. The end-user documentation included with the redistribution, if any,
1  2419					 ; must	include	the following acknowledgment:
1  2420					 ;
1  2421					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1  2422					 ;
1  2423					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1  2424					 ; and wherever	such third-party acknowledgments normally appear.
1  2425					 ;
1  2426					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1  2427					 ; "DOS/32 Advanced".
1  2428					 ;
1  2429					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1  2430					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1  2431					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1  2432					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1  2433					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1  2434					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
1  2435					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1  2436					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1  2437					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 44
kernel.asm



1  2438					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1  2439					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1  2440					 ;
1  2441					 ;
1  2442
1  2443					 ;=============================================================================
1  2444	    11CD  01*(87 DB) 90			 Align 16
1  2445	    11D0			 int_matrix:				 ; INT redirectors
1  2446						 rept 256			 ; 256 INTs
1  2447						 push ax
1  2448						 call near ptr int_main
1  2449						 endm
2  2450	    11D0  50				 push ax
2  2451	    11D1  E8 04BC			 call near ptr int_main
2  2452	    11D4  50				 push ax
2  2453	    11D5  E8 04B8			 call near ptr int_main
2  2454	    11D8  50				 push ax
2  2455	    11D9  E8 04B4			 call near ptr int_main
2  2456	    11DC  50				 push ax
2  2457	    11DD  E8 04B0			 call near ptr int_main
2  2458	    11E0  50				 push ax
2  2459	    11E1  E8 04AC			 call near ptr int_main
2  2460	    11E4  50				 push ax
2  2461	    11E5  E8 04A8			 call near ptr int_main
2  2462	    11E8  50				 push ax
2  2463	    11E9  E8 04A4			 call near ptr int_main
2  2464	    11EC  50				 push ax
2  2465	    11ED  E8 04A0			 call near ptr int_main
2  2466	    11F0  50				 push ax
2  2467	    11F1  E8 049C			 call near ptr int_main
2  2468	    11F4  50				 push ax
2  2469	    11F5  E8 0498			 call near ptr int_main
2  2470	    11F8  50				 push ax
2  2471	    11F9  E8 0494			 call near ptr int_main
2  2472	    11FC  50				 push ax
2  2473	    11FD  E8 0490			 call near ptr int_main
2  2474	    1200  50				 push ax
2  2475	    1201  E8 048C			 call near ptr int_main
2  2476	    1204  50				 push ax
2  2477	    1205  E8 0488			 call near ptr int_main
2  2478	    1208  50				 push ax
2  2479	    1209  E8 0484			 call near ptr int_main
2  2480	    120C  50				 push ax
2  2481	    120D  E8 0480			 call near ptr int_main
2  2482	    1210  50				 push ax
2  2483	    1211  E8 047C			 call near ptr int_main
2  2484	    1214  50				 push ax
2  2485	    1215  E8 0478			 call near ptr int_main
2  2486	    1218  50				 push ax
2  2487	    1219  E8 0474			 call near ptr int_main
2  2488	    121C  50				 push ax
2  2489	    121D  E8 0470			 call near ptr int_main
2  2490	    1220  50				 push ax
2  2491	    1221  E8 046C			 call near ptr int_main
2  2492	    1224  50				 push ax
2  2493	    1225  E8 0468			 call near ptr int_main
2  2494	    1228  50				 push ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 45
kernel.asm



2  2495	    1229  E8 0464			 call near ptr int_main
2  2496	    122C  50				 push ax
2  2497	    122D  E8 0460			 call near ptr int_main
2  2498	    1230  50				 push ax
2  2499	    1231  E8 045C			 call near ptr int_main
2  2500	    1234  50				 push ax
2  2501	    1235  E8 0458			 call near ptr int_main
2  2502	    1238  50				 push ax
2  2503	    1239  E8 0454			 call near ptr int_main
2  2504	    123C  50				 push ax
2  2505	    123D  E8 0450			 call near ptr int_main
2  2506	    1240  50				 push ax
2  2507	    1241  E8 044C			 call near ptr int_main
2  2508	    1244  50				 push ax
2  2509	    1245  E8 0448			 call near ptr int_main
2  2510	    1248  50				 push ax
2  2511	    1249  E8 0444			 call near ptr int_main
2  2512	    124C  50				 push ax
2  2513	    124D  E8 0440			 call near ptr int_main
2  2514	    1250  50				 push ax
2  2515	    1251  E8 043C			 call near ptr int_main
2  2516	    1254  50				 push ax
2  2517	    1255  E8 0438			 call near ptr int_main
2  2518	    1258  50				 push ax
2  2519	    1259  E8 0434			 call near ptr int_main
2  2520	    125C  50				 push ax
2  2521	    125D  E8 0430			 call near ptr int_main
2  2522	    1260  50				 push ax
2  2523	    1261  E8 042C			 call near ptr int_main
2  2524	    1264  50				 push ax
2  2525	    1265  E8 0428			 call near ptr int_main
2  2526	    1268  50				 push ax
2  2527	    1269  E8 0424			 call near ptr int_main
2  2528	    126C  50				 push ax
2  2529	    126D  E8 0420			 call near ptr int_main
2  2530	    1270  50				 push ax
2  2531	    1271  E8 041C			 call near ptr int_main
2  2532	    1274  50				 push ax
2  2533	    1275  E8 0418			 call near ptr int_main
2  2534	    1278  50				 push ax
2  2535	    1279  E8 0414			 call near ptr int_main
2  2536	    127C  50				 push ax
2  2537	    127D  E8 0410			 call near ptr int_main
2  2538	    1280  50				 push ax
2  2539	    1281  E8 040C			 call near ptr int_main
2  2540	    1284  50				 push ax
2  2541	    1285  E8 0408			 call near ptr int_main
2  2542	    1288  50				 push ax
2  2543	    1289  E8 0404			 call near ptr int_main
2  2544	    128C  50				 push ax
2  2545	    128D  E8 0400			 call near ptr int_main
2  2546	    1290  50				 push ax
2  2547	    1291  E8 03FC			 call near ptr int_main
2  2548	    1294  50				 push ax
2  2549	    1295  E8 03F8			 call near ptr int_main
2  2550	    1298  50				 push ax
2  2551	    1299  E8 03F4			 call near ptr int_main
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 46
kernel.asm



2  2552	    129C  50				 push ax
2  2553	    129D  E8 03F0			 call near ptr int_main
2  2554	    12A0  50				 push ax
2  2555	    12A1  E8 03EC			 call near ptr int_main
2  2556	    12A4  50				 push ax
2  2557	    12A5  E8 03E8			 call near ptr int_main
2  2558	    12A8  50				 push ax
2  2559	    12A9  E8 03E4			 call near ptr int_main
2  2560	    12AC  50				 push ax
2  2561	    12AD  E8 03E0			 call near ptr int_main
2  2562	    12B0  50				 push ax
2  2563	    12B1  E8 03DC			 call near ptr int_main
2  2564	    12B4  50				 push ax
2  2565	    12B5  E8 03D8			 call near ptr int_main
2  2566	    12B8  50				 push ax
2  2567	    12B9  E8 03D4			 call near ptr int_main
2  2568	    12BC  50				 push ax
2  2569	    12BD  E8 03D0			 call near ptr int_main
2  2570	    12C0  50				 push ax
2  2571	    12C1  E8 03CC			 call near ptr int_main
2  2572	    12C4  50				 push ax
2  2573	    12C5  E8 03C8			 call near ptr int_main
2  2574	    12C8  50				 push ax
2  2575	    12C9  E8 03C4			 call near ptr int_main
2  2576	    12CC  50				 push ax
2  2577	    12CD  E8 03C0			 call near ptr int_main
2  2578	    12D0  50				 push ax
2  2579	    12D1  E8 03BC			 call near ptr int_main
2  2580	    12D4  50				 push ax
2  2581	    12D5  E8 03B8			 call near ptr int_main
2  2582	    12D8  50				 push ax
2  2583	    12D9  E8 03B4			 call near ptr int_main
2  2584	    12DC  50				 push ax
2  2585	    12DD  E8 03B0			 call near ptr int_main
2  2586	    12E0  50				 push ax
2  2587	    12E1  E8 03AC			 call near ptr int_main
2  2588	    12E4  50				 push ax
2  2589	    12E5  E8 03A8			 call near ptr int_main
2  2590	    12E8  50				 push ax
2  2591	    12E9  E8 03A4			 call near ptr int_main
2  2592	    12EC  50				 push ax
2  2593	    12ED  E8 03A0			 call near ptr int_main
2  2594	    12F0  50				 push ax
2  2595	    12F1  E8 039C			 call near ptr int_main
2  2596	    12F4  50				 push ax
2  2597	    12F5  E8 0398			 call near ptr int_main
2  2598	    12F8  50				 push ax
2  2599	    12F9  E8 0394			 call near ptr int_main
2  2600	    12FC  50				 push ax
2  2601	    12FD  E8 0390			 call near ptr int_main
2  2602	    1300  50				 push ax
2  2603	    1301  E8 038C			 call near ptr int_main
2  2604	    1304  50				 push ax
2  2605	    1305  E8 0388			 call near ptr int_main
2  2606	    1308  50				 push ax
2  2607	    1309  E8 0384			 call near ptr int_main
2  2608	    130C  50				 push ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 47
kernel.asm



2  2609	    130D  E8 0380			 call near ptr int_main
2  2610	    1310  50				 push ax
2  2611	    1311  E8 037C			 call near ptr int_main
2  2612	    1314  50				 push ax
2  2613	    1315  E8 0378			 call near ptr int_main
2  2614	    1318  50				 push ax
2  2615	    1319  E8 0374			 call near ptr int_main
2  2616	    131C  50				 push ax
2  2617	    131D  E8 0370			 call near ptr int_main
2  2618	    1320  50				 push ax
2  2619	    1321  E8 036C			 call near ptr int_main
2  2620	    1324  50				 push ax
2  2621	    1325  E8 0368			 call near ptr int_main
2  2622	    1328  50				 push ax
2  2623	    1329  E8 0364			 call near ptr int_main
2  2624	    132C  50				 push ax
2  2625	    132D  E8 0360			 call near ptr int_main
2  2626	    1330  50				 push ax
2  2627	    1331  E8 035C			 call near ptr int_main
2  2628	    1334  50				 push ax
2  2629	    1335  E8 0358			 call near ptr int_main
2  2630	    1338  50				 push ax
2  2631	    1339  E8 0354			 call near ptr int_main
2  2632	    133C  50				 push ax
2  2633	    133D  E8 0350			 call near ptr int_main
2  2634	    1340  50				 push ax
2  2635	    1341  E8 034C			 call near ptr int_main
2  2636	    1344  50				 push ax
2  2637	    1345  E8 0348			 call near ptr int_main
2  2638	    1348  50				 push ax
2  2639	    1349  E8 0344			 call near ptr int_main
2  2640	    134C  50				 push ax
2  2641	    134D  E8 0340			 call near ptr int_main
2  2642	    1350  50				 push ax
2  2643	    1351  E8 033C			 call near ptr int_main
2  2644	    1354  50				 push ax
2  2645	    1355  E8 0338			 call near ptr int_main
2  2646	    1358  50				 push ax
2  2647	    1359  E8 0334			 call near ptr int_main
2  2648	    135C  50				 push ax
2  2649	    135D  E8 0330			 call near ptr int_main
2  2650	    1360  50				 push ax
2  2651	    1361  E8 032C			 call near ptr int_main
2  2652	    1364  50				 push ax
2  2653	    1365  E8 0328			 call near ptr int_main
2  2654	    1368  50				 push ax
2  2655	    1369  E8 0324			 call near ptr int_main
2  2656	    136C  50				 push ax
2  2657	    136D  E8 0320			 call near ptr int_main
2  2658	    1370  50				 push ax
2  2659	    1371  E8 031C			 call near ptr int_main
2  2660	    1374  50				 push ax
2  2661	    1375  E8 0318			 call near ptr int_main
2  2662	    1378  50				 push ax
2  2663	    1379  E8 0314			 call near ptr int_main
2  2664	    137C  50				 push ax
2  2665	    137D  E8 0310			 call near ptr int_main
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 48
kernel.asm



2  2666	    1380  50				 push ax
2  2667	    1381  E8 030C			 call near ptr int_main
2  2668	    1384  50				 push ax
2  2669	    1385  E8 0308			 call near ptr int_main
2  2670	    1388  50				 push ax
2  2671	    1389  E8 0304			 call near ptr int_main
2  2672	    138C  50				 push ax
2  2673	    138D  E8 0300			 call near ptr int_main
2  2674	    1390  50				 push ax
2  2675	    1391  E8 02FC			 call near ptr int_main
2  2676	    1394  50				 push ax
2  2677	    1395  E8 02F8			 call near ptr int_main
2  2678	    1398  50				 push ax
2  2679	    1399  E8 02F4			 call near ptr int_main
2  2680	    139C  50				 push ax
2  2681	    139D  E8 02F0			 call near ptr int_main
2  2682	    13A0  50				 push ax
2  2683	    13A1  E8 02EC			 call near ptr int_main
2  2684	    13A4  50				 push ax
2  2685	    13A5  E8 02E8			 call near ptr int_main
2  2686	    13A8  50				 push ax
2  2687	    13A9  E8 02E4			 call near ptr int_main
2  2688	    13AC  50				 push ax
2  2689	    13AD  E8 02E0			 call near ptr int_main
2  2690	    13B0  50				 push ax
2  2691	    13B1  E8 02DC			 call near ptr int_main
2  2692	    13B4  50				 push ax
2  2693	    13B5  E8 02D8			 call near ptr int_main
2  2694	    13B8  50				 push ax
2  2695	    13B9  E8 02D4			 call near ptr int_main
2  2696	    13BC  50				 push ax
2  2697	    13BD  E8 02D0			 call near ptr int_main
2  2698	    13C0  50				 push ax
2  2699	    13C1  E8 02CC			 call near ptr int_main
2  2700	    13C4  50				 push ax
2  2701	    13C5  E8 02C8			 call near ptr int_main
2  2702	    13C8  50				 push ax
2  2703	    13C9  E8 02C4			 call near ptr int_main
2  2704	    13CC  50				 push ax
2  2705	    13CD  E8 02C0			 call near ptr int_main
2  2706	    13D0  50				 push ax
2  2707	    13D1  E8 02BC			 call near ptr int_main
2  2708	    13D4  50				 push ax
2  2709	    13D5  E8 02B8			 call near ptr int_main
2  2710	    13D8  50				 push ax
2  2711	    13D9  E8 02B4			 call near ptr int_main
2  2712	    13DC  50				 push ax
2  2713	    13DD  E8 02B0			 call near ptr int_main
2  2714	    13E0  50				 push ax
2  2715	    13E1  E8 02AC			 call near ptr int_main
2  2716	    13E4  50				 push ax
2  2717	    13E5  E8 02A8			 call near ptr int_main
2  2718	    13E8  50				 push ax
2  2719	    13E9  E8 02A4			 call near ptr int_main
2  2720	    13EC  50				 push ax
2  2721	    13ED  E8 02A0			 call near ptr int_main
2  2722	    13F0  50				 push ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 49
kernel.asm



2  2723	    13F1  E8 029C			 call near ptr int_main
2  2724	    13F4  50				 push ax
2  2725	    13F5  E8 0298			 call near ptr int_main
2  2726	    13F8  50				 push ax
2  2727	    13F9  E8 0294			 call near ptr int_main
2  2728	    13FC  50				 push ax
2  2729	    13FD  E8 0290			 call near ptr int_main
2  2730	    1400  50				 push ax
2  2731	    1401  E8 028C			 call near ptr int_main
2  2732	    1404  50				 push ax
2  2733	    1405  E8 0288			 call near ptr int_main
2  2734	    1408  50				 push ax
2  2735	    1409  E8 0284			 call near ptr int_main
2  2736	    140C  50				 push ax
2  2737	    140D  E8 0280			 call near ptr int_main
2  2738	    1410  50				 push ax
2  2739	    1411  E8 027C			 call near ptr int_main
2  2740	    1414  50				 push ax
2  2741	    1415  E8 0278			 call near ptr int_main
2  2742	    1418  50				 push ax
2  2743	    1419  E8 0274			 call near ptr int_main
2  2744	    141C  50				 push ax
2  2745	    141D  E8 0270			 call near ptr int_main
2  2746	    1420  50				 push ax
2  2747	    1421  E8 026C			 call near ptr int_main
2  2748	    1424  50				 push ax
2  2749	    1425  E8 0268			 call near ptr int_main
2  2750	    1428  50				 push ax
2  2751	    1429  E8 0264			 call near ptr int_main
2  2752	    142C  50				 push ax
2  2753	    142D  E8 0260			 call near ptr int_main
2  2754	    1430  50				 push ax
2  2755	    1431  E8 025C			 call near ptr int_main
2  2756	    1434  50				 push ax
2  2757	    1435  E8 0258			 call near ptr int_main
2  2758	    1438  50				 push ax
2  2759	    1439  E8 0254			 call near ptr int_main
2  2760	    143C  50				 push ax
2  2761	    143D  E8 0250			 call near ptr int_main
2  2762	    1440  50				 push ax
2  2763	    1441  E8 024C			 call near ptr int_main
2  2764	    1444  50				 push ax
2  2765	    1445  E8 0248			 call near ptr int_main
2  2766	    1448  50				 push ax
2  2767	    1449  E8 0244			 call near ptr int_main
2  2768	    144C  50				 push ax
2  2769	    144D  E8 0240			 call near ptr int_main
2  2770	    1450  50				 push ax
2  2771	    1451  E8 023C			 call near ptr int_main
2  2772	    1454  50				 push ax
2  2773	    1455  E8 0238			 call near ptr int_main
2  2774	    1458  50				 push ax
2  2775	    1459  E8 0234			 call near ptr int_main
2  2776	    145C  50				 push ax
2  2777	    145D  E8 0230			 call near ptr int_main
2  2778	    1460  50				 push ax
2  2779	    1461  E8 022C			 call near ptr int_main
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 50
kernel.asm



2  2780	    1464  50				 push ax
2  2781	    1465  E8 0228			 call near ptr int_main
2  2782	    1468  50				 push ax
2  2783	    1469  E8 0224			 call near ptr int_main
2  2784	    146C  50				 push ax
2  2785	    146D  E8 0220			 call near ptr int_main
2  2786	    1470  50				 push ax
2  2787	    1471  E8 021C			 call near ptr int_main
2  2788	    1474  50				 push ax
2  2789	    1475  E8 0218			 call near ptr int_main
2  2790	    1478  50				 push ax
2  2791	    1479  E8 0214			 call near ptr int_main
2  2792	    147C  50				 push ax
2  2793	    147D  E8 0210			 call near ptr int_main
2  2794	    1480  50				 push ax
2  2795	    1481  E8 020C			 call near ptr int_main
2  2796	    1484  50				 push ax
2  2797	    1485  E8 0208			 call near ptr int_main
2  2798	    1488  50				 push ax
2  2799	    1489  E8 0204			 call near ptr int_main
2  2800	    148C  50				 push ax
2  2801	    148D  E8 0200			 call near ptr int_main
2  2802	    1490  50				 push ax
2  2803	    1491  E8 01FC			 call near ptr int_main
2  2804	    1494  50				 push ax
2  2805	    1495  E8 01F8			 call near ptr int_main
2  2806	    1498  50				 push ax
2  2807	    1499  E8 01F4			 call near ptr int_main
2  2808	    149C  50				 push ax
2  2809	    149D  E8 01F0			 call near ptr int_main
2  2810	    14A0  50				 push ax
2  2811	    14A1  E8 01EC			 call near ptr int_main
2  2812	    14A4  50				 push ax
2  2813	    14A5  E8 01E8			 call near ptr int_main
2  2814	    14A8  50				 push ax
2  2815	    14A9  E8 01E4			 call near ptr int_main
2  2816	    14AC  50				 push ax
2  2817	    14AD  E8 01E0			 call near ptr int_main
2  2818	    14B0  50				 push ax
2  2819	    14B1  E8 01DC			 call near ptr int_main
2  2820	    14B4  50				 push ax
2  2821	    14B5  E8 01D8			 call near ptr int_main
2  2822	    14B8  50				 push ax
2  2823	    14B9  E8 01D4			 call near ptr int_main
2  2824	    14BC  50				 push ax
2  2825	    14BD  E8 01D0			 call near ptr int_main
2  2826	    14C0  50				 push ax
2  2827	    14C1  E8 01CC			 call near ptr int_main
2  2828	    14C4  50				 push ax
2  2829	    14C5  E8 01C8			 call near ptr int_main
2  2830	    14C8  50				 push ax
2  2831	    14C9  E8 01C4			 call near ptr int_main
2  2832	    14CC  50				 push ax
2  2833	    14CD  E8 01C0			 call near ptr int_main
2  2834	    14D0  50				 push ax
2  2835	    14D1  E8 01BC			 call near ptr int_main
2  2836	    14D4  50				 push ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 51
kernel.asm



2  2837	    14D5  E8 01B8			 call near ptr int_main
2  2838	    14D8  50				 push ax
2  2839	    14D9  E8 01B4			 call near ptr int_main
2  2840	    14DC  50				 push ax
2  2841	    14DD  E8 01B0			 call near ptr int_main
2  2842	    14E0  50				 push ax
2  2843	    14E1  E8 01AC			 call near ptr int_main
2  2844	    14E4  50				 push ax
2  2845	    14E5  E8 01A8			 call near ptr int_main
2  2846	    14E8  50				 push ax
2  2847	    14E9  E8 01A4			 call near ptr int_main
2  2848	    14EC  50				 push ax
2  2849	    14ED  E8 01A0			 call near ptr int_main
2  2850	    14F0  50				 push ax
2  2851	    14F1  E8 019C			 call near ptr int_main
2  2852	    14F4  50				 push ax
2  2853	    14F5  E8 0198			 call near ptr int_main
2  2854	    14F8  50				 push ax
2  2855	    14F9  E8 0194			 call near ptr int_main
2  2856	    14FC  50				 push ax
2  2857	    14FD  E8 0190			 call near ptr int_main
2  2858	    1500  50				 push ax
2  2859	    1501  E8 018C			 call near ptr int_main
2  2860	    1504  50				 push ax
2  2861	    1505  E8 0188			 call near ptr int_main
2  2862	    1508  50				 push ax
2  2863	    1509  E8 0184			 call near ptr int_main
2  2864	    150C  50				 push ax
2  2865	    150D  E8 0180			 call near ptr int_main
2  2866	    1510  50				 push ax
2  2867	    1511  E8 017C			 call near ptr int_main
2  2868	    1514  50				 push ax
2  2869	    1515  E8 0178			 call near ptr int_main
2  2870	    1518  50				 push ax
2  2871	    1519  E8 0174			 call near ptr int_main
2  2872	    151C  50				 push ax
2  2873	    151D  E8 0170			 call near ptr int_main
2  2874	    1520  50				 push ax
2  2875	    1521  E8 016C			 call near ptr int_main
2  2876	    1524  50				 push ax
2  2877	    1525  E8 0168			 call near ptr int_main
2  2878	    1528  50				 push ax
2  2879	    1529  E8 0164			 call near ptr int_main
2  2880	    152C  50				 push ax
2  2881	    152D  E8 0160			 call near ptr int_main
2  2882	    1530  50				 push ax
2  2883	    1531  E8 015C			 call near ptr int_main
2  2884	    1534  50				 push ax
2  2885	    1535  E8 0158			 call near ptr int_main
2  2886	    1538  50				 push ax
2  2887	    1539  E8 0154			 call near ptr int_main
2  2888	    153C  50				 push ax
2  2889	    153D  E8 0150			 call near ptr int_main
2  2890	    1540  50				 push ax
2  2891	    1541  E8 014C			 call near ptr int_main
2  2892	    1544  50				 push ax
2  2893	    1545  E8 0148			 call near ptr int_main
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 52
kernel.asm



2  2894	    1548  50				 push ax
2  2895	    1549  E8 0144			 call near ptr int_main
2  2896	    154C  50				 push ax
2  2897	    154D  E8 0140			 call near ptr int_main
2  2898	    1550  50				 push ax
2  2899	    1551  E8 013C			 call near ptr int_main
2  2900	    1554  50				 push ax
2  2901	    1555  E8 0138			 call near ptr int_main
2  2902	    1558  50				 push ax
2  2903	    1559  E8 0134			 call near ptr int_main
2  2904	    155C  50				 push ax
2  2905	    155D  E8 0130			 call near ptr int_main
2  2906	    1560  50				 push ax
2  2907	    1561  E8 012C			 call near ptr int_main
2  2908	    1564  50				 push ax
2  2909	    1565  E8 0128			 call near ptr int_main
2  2910	    1568  50				 push ax
2  2911	    1569  E8 0124			 call near ptr int_main
2  2912	    156C  50				 push ax
2  2913	    156D  E8 0120			 call near ptr int_main
2  2914	    1570  50				 push ax
2  2915	    1571  E8 011C			 call near ptr int_main
2  2916	    1574  50				 push ax
2  2917	    1575  E8 0118			 call near ptr int_main
2  2918	    1578  50				 push ax
2  2919	    1579  E8 0114			 call near ptr int_main
2  2920	    157C  50				 push ax
2  2921	    157D  E8 0110			 call near ptr int_main
2  2922	    1580  50				 push ax
2  2923	    1581  E8 010C			 call near ptr int_main
2  2924	    1584  50				 push ax
2  2925	    1585  E8 0108			 call near ptr int_main
2  2926	    1588  50				 push ax
2  2927	    1589  E8 0104			 call near ptr int_main
2  2928	    158C  50				 push ax
2  2929	    158D  E8 0100			 call near ptr int_main
2  2930	    1590  50				 push ax
2  2931	    1591  E8 00FC			 call near ptr int_main
2  2932	    1594  50				 push ax
2  2933	    1595  E8 00F8			 call near ptr int_main
2  2934	    1598  50				 push ax
2  2935	    1599  E8 00F4			 call near ptr int_main
2  2936	    159C  50				 push ax
2  2937	    159D  E8 00F0			 call near ptr int_main
2  2938	    15A0  50				 push ax
2  2939	    15A1  E8 00EC			 call near ptr int_main
2  2940	    15A4  50				 push ax
2  2941	    15A5  E8 00E8			 call near ptr int_main
2  2942	    15A8  50				 push ax
2  2943	    15A9  E8 00E4			 call near ptr int_main
2  2944	    15AC  50				 push ax
2  2945	    15AD  E8 00E0			 call near ptr int_main
2  2946	    15B0  50				 push ax
2  2947	    15B1  E8 00DC			 call near ptr int_main
2  2948	    15B4  50				 push ax
2  2949	    15B5  E8 00D8			 call near ptr int_main
2  2950	    15B8  50				 push ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 53
kernel.asm



2  2951	    15B9  E8 00D4			 call near ptr int_main
2  2952	    15BC  50				 push ax
2  2953	    15BD  E8 00D0			 call near ptr int_main
2  2954	    15C0  50				 push ax
2  2955	    15C1  E8 00CC			 call near ptr int_main
2  2956	    15C4  50				 push ax
2  2957	    15C5  E8 00C8			 call near ptr int_main
2  2958	    15C8  50				 push ax
2  2959	    15C9  E8 00C4			 call near ptr int_main
2  2960	    15CC  50				 push ax
2  2961	    15CD  E8 00C0			 call near ptr int_main
1  2962					 ;=============================================================================
1  2963	    15D0			 std_matrix:				 ; Standard IRQ	redirectors
1  2964						 rept 16			 ; 16 IRQs
1  2965						 push ax
1  2966						 call near ptr irq_standard
1  2967						 endm
2  2968	    15D0  50				 push ax
2  2969	    15D1  E8 0344			 call near ptr irq_standard
2  2970	    15D4  50				 push ax
2  2971	    15D5  E8 0340			 call near ptr irq_standard
2  2972	    15D8  50				 push ax
2  2973	    15D9  E8 033C			 call near ptr irq_standard
2  2974	    15DC  50				 push ax
2  2975	    15DD  E8 0338			 call near ptr irq_standard
2  2976	    15E0  50				 push ax
2  2977	    15E1  E8 0334			 call near ptr irq_standard
2  2978	    15E4  50				 push ax
2  2979	    15E5  E8 0330			 call near ptr irq_standard
2  2980	    15E8  50				 push ax
2  2981	    15E9  E8 032C			 call near ptr irq_standard
2  2982	    15EC  50				 push ax
2  2983	    15ED  E8 0328			 call near ptr irq_standard
2  2984	    15F0  50				 push ax
2  2985	    15F1  E8 0324			 call near ptr irq_standard
2  2986	    15F4  50				 push ax
2  2987	    15F5  E8 0320			 call near ptr irq_standard
2  2988	    15F8  50				 push ax
2  2989	    15F9  E8 031C			 call near ptr irq_standard
2  2990	    15FC  50				 push ax
2  2991	    15FD  E8 0318			 call near ptr irq_standard
2  2992	    1600  50				 push ax
2  2993	    1601  E8 0314			 call near ptr irq_standard
2  2994	    1604  50				 push ax
2  2995	    1605  E8 0310			 call near ptr irq_standard
2  2996	    1608  50				 push ax
2  2997	    1609  E8 030C			 call near ptr irq_standard
2  2998	    160C  50				 push ax
2  2999	    160D  E8 0308			 call near ptr irq_standard
1  3000					 ;=============================================================================
1  3001	    1610			 back_matrix:				 ; Real	mode IRQ callbacks
1  3002						 rept 16			 ; 16 IRQs
1  3003						 push ax
1  3004						 call near ptr irq_callback
1  3005						 endm
2  3006	    1610  50				 push ax
2  3007	    1611  E8 03A3			 call near ptr irq_callback
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 54
kernel.asm



2  3008	    1614  50				 push ax
2  3009	    1615  E8 039F			 call near ptr irq_callback
2  3010	    1618  50				 push ax
2  3011	    1619  E8 039B			 call near ptr irq_callback
2  3012	    161C  50				 push ax
2  3013	    161D  E8 0397			 call near ptr irq_callback
2  3014	    1620  50				 push ax
2  3015	    1621  E8 0393			 call near ptr irq_callback
2  3016	    1624  50				 push ax
2  3017	    1625  E8 038F			 call near ptr irq_callback
2  3018	    1628  50				 push ax
2  3019	    1629  E8 038B			 call near ptr irq_callback
2  3020	    162C  50				 push ax
2  3021	    162D  E8 0387			 call near ptr irq_callback
2  3022	    1630  50				 push ax
2  3023	    1631  E8 0383			 call near ptr irq_callback
2  3024	    1634  50				 push ax
2  3025	    1635  E8 037F			 call near ptr irq_callback
2  3026	    1638  50				 push ax
2  3027	    1639  E8 037B			 call near ptr irq_callback
2  3028	    163C  50				 push ax
2  3029	    163D  E8 0377			 call near ptr irq_callback
2  3030	    1640  50				 push ax
2  3031	    1641  E8 0373			 call near ptr irq_callback
2  3032	    1644  50				 push ax
2  3033	    1645  E8 036F			 call near ptr irq_callback
2  3034	    1648  50				 push ax
2  3035	    1649  E8 036B			 call near ptr irq_callback
2  3036	    164C  50				 push ax
2  3037	    164D  E8 0367			 call near ptr irq_callback
1  3038					 ;=============================================================================
1  3039	    1650			 exc_matrix:				 ; Exceptions
1  3040						 rept 16			 ; 16 EXCs
1  3041						 push ax
1  3042						 call near ptr exc_handler
1  3043						 endm
2  3044	    1650  50				 push ax
2  3045	    1651  E8 0285			 call near ptr exc_handler
2  3046	    1654  50				 push ax
2  3047	    1655  E8 0281			 call near ptr exc_handler
2  3048	    1658  50				 push ax
2  3049	    1659  E8 027D			 call near ptr exc_handler
2  3050	    165C  50				 push ax
2  3051	    165D  E8 0279			 call near ptr exc_handler
2  3052	    1660  50				 push ax
2  3053	    1661  E8 0275			 call near ptr exc_handler
2  3054	    1664  50				 push ax
2  3055	    1665  E8 0271			 call near ptr exc_handler
2  3056	    1668  50				 push ax
2  3057	    1669  E8 026D			 call near ptr exc_handler
2  3058	    166C  50				 push ax
2  3059	    166D  E8 0269			 call near ptr exc_handler
2  3060	    1670  50				 push ax
2  3061	    1671  E8 0265			 call near ptr exc_handler
2  3062	    1674  50				 push ax
2  3063	    1675  E8 0261			 call near ptr exc_handler
2  3064	    1678  50				 push ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 55
kernel.asm



2  3065	    1679  E8 025D			 call near ptr exc_handler
2  3066	    167C  50				 push ax
2  3067	    167D  E8 0259			 call near ptr exc_handler
2  3068	    1680  50				 push ax
2  3069	    1681  E8 0255			 call near ptr exc_handler
2  3070	    1684  50				 push ax
2  3071	    1685  E8 0251			 call near ptr exc_handler
2  3072	    1688  50				 push ax
2  3073	    1689  E8 024D			 call near ptr exc_handler
2  3074	    168C  50				 push ax
2  3075	    168D  E8 0249			 call near ptr exc_handler
1  3076
1  3077
1  3078
1  3079
1  3080
1  3081
1  3082					 ; INT Redirector
1  3083					 ;
1  3084					 ; Used	by INTs	in protected mode to process real mode INT handlers
1  3085					 ;
1  3086					 ;=============================================================================
1  3087	    1690			 int_main:
1  3088	    1690  FA				 cli				 ; disable interrupts (emul. real-mode)
1  3089	    1691  58				 pop ax				 ; get caller address in AX
1  3090	    1692  2D 11D1r			 sub ax,offs int_matrix+1	 ; calculate INT number
1  3091	    1695  C1 E8	02			 shr ax,2			 ; now AX = INT	##h
1  3092	    1698  66| 60			 pushad
1  3093	    169A  1E 06	0F A0 0F A8		 push ds es fs gs
1  3094	    16A0  66| 33 F6			 xor esi,esi
1  3095	    16A3  2E: 8E 1E 0010		 mov ds,cs:seldata
1  3096	    16A8  66| FF 06 0280r		 inc _pc_intpmtorm		 ; increment INT PM->RM	counter
**Error** TEXT\KERNEL\intr.asm(85) Forward reference needs override
1  3097	    16AC  8B 16	02B0r			 mov dx,rmstacktop		 ; DX =	SS for real mode redirection
1  3098	    16B0  8B 1E	02ACr			 mov bx,rmstacklen		 ; get size of real mode stack
1  3099	    16B4  8B F2				 mov si,dx			 ; EBP -> top of real mode stack
1  3100	    16B6  2B D3				 sub dx,bx			 ; adjust DX to	next stack location
1  3101	    16B8  A2 1712r			 mov @@N,al			 ; modify code with interrupt number
1  3102	    16BB  66| C1 E6 04			 shl esi,4
1  3103	    16BF  3B 16	02AEr			 cmp dx,rmstackbase		 ; exceeded real mode stack space?
1  3104	    16C3  0F 82	F96E			 jb critical_error_rm		 ; if yes, critical error
1  3105	    16C7  89 16	02B0r			 mov rmstacktop,dx		 ; update ptr for possible reenterancy
1  3106	    16CB  C1 E3	04			 shl bx,4			 ; set real mode SP to top of stack
1  3107	    16CE  A2 00CAr			 mov last_int,al
1  3108	    16D1  B8 0018			 mov es,selzero			 ; copy	registers from protected mode
**Error** TEXT\KERNEL\intr.asm(97) Illegal use of segment register
1  3109	    16D4  B8 0018			 mov ds,selzero			 ; DS -> 0 (beginning of memory)
**Error** TEXT\KERNEL\intr.asm(98) Illegal use of segment register
1  3110	    16D7  66| 67| 8D 7E	DA		 lea edi,[esi-26h]
1  3111	    16DC  66| B9 00000008		 mov ecx,8
1  3112	    16E2  FC				 cld
1  3113	    16E3  67| 8C 56 FE			 mov [esi-2],ss			 ; store SS:ESP	on real	mode stack
1  3114	    16E7  66| 67| 89 66	FA		 mov [esi-6],esp
1  3115	    16EC  66| 67| 8D 74	24 08		 lea esi,[esp+8]
1  3116	    16F2  F3> 66| 36: 67| A5		 rep movs dword	ptr es:[edi],ss:[esi]
1  3117	    16F7  67| 8B 44 24 28		 mov ax,[esp+28h]		 ; move	AX to real mode	stack frame
1  3118	    16FC  67| 89 47 FC			 mov [edi-04h],ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 56
kernel.asm



1  3119	    1700  BE 0000s			 mov si,_KERNEL			 ; real	mode target CS:IP
1  3120	    1703  BF 170Fr			 mov di,offs @@0
1  3121	    1706  83 EB	26			 sub bx,26h			 ; adjust real mode SP for stored vars
1  3122	    1709  66				 db 66h				 ; JMP DWORD PTR, as in	32bit offset,
1  3123	    170A  2E: FF 26 0046r		 jmp word ptr cs:pmtormswrout	 ;  not	seg:16bit offset
1  3124
1  3125	    170F  66| 61		 @@0:	 popad				 ; load	regs with int call values
1  3126	    1711  CD				 db 0CDh			 ; INT ##h
1  3127	    1712  00			 @@N	 db 000h
1  3128	    1713  66| 60			 pushad				 ; store registers on stack
1  3129	    1715  9C				 pushf				 ; store flags on stack
1  3130	    1716  FA				 cli				 ; disable interrupts (emul. real-mode)
1  3131	    1717  66| 33 C0			 xor eax,eax			 ; EAX = linear	ptr to SS
1  3132	    171A  66| 8B E8			 mov ebp,eax
1  3133	    171D  8C D0				 mov ax,ss
1  3134	    171F  66| C1 E0 04			 shl eax,4
1  3135	    1723  8B EC				 mov bp,sp			 ; EBP = SP
1  3136	    1725  66| 8B 5E 22			 mov ebx,[bp+22h]		 ; get protected mode SS:ESP from stack
1  3137	    1729  8B 56	26			 mov dx,[bp+26h]
1  3138	    172C  66| 03 E8			 add ebp,eax			 ; EBP -> stored regs on stack
1  3139	    172F  B8 0018			 mov ax,SELZERO			 ; DS selector value for protected mode
1  3140	    1732  B9 0010			 mov cx,SELDATA			 ; ES selector value for protected mode
1  3141	    1735  BE 0008			 mov si,SELCODE			 ; target CS:EIP in protected mode
1  3142	    1738  66| BF 00001743r		 mov edi,offs @@1
1  3143	    173E  2E: FF 26 0044r		 jmp cs:rmtopmswrout		 ; go back to protected	mode
1  3144
1  3145	    1743  26: A1 02ACr		 @@1:	 mov ax,es:rmstacklen		 ; restore top of real mode stack
1  3146	    1747  26: 01 06 02B0r		 add es:rmstacktop,ax
1  3147	    174C  3E: 67| 8B 45	00		 mov ax,ds:[ebp]		 ; move	return FLAGS from real mode
1  3148	    1751  25 08D5			 and ax,08D5h			 ;  stack to protected mode stack
1  3149	    1754  67| 8B 54 24 32		 mov dx,[esp+32h]
1  3150	    1759  81 E2	F72A			 and dx,not 08D5h
1  3151	    175D  0B C2				 or ax,dx
1  3152	    175F  67| 89 44 24 32		 mov [esp+32h],ax
1  3153	    1764  66| 26: FF 06	027Cr		 inc es:_pc_intrmtopm		 ; increment INT RM->PM	counter
**Error** TEXT\KERNEL\intr.asm(142) Forward reference needs override
1  3154	    1769  66| 8B C5			 mov eax,ebp
1  3155	    176C  66| 67| 8B 78	02		 mov edi,[eax+2]		 ; restore return registers from real
1  3156	    1771  66| 67| 8B 70	06		 mov esi,[eax+6]		 ;  mode stack
1  3157	    1776  66| 67| 8B 68	0A		 mov ebp,[eax+10]
1  3158	    177B  66| 67| 8B 58	12		 mov ebx,[eax+18]
1  3159	    1780  66| 67| 8B 50	16		 mov edx,[eax+22]
1  3160	    1785  66| 67| 8B 48	1A		 mov ecx,[eax+26]
1  3161	    178A  66| 67| 8B 40	1E		 mov eax,[eax+30]
1  3162
1  3163	    178F  0F A9	0F A1 07 1F		 pop gs	fs es ds		 ; restore segment regs
1  3164	    1795  66| 83 C4 22			 add esp,22h			 ; skip	old registers
1  3165	    1799  66| CF			 iretd				 ;**no pop AX
1  3166
1  3167
1  3168
1  3169
1  3170					 ;-----------------------------------------------------------------------------
1  3171					 ; User	IRQ Handler
1  3172					 ;
1  3173	    179B			 irq_user:
1  3174	    179B  67| 89 1C 24			 mov [esp],bx			 ; handle user installed IRQ
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 57
kernel.asm



1  3175	    179F  8B D8				 mov bx,ax
1  3176	    17A1  C1 E3	03			 shl bx,3
1  3177	    17A4  66| 83 EC 04			 sub esp,4				 ; 4 bytes on stack for	00:CS
1  3178	    17A8  2E: 8B 87 0112r		 mov ax,word ptr cs:irqtab_pm[bx+0]	 ; get offset low (EIP)
1  3179	    17AD  67| 89 04 24			 mov [esp+0],ax
1  3180	    17B1  2E: 8B 87 0114r		 mov ax,word ptr cs:irqtab_pm[bx+2]	 ; get offset high (EIP)
1  3181	    17B6  67| 89 44 24 02		 mov [esp+2],ax
1  3182	    17BB  2E: 8B 9F 0116r		 mov bx,word ptr cs:irqtab_pm[bx+4]	 ; get selector	(CS:)
1  3183	    17C0  67| 87 5C 24 04		 xchg bx,[esp+4]		 ; put CS and restore BX
1  3184	    17C5  67| 8B 44 24 06		 mov ax,[esp+6]			 ; restore AX
1  3185	    17CA  66				 db 66h				 ; do 32bit far	ret to the
1  3186	    17CB  CB				 retf				 ;  appropriate	interrupt handler
1  3187
1  3188
1  3189					 ; Modifiable IRQ Handler
1  3190					 ;
1  3191					 ; This	handler	will, when called, send	IRQs from protected mode to real mode
1  3192					 ; by default, if protected mode handler is installed, it will be called
1  3193					 ; instead.
1  3194					 ;
1  3195					 ;=============================================================================
1  3196	    17CC			 irq_normal:				 ; Standard IRQ	handler	that will send
1  3197	    17CC  FA				 cli
1  3198	    17CD  58				 pop ax				 ; all the IRQs	that have not been
1  3199	    17CE  2D 11D1r			 sub ax,offs int_matrix+1	 ; hooked in protected mode to real
1  3200	    17D1  C1 E8	02			 shr ax,2			 ; mode
1  3201	    17D4  EB 31	90			 jmp irq_down
1  3202
1  3203					 ;=============================================================================
1  3204	    17D7			 irq_tester:			 ; redirection for IRQs	mapped on INT 08-0Fh
1  3205	    17D7  FA				 cli
1  3206	    17D8  B0 0B				 mov al,0Bh
1  3207	    17DA  E6 20				 out 20h,al
1  3208	    17DC  E4 20				 in al,20h
1  3209	    17DE  84 C0				 test al,al
1  3210	    17E0  0F 84	008D			 jz irq_fail
1  3211	    17E4  58				 pop ax				 ; get caller address in AX
1  3212	    17E5  2D 11D1r			 sub ax,offs int_matrix+1	 ; calculate INT number
1  3213	    17E8  C1 E8	02			 shr ax,2			 ; now AX = INT	##h
1  3214
1  3215	    17EB			 irq_soft:
1  3216	    17EB  50				 push ax
1  3217	    17EC  8A E0				 mov ah,al
1  3218	    17EE  25 F807			 and ax,0F807h
1  3219	    17F1  2E: 3A 26 001Dr		 cmp ah,cs:picmaster
1  3220	    17F6  B4 00				 mov ah,0
1  3221	    17F8  74 04	90 90			 jz @@1
1  3222	    17FC  04 08				 add al,8
1  3223	    17FE  2E: 0F A3 06 00CEr	 @@1:	 bt cs:irqset_pm,ax		 ; check if user handler is installed
1  3224	    1804  72 95				 jc irq_user			 ; if yes, branch
1  3225	    1806  58				 pop ax
1  3226
1  3227
1  3228					 ;-----------------------------------------------------------------------------
1  3229	    1807			 irq_down:
1  3230	    1807  66| 60			 pushad
1  3231	    1809  1E 06	0F A0 0F A8		 push ds es fs gs
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 58
kernel.asm



1  3232	    180F  2E: 8E 1E 0010		 mov ds,cs:seldata
1  3233	    1814  66| FF 06 0288r		 inc _pc_irqpmtorm		 ; increment IRQ PM->RM	counter
**Error** TEXT\KERNEL\intr.asm(222) Forward reference needs override
1  3234	    1818  66| 33 F6			 xor esi,esi
1  3235	    181B  8B 16	02B0r			 mov dx,rmstacktop		 ; DX =	SS for real mode redirection
1  3236	    181F  66| 33 C9			 xor ecx,ecx
1  3237	    1822  8B 1E	02ACr			 mov bx,rmstacklen		 ; get size of real mode stack
1  3238	    1826  8B F2				 mov si,dx			 ; ESI -> top of real mode stack
1  3239	    1828  2B D3				 sub dx,bx			 ; adjust DX to	next stack location
1  3240	    182A  8A C8				 mov cl,al
1  3241	    182C  66| C1 E6 04			 shl esi,4
1  3242	    1830  3B 16	02AEr			 cmp dx,rmstackbase		 ; exceeded real mode stack space?
1  3243	    1834  0F 82	F7FD			 jb critical_error_rm		 ; if yes, critical error
1  3244	    1838  89 16	02B0r			 mov rmstacktop,dx		 ; update ptr for possible reenterancy
1  3245	    183C  C1 E3	04			 shl bx,4			 ; set real mode SP to top of stack
1  3246	    183F  B8 0018			 mov ds,selzero			 ; DS -> 0 (beginning of memory)
**Error** TEXT\KERNEL\intr.asm(235) Illegal use	of segment register
1  3247	    1842  66| 67| 8B 3C	8D    +		 mov edi,ds:[ecx*4]		 ; get real mode interrupt CS:IP
   3248		  00000000
1  3249	    184B  67| 8C 56 FE			 mov [esi-2],ss			 ; store SS: on	real mode stack
1  3250	    184F  66| 67| 89 66	FA		 mov [esi-6],esp		 ; store ESP on	real mode stack
1  3251	    1854  66| 67| C7 46	F6    +		 mov dword ptr [esi-10],_KERNEL	 ; set target FLAGS and	CS: on RM stack
   3252		  00000000s
1  3253	    185D  67| C7 46 F4 198Ar		 mov word ptr [esi-12],offs @irq ; set target IP on RM stack
1  3254	    1863  66| 0F A4 FE 10		 shld esi,edi,16
1  3255	    1868  83 EB	0C			 sub bx,12			 ; adjust real mode SP for stored vars
1  3256	    186B  66				 db 66h				 ; JMP DWORD PTR, as in	32bit offset,
1  3257	    186C  2E: FF 26 0046r		 jmp word ptr cs:pmtormswrout	 ;  not	seg:16bit offset
1  3258
1  3259
1  3260
1  3261					 ; Exception Handler
1  3262					 ;
1  3263					 ; NOTE: this handler should be	called only by interrupts in range
1  3264					 ;	 INT 00h thru INT 0Fh which are	exceptions.
1  3265					 ;
1  3266					 ;=============================================================================
1  3267	    1871			 irq_fail:
1  3268	    1871  58				 pop ax				 ; get call address
1  3269	    1872  2D 11D1r			 sub ax,offs int_matrix+1	 ; calculate INT ##
1  3270	    1875  C1 E8	02			 shr ax,2
1  3271	    1878  2E: F6 06 0000r 10		 test cs:pm32_mode,00010000b	 ; check if software INTs are allowed
1  3272	    187E  75 45	90 90			 jnz @@1			 ; if trap them	down, then jump
1  3273	    1882  50				 push ax			 ; check if software INT was issued
1  3274	    1883  1E				 push ds
1  3275	    1884  66| 56			 push esi
1  3276	    1886  67| 0F 02 74 24 0E		 lar si,[esp+8+6]		 ; get CS: rights assuming no errcode
1  3277	    188C  75 29	90 90			 jnz @@0			 ; if CS: not valid, jump
1  3278	    1890  67| 0F 00 64 24 0E		 verr word ptr [esp+8+6]	 ; verify selector read	access
1  3279	    1896  75 1F	90 90			 jnz @@0			 ; if non-readable, jump
1  3280	    189A  F7 D6				 not si				 ; invert Present bit
1  3281	    189C  F7 C6	8000			 test si,8000h			 ; test	Present	bit
1  3282	    18A0  75 15	90 90			 jnz @@0			 ; if segment was not present, jump
1  3283	    18A4  8A E0				 mov ah,al
1  3284	    18A6  B0 CD				 mov al,0CDh
1  3285	    18A8  67| 8E 5C 24 0E		 mov ds,[esp+8+6]
1  3286	    18AD  66| 67| 8B 74	24 0A		 mov esi,[esp+8+2]
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 59
kernel.asm



1  3287	    18B3  67| 3B 46 FE			 cmp ax,ds:[esi-2]
1  3288	    18B7  66| 5E		 @@0:	 pop esi
1  3289	    18B9  1F				 pop ds
1  3290	    18BA  58				 pop ax
1  3291	    18BB  75 08	90 90			 jnz @@1
1  3292	    18BF  3C 08				 cmp al,8
1  3293	    18C1  0F 83	FF26			 jae irq_soft
1  3294
1  3295	    18C5  2E: 0F A3 06 00D0r	 @@1:	 bt cs:excset_pm,ax		 ; check if user handler is installed
1  3296	    18CB  72 1D	90 90			 jc exc_user			 ; if yes, branch
1  3297	    18CF  2E: 8A 26 00CAr		 mov ah,cs:last_int		 ; put last int	number in AH
1  3298	    18D4  2E: FF 2E 0010r		 jmp dword ptr cs:client_call	 ; use default exception handler
1  3299
1  3300
1  3301					 ;=============================================================================
1  3302	    18D9			 exc_handler:
1  3303	    18D9  58				 pop ax
1  3304	    18DA  2D 1651r			 sub ax,offs exc_matrix+1
1  3305	    18DD  C1 E8	02			 shr ax,2
1  3306	    18E0  2E: 8A 26 00CAr		 mov ah,cs:last_int
1  3307	    18E5  2E: FF 2E 0010r		 jmp dword ptr cs:client_call	 ; use default exception handler
1  3308
1  3309
1  3310
1  3311					 ;-----------------------------------------------------------------------------
1  3312					 ; User	Exception Handler
1  3313					 ;
1  3314	    18EA			 exc_user:
1  3315	    18EA  53				 push bx
1  3316	    18EB  8B D8				 mov bx,ax
1  3317	    18ED  C1 E3	03			 shl bx,3
1  3318	    18F0  66| 83 EC 04			 sub esp,4				 ; 4 bytes on stack for	00:CS
1  3319	    18F4  2E: 8B 87 0192r		 mov ax,word ptr cs:exctab_pm[bx+0]	 ; get offset low (EIP)
1  3320	    18F9  67| 89 04 24			 mov [esp+0],ax
1  3321	    18FD  2E: 8B 87 0194r		 mov ax,word ptr cs:exctab_pm[bx+2]	 ; get offset high (EIP)
1  3322	    1902  67| 89 44 24 02		 mov [esp+2],ax
1  3323	    1907  2E: 8B 9F 0196r		 mov bx,word ptr cs:exctab_pm[bx+4]	 ; get selector	(CS:)
1  3324	    190C  67| 87 5C 24 04		 xchg bx,[esp+4]		 ; put CS and restore BX
1  3325	    1911  67| 8B 44 24 06		 mov ax,[esp+6]			 ; restore AX
1  3326	    1916  66				 db 66h				 ; do 32bit far	ret to the
1  3327	    1917  CB				 retf				 ;  appropriate	exception handler
1  3328
1  3329
1  3330
1  3331
1  3332
1  3333
1  3334
1  3335					 ; Standard IRQ	Handler
1  3336					 ;
1  3337					 ; This	handler	will always, when called, send IRQs from protected mode	to
1  3338					 ; real	mode
1  3339					 ;
1  3340					 ;=============================================================================
1  3341	    1918			 irq_standard:				 ; Standard IRQ	handler	that will send
1  3342	    1918  FA				 cli
1  3343	    1919  58				 pop ax				 ; by default all the IRQs from
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 60
kernel.asm



1  3344	    191A  2D 15D1r			 sub ax,offs std_matrix+1	 ; protected mode to real mode
1  3345	    191D  C1 E8	02			 shr ax,2
1  3346	    1920  66| 60			 pushad
1  3347	    1922  1E 06	0F A0 0F A8		 push ds es fs gs
1  3348	    1928  2E: 8E 1E 0010		 mov ds,cs:seldata
1  3349	    192D  66| FF 06 0288r		 inc _pc_irqpmtorm		 ; increment IRQ PM->RM	counter
**Error** TEXT\KERNEL\intr.asm(336) Forward reference needs override
1  3350	    1931  66| 33 F6			 xor esi,esi
1  3351	    1934  8B 16	02B0r			 mov dx,rmstacktop		 ; DX =	SS for real mode redirection
1  3352	    1938  66| 33 C9			 xor ecx,ecx
1  3353	    193B  8B 1E	02ACr			 mov bx,rmstacklen		 ; get size of real mode stack
1  3354	    193F  8B F2				 mov si,dx			 ; ESI -> top of real mode stack
1  3355	    1941  2B D3				 sub dx,bx			 ; adjust DX to	next stack location
1  3356	    1943  8A C8				 mov cl,al
1  3357	    1945  66| C1 E6 04			 shl esi,4
1  3358	    1949  3B 16	02AEr			 cmp dx,rmstackbase		 ; exceeded real mode stack space?
1  3359	    194D  0F 82	F6E4			 jb critical_error_rm		 ; if yes, critical error
1  3360	    1951  89 16	02B0r			 mov rmstacktop,dx		 ; update ptr for possible reenterancy
1  3361	    1955  C1 E3	04			 shl bx,4			 ; set real mode SP to top of stack
1  3362	    1958  66| 67| 8B 3C	8D    +		 mov edi,irqtab_rm[ecx*4]	 ; get real mode interrupt CS:IP
   3363		  000000D2r
1  3364	    1961  B8 0018			 mov ds,selzero			 ; DS -> 0 (beginning of memory)
**Error** TEXT\KERNEL\intr.asm(350) Illegal use	of segment register
1  3365	    1964  67| 8C 56 FE			 mov [esi-2],ss			 ; store SS: on	real mode stack
1  3366	    1968  66| 67| 89 66	FA		 mov [esi-6],esp		 ; store ESP on	real mode stack
1  3367	    196D  66| 67| C7 46	F6    +		 mov dword ptr [esi-10],_KERNEL	 ; set target FLAGS and	CS: on RM stack
   3368		  00000000s
1  3369	    1976  67| C7 46 F4 198Ar		 mov word ptr [esi-12],offs @irq ; set target IP on RM stack
1  3370	    197C  66| 0F A4 FE 10		 shld esi,edi,16
1  3371	    1981  83 EB	0C			 sub bx,12			 ; adjust real mode SP for stored vars
1  3372	    1984  66				 db 66h				 ; JMP DWORD PTR, as in	32bit offset,
1  3373	    1985  2E: FF 26 0046r		 jmp word ptr cs:pmtormswrout	 ;  not	seg:16bit offset
1  3374
1  3375	    198A  FA			 @irq:	 cli
1  3376	    198B  B8 0010			 mov ax,SELDATA			 ; DS selector value for protected mode
1  3377	    198E  8B C8				 mov cx,ax			 ; ES selector value for protected mode
1  3378	    1990  66| 5B			 pop ebx			 ; get protected mode SS:ESP from stack
1  3379	    1992  5A				 pop dx
1  3380	    1993  BE 0008			 mov si,SELCODE			 ; target CS:EIP in protected mode
1  3381	    1996  66| BF 000019A1r		 mov edi,offs @@2
1  3382	    199C  2E: FF 26 0044r		 jmp cs:rmtopmswrout		 ; go back to protected	mode
1  3383
1  3384	    19A1  A1 02ACr		 @@2:	 mov ax,rmstacklen		 ; restore top of real mode stack
1  3385	    19A4  01 06	02B0r			 add rmstacktop,ax
1  3386	    19A8  66| FF 06 0284r		 inc _pc_irqrmtopm		 ; increment IRQ RM->PM	counter
**Error** TEXT\KERNEL\intr.asm(371) Forward reference needs override
1  3387	    19AC  0F A9	0F A1 07 1F		 pop gs	fs es ds		 ; restore all registers
1  3388	    19B2  66| 61			 popad
1  3389	    19B4  58				 pop ax				 ; restore original AX
1  3390	    19B5  66| CF			 iretd
1  3391
1  3392
1  3393
1  3394
1  3395
1  3396
1  3397
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 61
kernel.asm



1  3398
1  3399					 ; IRQ Callback
1  3400					 ;
1  3401					 ; Used	by IRQs	in real	mode to	process	protected mode IRQ handlers.
1  3402					 ;
1  3403					 ;=============================================================================
1  3404	    19B7			 irq_callback:
1  3405	    19B7  FA				 cli
1  3406	    19B8  58				 pop ax
1  3407	    19B9  2D 1611r			 sub ax,offs back_matrix+1
1  3408	    19BC  C1 E8	02			 shr ax,2			 ; AX =	IRQ number
1  3409	    19BF  66| 60			 pushad
1  3410	    19C1  1E 06	0F A0 0F A8		 push ds es fs gs
1  3411	    19C7  2E: 8E 1E 0016r		 mov ds,cs:kernel_code
1  3412
1  3413	    19CC  66| FF 06 028Cr		 inc _pc_irqcbrmtopm		 ; increment IRQCallback RM->PM	counter
**Error** TEXT\KERNEL\intr.asm(398) Forward reference needs override
1  3414	    19D0  A2 00CBr			 mov temp_int,al
1  3415	    19D3  66| 8B 16 02A4r		 mov edx,pmstacktop		 ; EDX = ESP for protected mode
1  3416	    19D8  66| 8B DA			 mov ebx,edx
1  3417	    19DB  66| 2B 16 029Cr		 sub edx,pmstacklen
1  3418	    19E0  66| 3B 16 02A0r		 cmp edx,pmstackbase		 ; exceeded protected mode stack space?
1  3419	    19E5  0F 82	F66B			 jb critical_error_pm		 ; if yes, critical error
1  3420	    19E9  66| 89 16 02A4r		 mov pmstacktop,edx		 ; update ptr for possible reenterancy
1  3421
1  3422	    19EE  8C D5				 mov bp,ss			 ; save	real mode SS:SP	in EBP
1  3423	    19F0  66| C1 E5 10			 shl ebp,16
1  3424	    19F4  8B EC				 mov bp,sp
1  3425	    19F6  8B 36	02CCr			 mov si,irqcallbackptr		 ; save	ESP across mode	switches
1  3426	    19FA  66| 89 A4 0640r		 mov dptr @callback_data[si+100h],esp
1  3427	    19FF  83 06	02CCr 04		 add irqcallbackptr,4
1  3428
1  3429	    1A04  B8 0008			 mov ax,SELCODE			 ; prot. mode DS
1  3430	    1A07  B9 0018			 mov cx,SELZERO			 ; prot. mode ES
1  3431	    1A0A  8B D1				 mov dx,cx			 ; prot. mode SS
1  3432	    1A0C  8B F0				 mov si,ax			 ; prot. mode CS
1  3433	    1A0E  66| BF 00001A18r		 mov edi,offs @@0			 ; prot. mode EIP
1  3434	    1A14  FF 26	0044r			 jmp rmtopmswrout		 ; switch to protected mode
1  3435
1  3436	    1A18  0F B6	1E 00CBr	 @@0:	 movzx bx,temp_int
1  3437	    1A1D  C1 E3	03			 shl bx,3			 ; BX =	pointer	to interrupt ##h
1  3438	    1A20  66| 9C			 pushfd				 ; set return eflags
1  3439	    1A22  66| 6A 08			 push large SELCODE		 ; set return CS on PM stack
1  3440	    1A25  66| 68 00001A30r		 push large offs @@1		 ; set return EIP on PM	stack
1  3441	    1A2B  66				 db 66h
1  3442	    1A2C  FF AF	0112r			 jmp dword ptr irqtab_pm[bx]	 ; go to prot. mode interrupt handler
1  3443
1  3444	    1A30  B8 0000s		 @@1:	 mov ax,_KERNEL			 ; AX =	real mode DS
1  3445	    1A33  8B F0				 mov si,ax			 ; SI =	real mode CS
1  3446	    1A35  BF 1A46r			 mov di,offs @@2		 ; DI =	real mode IP
1  3447	    1A38  8B DD				 mov bx,bp			 ; BX =	real mode SP
1  3448	    1A3A  66| C1 ED 10			 shr ebp,16
1  3449	    1A3E  8B D5				 mov dx,bp			 ; DX =	real mode SS
1  3450	    1A40  66				 db 66h
1  3451	    1A41  2E: FF 26 0046r		 jmp word ptr cs:pmtormswrout	 ; switch to real mode
1  3452
1  3453	    1A46  66| A1 029Cr		 @@2:	 mov eax,pmstacklen
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 62
kernel.asm



1  3454	    1A4A  66| 01 06 02A4r		 add pmstacktop,eax
1  3455	    1A4F  66| FF 06 0290r		 inc _pc_irqcbpmtorm		 ; increment IRQCallback PM->RM	counter
**Error** TEXT\KERNEL\intr.asm(440) Forward reference needs override
1  3456
1  3457	    1A53  83 2E	02CCr 04		 sub irqcallbackptr,4		 ; restore original ESP
1  3458	    1A58  8B 36	02CCr			 mov si,irqcallbackptr
1  3459	    1A5C  66| 8B A4 0640r		 mov esp,dptr @callback_data[si+100h]
1  3460
1  3461	    1A61  0F A9	0F A1 07 1F		 pop gs	fs es ds
1  3462	    1A67  66| 61			 popad
1  3463	    1A69  58				 pop ax
1  3464	    1A6A  CF				 iret				 ; return from IRQ callback
1  3465
1  3466
1  3467
1  3468
1  3469
1  3470
1  3471
1  3472
1  3473					 ;=============================================================================
1  3474					 ;	 Real mode callback actual code:
1  3475					 ;##	 pushad
1  3476					 ;##	 push 0				 ; if 0, callback is free
1  3477					 ;##	 push large 0
1  3478					 ;##	 mov cx,0			 ; load	CX with	callers	ES
1  3479					 ;##	 push large
1  3480					 ;##	 jmp far ptr ?:?
1  3481					 ;
1  3482	    1A6B			 callback:				 ; real	mode callback handler
1  3483	    1A6B  8B C4				 mov ax,sp			 ; preserve SS:SP for callback
1  3484	    1A6D  16				 push ss
1  3485	    1A6E  50				 push ax
1  3486	    1A6F  0F A8	0F A0 1E 06		 push gs fs ds es		 ; preserve real mode regs for callback
1  3487	    1A75  9C				 pushf				 ; preserve FLAGS for callback
1  3488	    1A76  FA				 cli
1  3489	    1A77  0E				 push cs
1  3490	    1A78  1F				 pop ds
1  3491
1  3492	    1A79  66| FF 06 0294r		 inc _pc_cbrmtopm		 ; increment Callback RM->PM counter
**Error** TEXT\KERNEL\intr.asm(477) Forward reference needs override
1  3493	    1A7D  66| 8B 2E 02A4r		 mov ebp,pmstacktop		 ; EBP = ESP for protected mode
1  3494	    1A82  66| 8B DD			 mov ebx,ebp			 ; set EBX to next stack location
1  3495	    1A85  66| 2B 1E 029Cr		 sub ebx,pmstacklen
1  3496	    1A8A  66| 89 1E 02A4r		 mov pmstacktop,ebx		 ; update ptr for possible reenterancy
1  3497	    1A8F  66| 3B 1E 02A0r		 cmp ebx,pmstackbase		 ; exceeded protected mode stack space?
1  3498	    1A94  0F 82	F5BC			 jb critical_error_pm		 ; if yes, critical error
1  3499
1  3500	    1A98  66| 33 C0			 xor eax,eax			 ; EAX = base address of SS
1  3501	    1A9B  66| 8B D8			 mov ebx,eax
1  3502	    1A9E  8C D0				 mov ax,ss
1  3503	    1AA0  66| C1 E0 04			 shl eax,4
1  3504	    1AA4  8B DC				 mov bx,sp			 ; EBX = current linear	SS:SP
1  3505	    1AA6  66| 03 D8			 add ebx,eax
1  3506
1  3507	    1AA9  8E 06	002Er			 mov es,ds:gdtseg		 ; set for protected mode callback DS
1  3508	    1AAD  66| 0D 92000000		 or eax,92000000h		 ;  base address in GDT
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 63
kernel.asm



1  3509	    1AB3  66| 26: A3 004A		 mov es:[SELCALLBACK+2],eax
1  3510	    1AB8  B8 0018			 mov ax,SELZERO			 ; DS selector for protected mode
1  3511	    1ABB  8B D0				 mov dx,ax			 ; SS selector = DS selector
1  3512	    1ABD  BE 0008			 mov si,SELCODE			 ; target protected mode CS:EIP
1  3513	    1AC0  66| BF 00001ACAr		 mov edi,offs @@0
1  3514	    1AC6  FF 26	0044r			 jmp rmtopmswrout		 ; go to protected mode
1  3515
1  3516	    1ACA  66| 67| 8B 7C	24 0E	 @@0:	 mov edi,[esp+14]		 ; EDI -> register structure from stack
1  3517	    1AD0  66| 67| 8D 74	24 18		 lea esi,[esp+24]		 ; copy	general	registers from stack
1  3518	    1AD6  66| B9 00000008		 mov ecx,8			 ;  to register	structure
1  3519	    1ADC  FC				 cld
1  3520	    1ADD  F3> 66| 67| A5		 rep movs dword	ptr es:[edi],dword ptr ds:[esi]
1  3521
1  3522	    1AE1  66| 8B F4			 mov esi,esp			 ; copy	FLAGS, ES, DS, FG, and GS
1  3523	    1AE4  67| A5			 movs word ptr es:[edi],word ptr ds:[esi]
1  3524	    1AE6  66| 67| A5			 movs dword ptr	es:[edi],dword ptr ds:[esi]
1  3525	    1AE9  66| 67| A5			 movs dword ptr	es:[edi],dword ptr ds:[esi]
1  3526	    1AEC  66| 67| AD			 lods dword ptr	ds:[esi]	 ; EAX = real mode SS:SP from stack
1  3527	    1AEF  05 002A			 add ax,42			 ; adjust SP for stuff on stack
1  3528	    1AF2  66| 26: 67| 89 47 04		 mov es:[edi+4],eax		 ; put in register structure
1  3529	    1AF8  2E: 8E 1E 0048		 mov ds,cs:selcallback		 ; DS =	callback DS selector
1  3530	    1AFD  66| 83 EF 2A			 sub edi,42			 ; EDI -> register structure
1  3531	    1B01  66| 0F B7 F0			 movzx esi,ax			 ; ESI = old real mode SP
1  3532	    1B05  66| 87 E5			 xchg esp,ebp			 ; ESP = protected mode	stack
1  3533	    1B08  66| 9C			 pushfd				 ; push	flags for IRETD	from callback
1  3534	    1B0A  66| 0E			 push large cs			 ; push	32bit CS for IRETD
1  3535	    1B0C  66| 68 00001B21r		 push large offs @@1		 ; push	32bit EIP for IRETD
1  3536	    1B12  66| 67| 0F B7	45 16		 movzx eax,word	ptr [ebp+22]	 ; EAX = target	CS of callback
1  3537	    1B18  66| 50			 push eax			 ; push	32bit CS for RETF to callback
1  3538	    1B1A  66| 67| FF 75	12		 push dword ptr	[ebp+18]	 ; push	32bit EIP for retf
1  3539	    1B1F  66				 db 66h				 ; 32bit RETF to callback
1  3540	    1B20  CB				 retf
1  3541
1  3542	    1B21  FA			 @@1:	 cli
1  3543	    1B22  06				 push es			 ; DS:ESI = register structure
1  3544	    1B23  1F				 pop ds
1  3545	    1B24  66| 8B F7			 mov esi,edi
1  3546	    1B27  2E: 8E 06 0018		 mov es,cs:selzero		 ; ES -> 0 (beginning of memory)
1  3547	    1B2C  66| 67| 0F B7	5E 2E		 movzx ebx,word	ptr [esi+2Eh]	 ; EBX = real mode SP from structure
1  3548	    1B32  66| 67| 0F B7	56 30		 movzx edx,word	ptr [esi+30h]	 ; EDX = real mode SS from structure
1  3549	    1B38  83 EB	2A			 sub bx,42			 ; subtract size of vars to be put
1  3550	    1B3B  66| 67| 8B 6E	0C		 mov ebp,[esi+0Ch]		 ; EBP = pushed	ESP from real mode
1  3551	    1B40  8B EB				 mov bp,bx			 ; EBP = old high & new	low word of ESP
1  3552	    1B42  66| 67| 8D 3C	95    +		 lea edi,[edx*4]		 ; EDI -> real mode base of stack
   3553		  00000000
1  3554	    1B4B  66| 67| 8D 3C	BB		 lea edi,[edi*4+ebx]		 ;  of vars to be stored
1  3555	    1B50  66| B9 00000008		 mov ecx,8			 ; copy	general	registers to stack
1  3556	    1B56  FC				 cld
1  3557	    1B57  F3> 66| 67| A5		 rep movs dword	ptr es:[edi],ds:[esi]
1  3558	    1B5B  66| 67| 8B 46	06		 mov eax,[esi+6]		 ; EAX = return	FS and GS for real mode
1  3559	    1B60  66| 26: 67| 89 07		 mov es:[edi],eax		 ; store on real mode stack for	return
1  3560	    1B65  66| 67| 8B 46	0A		 mov eax,[esi+10]		 ; EAX = return	CS:IP for real mode
1  3561	    1B6A  66| 26: 67| 89 47 04		 mov es:[edi+4],eax		 ; store on real mode stack for	return
1  3562	    1B70  67| 8B 06			 mov ax,[esi]			 ; AX =	return FLAGS for real mode
1  3563	    1B73  26: 67| 89 47	08		 mov es:[edi+8],ax		 ; store on real mode stack for	return
1  3564	    1B78  67| 8B 46 04			 mov ax,[esi+4]			 ; AX =	return DS for real mode
1  3565	    1B7C  67| 8B 4E 02			 mov cx,[esi+2]			 ; CX =	return ES for real mode
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 64
kernel.asm



1  3566	    1B80  BE 0000s			 mov si,_KERNEL			 ; real	mode target CS:IP
1  3567	    1B83  BF 1B8Cr			 mov di,offs @@2
1  3568	    1B86  66				 db 66h				 ; JMP DWORD PTR, as in	32bit offset,
1  3569	    1B87  2E: FF 26 0046r		 jmp word ptr cs:pmtormswrout	 ;  not	seg:16bit offset
1  3570
1  3571	    1B8C  66| 8B E5		 @@2:	 mov esp,ebp			 ; restore total ESP, old high word
1  3572	    1B8F  66| 2E: A1 029Cr		 mov eax,cs:pmstacklen		 ; restore top of protected mode stack
1  3573	    1B94  66| 2E: 01 06	02A4r		 add cs:pmstacktop,eax
1  3574	    1B9A  66| 2E: FF 06	0298r		 inc cs:_pc_cbpmtorm		 ; increment Callback PM->RM counter
**Error** TEXT\KERNEL\intr.asm(558) Forward reference needs override
1  3575	    1B9F  66| 61			 popad				 ; get callback	return general regs
1  3576	    1BA1  0F A1	0F A9			 pop fs	gs			 ; get callback	return FS and GS values
1  3577	    1BA5  CF				 iret				 ; go to callback return CS:IP
1  3578
1  3579
1  3580
   3581					 include TEXT\KERNEL\int31h.asm
1  3582					 ;
1  3583					 ; Copyright (C) 1996-2002 Supernar Systems, Ltd. All rights reserved.
1  3584					 ;
1  3585					 ; Redistribution  and	use  in	source and  binary  forms, with	or without
1  3586					 ; modification,  are permitted	provided that the following conditions are
1  3587					 ; met:
1  3588					 ;
1  3589					 ; 1.  Redistributions	of  source code	 must  retain  the above copyright
1  3590					 ; notice, this	list of	conditions and the following disclaimer.
1  3591					 ;
1  3592					 ; 2.  Redistributions	in binary form	must reproduce the above copyright
1  3593					 ; notice,  this  list of conditions and  the  following disclaimer in the
1  3594					 ; documentation and/or	other materials	provided with the distribution.
1  3595					 ;
1  3596					 ; 3. The end-user documentation included with the redistribution, if any,
1  3597					 ; must	include	the following acknowledgment:
1  3598					 ;
1  3599					 ; "This product uses DOS/32 Advanced DOS Extender technology."
1  3600					 ;
1  3601					 ; Alternately,	 this acknowledgment may appear	in the software	itself,	if
1  3602					 ; and wherever	such third-party acknowledgments normally appear.
1  3603					 ;
1  3604					 ; 4.  Products	derived	from this software  may	not be called "DOS/32A"	or
1  3605					 ; "DOS/32 Advanced".
1  3606					 ;
1  3607					 ; THIS	 SOFTWARE AND DOCUMENTATION IS PROVIDED	 "AS IS" AND ANY EXPRESSED
1  3608					 ; OR  IMPLIED	WARRANTIES,  INCLUDING,	BUT  NOT  LIMITED  TO, THE IMPLIED
1  3609					 ; WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
1  3610					 ; DISCLAIMED.	IN  NO	EVENT SHALL THE	 AUTHORS  OR  COPYRIGHT	HOLDERS	BE
1  3611					 ; LIABLE  FOR	ANY DIRECT, INDIRECT,  INCIDENTAL,  SPECIAL, EXEMPLARY,	OR
1  3612					 ; CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT	LIMITED	TO, PROCUREMENT	OF
1  3613					 ; SUBSTITUTE  GOODS  OR  SERVICES;  LOSS OF  USE,  DATA,  OR  PROFITS;	OR
1  3614					 ; BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF	LIABILITY,
1  3615					 ; WHETHER IN CONTRACT,	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE	OR
1  3616					 ; OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN	IF
1  3617					 ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1  3618					 ;
1  3619					 ;
1  3620
1  3621					 ;=============================================================================
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 65
kernel.asm



1  3622					 ; INT 31h INTERFACE
1  3623					 ;=============================================================================
1  3624
1  3625							 evendata
1  3626	    1BA6			 int31tab	 label word
1  3627	    1BA6  0300					 dw	 0300h	 ; simulate real mode int
1  3628	    1BA8  23C1r					 dw	 int310300
1  3629	    1BAA  0301					 dw	 0301h	 ; call	rm proc	RETF
1  3630	    1BAC  23B8r					 dw	 int310301
1  3631	    1BAE  0302					 dw	 0302h	 ; call	rm proc	IRET
1  3632	    1BB0  23B8r					 dw	 int310302
1  3633						 ;---------------------------------------------------------------------
1  3634	    1BB2  0000					 dw	 0000h	 ; allocate descriptor
1  3635	    1BB4  1DD2r					 dw	 int310000
1  3636	    1BB6  0001					 dw	 0001h	 ; free	descriptor
1  3637	    1BB8  1E23r					 dw	 int310001
1  3638	    1BBA  0002					 dw	 0002h	 ; map seg to sel
1  3639	    1BBC  1E62r					 dw	 int310002
1  3640	    1BBE  0003					 dw	 0003h	 ; get sel increment value
1  3641	    1BC0  1ED2r					 dw	 int310003
1  3642	    1BC2  0006					 dw	 0006h	 ; get sel base	addr
1  3643	    1BC4  1ED8r					 dw	 int310006
1  3644	    1BC6  0007					 dw	 0007h	 ; set sel base	addr
1  3645	    1BC8  1EEDr					 dw	 int310007
1  3646	    1BCA  0008					 dw	 0008h	 ; set sel limit
1  3647	    1BCC  1F02r					 dw	 int310008
1  3648	    1BCE  0009					 dw	 0009h	 ; set sel access rights
1  3649	    1BD0  1F2Cr					 dw	 int310009
1  3650	    1BD2  000A					 dw	 000Ah	 ; create alias	sel
1  3651	    1BD4  1F4Br					 dw	 int31000A
1  3652	    1BD6  000B					 dw	 000Bh	 ; get descriptor
1  3653	    1BD8  1F7Br					 dw	 int31000B
1  3654	    1BDA  000C					 dw	 000Ch	 ; set descriptor
1  3655	    1BDC  1F91r					 dw	 int31000C
1  3656	    1BDE  000E					 dw	 000Eh	 ; get multi descriptors
1  3657	    1BE0  1FB5r					 dw	 int31000E
1  3658	    1BE2  000F					 dw	 000Fh	 ; get multi descriptors
1  3659	    1BE4  1FBBr					 dw	 int31000F
1  3660						 ;---------------------------------------------------------------------
1  3661	    1BE6  0100					 dw	 0100h	 ; alloc DOS memory
1  3662	    1BE8  1FE1r					 dw	 int310100
1  3663	    1BEA  0101					 dw	 0101h	 ; free	DOS memory
1  3664	    1BEC  2022r					 dw	 int310101
1  3665	    1BEE  0102					 dw	 0102h	 ; resize DOS memory
1  3666	    1BF0  2032r					 dw	 int310102
1  3667						 ;---------------------------------------------------------------------
1  3668	    1BF2  0200					 dw	 0200h	 ; get real mode int
1  3669	    1BF4  20A4r					 dw	 int310200
1  3670	    1BF6  0201					 dw	 0201h	 ; set real mode int
1  3671	    1BF8  20BBr					 dw	 int310201
1  3672	    1BFA  0202					 dw	 0202h	 ; get pm exception vector
1  3673	    1BFC  20DEr					 dw	 int310202
1  3674	    1BFE  0203					 dw	 0203h	 ; set pm exception vector
1  3675	    1C00  2153r					 dw	 int310203
1  3676	    1C02  0204					 dw	 0204h	 ; get pm int
1  3677	    1C04  21DCr					 dw	 int310204
1  3678	    1C06  0205					 dw	 0205h	 ; set pm int
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 66
kernel.asm



1  3679	    1C08  2245r					 dw	 int310205
1  3680						 ;---------------------------------------------------------------------
1  3681	    1C0A  0303					 dw	 0303h	 ; alloc callback
1  3682	    1C0C  252Ar					 dw	 int310303
1  3683	    1C0E  0304					 dw	 0304h	 ; free	callback
1  3684	    1C10  2573r					 dw	 int310304
1  3685	    1C12  0305					 dw	 0305h	 ; get state save/restore addr
1  3686	    1C14  25ACr					 dw	 int310305
1  3687	    1C16  0306					 dw	 0306h	 ; get raw mode	switch addr
1  3688	    1C18  25C6r					 dw	 int310306
1  3689						 ;---------------------------------------------------------------------
1  3690	    1C1A  0400					 dw	 0400h	 ; get DPMI version
1  3691	    1C1C  25E0r					 dw	 int310400
1  3692						 ;---------------------------------------------------------------------
1  3693	    1C1E  0500					 dw	 0500h	 ; get free mem	info
1  3694	    1C20  27E9r					 dw	 int310500
1  3695	    1C22  0501					 dw	 0501h	 ; alloc mem
1  3696	    1C24  2853r					 dw	 int310501
1  3697	    1C26  0502					 dw	 0502h	 ; free	mem
1  3698	    1C28  2888r					 dw	 int310502
1  3699	    1C2A  0503					 dw	 0503h	 ; resize mem
1  3700	    1C2C  28A4r					 dw	 int310503
1  3701	    1C2E  050A					 dw	 050Ah	 ; get linear mem block	and size
1  3702	    1C30  296Br					 dw	 int31050A
1  3703						 ;---------------------------------------------------------------------
1  3704	    1C32  0600					 dw	 0600h	 ; lock	linear region			 ***VM*
1  3705	    1C34  2B9Er					 dw	 int310600
1  3706	    1C36  0601					 dw	 0601h	 ; unlock linear region			 ***VM*
1  3707	    1C38  2B9Er					 dw	 int310601
1  3708	    1C3A  0602					 dw	 0602h	 ;
1  3709	    1C3C  2B9Er					 dw	 int310602
1  3710	    1C3E  0603					 dw	 0603h	 ;
1  3711	    1C40  2B9Er					 dw	 int310603
1  3712	    1C42  0604					 dw	 0604h	 ; get page size			 ***VM*
1  3713	    1C44  2BA1r					 dw	 int310604
1  3714						 ;---------------------------------------------------------------------
1  3715	    1C46  0702					 dw	 0702h	 ; mark	page				 ***VM*
1  3716	    1C48  2B9Er					 dw	 int310702
1  3717	    1C4A  0703					 dw	 0703h	 ; discard page				 ***VM*
1  3718	    1C4C  2B9Er					 dw	 int310703
1  3719						 ;---------------------------------------------------------------------
1  3720	    1C4E  0800					 dw	 0800h	 ; physical mem	mapping
1  3721	    1C50  2BA9r					 dw	 int310800
1  3722	    1C52  0801					 dw	 0801h	 ; free	mapped mem
1  3723	    1C54  2CE5r					 dw	 int310801
1  3724						 ;---------------------------------------------------------------------
1  3725	    1C56  0900					 dw	 0900h	 ; get/disable VIS
1  3726	    1C58  2382r					 dw	 int310900
1  3727	    1C5A  0901					 dw	 0901h	 ; get/enable VIS
1  3728	    1C5C  2394r					 dw	 int310901
1  3729	    1C5E  0902					 dw	 0902h	 ; get VIS
1  3730	    1C60  23A6r					 dw	 int310902
1  3731						 ;---------------------------------------------------------------------
1  3732	    1C62  0A00					 dw	 0A00h	 ; vendor specific
1  3733	    1C64  2604r					 dw	 int310A00
1  3734						 ;---------------------------------------------------------------------
1  3735	    1C66  0E00					 dw	 0E00h	 ; get FPU status
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 67
kernel.asm



1  3736	    1C68  2D51r					 dw	 int310E00
1  3737	    1C6A  0E01					 dw	 0E01h	 ; set FPU emulation
1  3738	    1C6C  2D76r					 dw	 int310E01
1  3739						 ;---------------------------------------------------------------------
1  3740	    1C6E  EEFF					 dw	 0EEFFh	 ; PMODE/W compatible call
1  3741	    1C70  2D99r					 dw	 int31EEFF
1  3742	    1C72  FFFF					 dw	 0FFFFh
1  3743	    1C74  FFFF					 dw	 0FFFFh
1  3744
1  3745
1  3746					 ;=============================================================================
1  3747	    1C76  FA			 int31:	 cli
1  3748	    1C77  FC				 cld
1  3749
1  3750	    1C78  1E 06	0F A0 0F A8		 push ds es fs gs		 ; push	registers on stack
1  3751	    1C7E  66| 60			 pushad
1  3752	    1C80  53				 push bx
1  3753	    1C81  33 DB				 xor bx,bx
1  3754	    1C83  2E: 8E 1E 0018		 mov ds,cs:selzero		 ; DS -> 0 (beginning of memory)
1  3755
1  3756	    1C88  2E: 3B 87 1BA6r	 @@0:	 cmp ax,cs:int31tab[bx]		 ; found function value?
1  3757	    1C8D  74 11	90 90			 je @@1
1  3758	    1C91  2E: 83 BF 1BA6r FF		 cmp word ptr cs:int31tab[bx],0FFFFh
1  3759	    1C97  74 11	90 90			 je @@2
1  3760	    1C9B  83 C3	04			 add bx,4
1  3761	    1C9E  EB E8				 jmp @@0
1  3762
1  3763	    1CA0  2E: 8B 9F 1BA8r	 @@1:	 mov bx,cs:int31tab[bx+2]	 ; yes,	go to appropriate handler
1  3764	    1CA5  67| 87 1C 24			 xchg bx,[esp]
1  3765	    1CA9  C3				 ret
1  3766
1  3767	    1CAA  5B			 @@2:	 pop bx				 ; no function found
1  3768
1  3769					 ;-----------------------------------------------------------------------------
1  3770	    1CAB			 int31fail8001:				 ; INT 31h return fail with error 8001h
1  3771	    1CAB  B0 01				 mov al,01h
1  3772	    1CAD  EB 35	90			 jmp int31failx
1  3773	    1CB0			 int31fail8010:				 ; INT 31h return fail with error 8010h
1  3774	    1CB0  B0 10				 mov al,10h
1  3775	    1CB2  EB 30	90			 jmp int31failx
1  3776	    1CB5			 int31fail8011:				 ; INT 31h return fail with error 8011h
1  3777	    1CB5  B0 11				 mov al,11h
1  3778	    1CB7  EB 2B	90			 jmp int31failx
1  3779	    1CBA			 int31fail8012:				 ; INT 31h return fail with error 8012h
1  3780	    1CBA  B0 12				 mov al,12h
1  3781	    1CBC  EB 26	90			 jmp int31failx
1  3782	    1CBF			 int31fail8013:				 ; INT 31h return fail with error 8013h
1  3783	    1CBF  B0 13				 mov al,13h
1  3784	    1CC1  EB 21	90			 jmp int31failx
1  3785	    1CC4			 int31fail8015:				 ; INT 31h return fail with error 8015h
1  3786	    1CC4  B0 15				 mov al,15h
1  3787	    1CC6  EB 1C	90			 jmp int31failx
1  3788	    1CC9			 int31fail8016:				 ; INT 31h return fail with error 8016h
1  3789	    1CC9  B0 16				 mov al,16h
1  3790	    1CCB  EB 17	90			 jmp int31failx
1  3791	    1CCE			 int31fail8021:				 ; INT 31h return fail with error 8021h
1  3792	    1CCE  B0 21				 mov al,21h
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 68
kernel.asm



1  3793	    1CD0  EB 12	90			 jmp int31failx
1  3794	    1CD3			 int31fail8022:				 ; INT 31h return fail with error 8022h
1  3795	    1CD3  B0 22				 mov al,22h
1  3796	    1CD5  EB 0D	90			 jmp int31failx
1  3797	    1CD8			 int31fail8023:				 ; INT 31h return fail with error 8023h
1  3798	    1CD8  B0 23				 mov al,23h
1  3799	    1CDA  EB 08	90			 jmp int31failx
1  3800	    1CDD			 int31fail8024:				 ; INT 31h return fail with error 8024h
1  3801	    1CDD  B0 24				 mov al,24h
1  3802	    1CDF  EB 03	90			 jmp int31failx
1  3803	    1CE2			 int31fail8025:				 ; INT 31h return fail with error 8025h
1  3804	    1CE2  B0 25				 mov al,25h
1  3805
1  3806	    1CE4			 int31failx:
1  3807	    1CE4  B4 80				 mov ah,80h
1  3808	    1CE6  67| 89 44 24 1C		 mov [esp+28],ax		 ; set AX on stack to 8010h for	POPAD
1  3809	    1CEB  EB 13	90			 jmp int31fail
1  3810
1  3811
1  3812
1  3813					 ;-----------------------------------------------------------------------------
1  3814	    1CEE			 int31failbx:				 ; INT 31h return fail with BX,AX
1  3815	    1CEE  67| 89 5C 24 10		 mov word ptr [esp+16],bx	 ; put BX onto stack for POPAD
1  3816	    1CF3  EB 06	90			 jmp int31failax
1  3817	    1CF6			 int31failcx:				 ; INT 31h return fail with CX,AX
1  3818	    1CF6  67| 89 4C 24 18		 mov word ptr [esp+24],cx	 ; put CX onto stack for POPAD
1  3819	    1CFB			 int31failax:				 ; INT 31h return fail with AX
1  3820	    1CFB  67| 89 44 24 1C		 mov word ptr [esp+28],ax	 ; put AX onto stack for POPAD
1  3821
1  3822
1  3823					 ;-----------------------------------------------------------------------------
1  3824	    1D00			 int31fail:				 ; INT 31h return fail,	pop all	regs
1  3825	    1D00  66| 61			 popad
1  3826	    1D02  0F A9	0F A1 07 1F		 pop gs	fs es ds
1  3827	    1D08			 int31failnopop:			 ; INT 31h return fail with carry set
1  3828	    1D08  67| 80 4C 24 08 01		 or byte ptr [esp+8],01h	 ; set carry in	EFLAGS on stack
1  3829	    1D0E  66| CF			 iretd
1  3830
1  3831
1  3832					 ;-----------------------------------------------------------------------------
1  3833	    1D10			 int31okedx:				 ; INT 31h return ok with EDX,CX,AX
1  3834	    1D10  66| 67| 89 54	24 14		 mov [esp+20],edx		 ; put EDX onto	stack for POPAD
1  3835	    1D16  EB 1C	90			 jmp int31okcx
1  3836	    1D19			 int31okdx:				 ; INT 31h return ok with DX,CX,AX
1  3837	    1D19  67| 89 54 24 14		 mov [esp+20],dx		 ; put DX onto stack for POPAD
1  3838	    1D1E  EB 14	90			 jmp int31okcx
1  3839	    1D21			 int31oksinoax:				 ; INT 31h return ok SI,DI,BX,CX
1  3840	    1D21  67| 8B 44 24 1C		 mov ax,[esp+28]		 ; get old value of AX for restore
1  3841	    1D26			 int31oksi:				 ; INT 31h return ok SI,DI,BX,CX,AX
1  3842	    1D26  67| 89 74 24 04		 mov [esp+4],si			 ; put SI onto stack for POPAD
1  3843	    1D2B  67| 89 3C 24			 mov [esp+0],di			 ; put DI onto stack for POPAD
1  3844	    1D2F			 int31okbx:
1  3845	    1D2F  67| 89 5C 24 10		 mov [esp+16],bx		 ; put BX onto stack for POPAD
1  3846	    1D34			 int31okcx:				 ; INT 31h return ok with CX,AX
1  3847	    1D34  67| 89 4C 24 18		 mov [esp+24],cx		 ; put CX onto stack for POPAD
1  3848	    1D39			 int31okax:				 ; INT 31h return ok with AX
1  3849	    1D39  67| 89 44 24 1C		 mov [esp+28],ax		 ; put AX onto stack for POPAD
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 69
kernel.asm



1  3850
1  3851
1  3852					 ;-----------------------------------------------------------------------------
1  3853	    1D3E			 int31ok:				 ; INT 31h return ok, pop all regs
1  3854	    1D3E  66| 61			 popad
1  3855	    1D40  0F A9	0F A1 07 1F		 pop gs	fs es ds
1  3856	    1D46			 int31oknopop:				 ; INT 31h return ok with carry	clear
1  3857	    1D46  67| 80 64 24 08 FE		 and byte ptr [esp+8],0FEh	 ; clear carry in EFLAGS on stack
1  3858	    1D4C  66| CF			 iretd
1  3859
1  3860
1  3861
1  3862
1  3863
1  3864
1  3865					 ;=============================================================================
1  3866					 ; DESCRIPTOR FUNCTIONS
1  3867					 ;=============================================================================
1  3868
1  3869					 ;-----------------------------------------------------------------------------
1  3870	    1D4E			 int31testsel:				 ; test	for valid selector BX
1  3871	    1D4E  5D				 pop bp				 ; pop return address
1  3872	    1D4F  2E: 3B 1E 0030r		 cmp bx,cs:gdtlimit		 ; selector BX out of range?
1  3873	    1D54  0F 87	FF7B			 ja int31fail8022		 ; if yes, fail	with error 8022h
1  3874	    1D58  66| 2E: 8B 3E	0032r		 mov edi,cs:gdtbase		 ; get base of GDT
1  3875	    1D5E  66| 81 E3 0000FFF8		 and ebx,0FFF8h			 ; mask	offset table index and RPL
1  3876	    1D65  67| F6 44 1F 06 10		 test byte ptr ds:[edi+ebx+6],10h; is descriptor used?
1  3877	    1D6B  0F 84	FF64			 jz int31fail8022		 ; if descriptor not used, fail	8022h
1  3878	    1D6F  FF E5				 jmp bp				 ; return ok
1  3879
1  3880					 ;-----------------------------------------------------------------------------
1  3881	    1D71			 int31testaccess:			 ; test	access bits in CX
1  3882	    1D71  5D				 pop bp				 ; pop return address
1  3883	    1D72  F6 C5	20			 test ch,20h			 ; test	MUST BE	0 bit in CH
1  3884	    1D75  0F 85	FF55			 jnz int31fail8021		 ; if not 0, error 8021h
1  3885	    1D79  F6 C1	90			 test cl,90h			 ; test	present	and MUST BE 1 bits
1  3886	    1D7C  0F 84	FF4E			 jz int31fail8021		 ; if both 0, error 8021h
1  3887	    1D80  0F 8B	FF4A			 jpo int31fail8021		 ; if unequal, error 8021h
1  3888	    1D84  F6 C1	60			 test cl,60h			 ; test	DPL
1  3889	    1D87  0F 85	FF43			 jnz int31fail8021		 ; if not 0, error 8021h
1  3890	    1D8B  F6 C1	08			 test cl,8			 ; if code, more tests needed
1  3891	    1D8E  74 10	90 90			 jz @@0				 ; if data, skip code tests
1  3892	    1D92  F6 C1	02			 test cl,2			 ; readable?
1  3893	    1D95  0F 84	FF35			 jz int31fail8021
1  3894	    1D99  F6 C1	04			 test cl,4			 ; non-conform?
1  3895	    1D9C  0F 85	FF2E			 jnz int31fail8021
1  3896	    1DA0  FF E5			 @@0:	 jmp bp				 ; return ok
1  3897
1  3898					 ;-----------------------------------------------------------------------------
1  3899	    1DA2			 checkint:
1  3900	    1DA2  66| 52			 push edx
1  3901	    1DA4  66| 0F B6 DB			 movzx ebx,bl			 ; EBX = interrupt number
1  3902	    1DA8  66| 8B D3			 mov edx,ebx
1  3903	    1DAB  8A C3				 mov al,bl
1  3904	    1DAD  80 E2	07			 and dl,07h			 ; EDX = INT number in range 00-07h
1  3905	    1DB0  24 F8				 and al,0F8h			 ; AL =	masked out low 3 bits
1  3906	    1DB2  3A 06	001Dr			 cmp al,picmaster		 ; if 1st PIC,
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 70
kernel.asm



1  3907	    1DB6  66| 67| 8D 32			 lea esi,[edx+0]		 ; then	ESI = EDX
1  3908	    1DBA  74 13	90 90			 jz @@done
1  3909	    1DBE  3A 06	001Cr			 cmp al,picslave		 ; if 2nd PIC,
1  3910	    1DC2  66| 67| 8D 72	08		 lea esi,[edx+8]		 ; then	ESI = EDX+8
1  3911	    1DC7  74 06	90 90			 jz @@done
1  3912	    1DCB  66| 83 CE FF			 or esi,-1
1  3913	    1DCF  66| 5A		 @@done: pop edx			 ; return ZF reset to 0	if an IRQ
1  3914	    1DD1  C3				 ret				 ; otherwise ZF	is set to 1
1  3915
1  3916
1  3917
1  3918
1  3919
1  3920					 ;=============================================================================
1  3921	    1DD2			 int310000:				 ; allocate descriptors
1  3922	    1DD2  85 C9				 test cx,cx			 ; if CX = 0, error 8021h
1  3923	    1DD4  0F 84	FEF6			 jz int31fail8021
1  3924
1  3925	    1DD8  66| 2E: 8B 16	0032r		 mov edx,cs:gdtbase		 ; get base of GDT
1  3926	    1DDE  66| 2E: 0F B7	06    +		 movzx eax,cs:gdtlimit		 ; EAX = last selector index
   3927		  0030r
1  3928	    1DE5  24 F8				 and al,0F8h
1  3929
1  3930	    1DE7  8B D9				 mov bx,cx			 ; BX =	number of selectors to find
1  3931	    1DE9  67| F6 44 02 06 10	 @@l0:	 test byte ptr [edx+eax+6],10h	 ; is descriptor used?
1  3932	    1DEF  75 25	90 90			 jnz @@f0
1  3933	    1DF3  4B				 dec bx				 ; found free descriptor, dec counter
1  3934	    1DF4  75 22	90 90			 jnz @@f1			 ; continue if need to find more
1  3935
1  3936	    1DF8  66| 8B D8			 mov ebx,eax			 ; found all descriptors requested
1  3937	    1DFB  66| 67| C7 04	1A    +	 @@l1:	 mov dword ptr [edx+ebx],0	 ; set entire new descriptor
   3938		  00000000
1  3939	    1E04  66| 67| C7 44	1A 04 +		 mov dword ptr [edx+ebx+4],109200h
   3940		  00109200
1  3941	    1E0E  83 C3	08			 add bx,8			 ; increment selector index
1  3942	    1E11  E2 E8				 loop @@l1			 ; dec counter of descriptors to mark
1  3943	    1E13  E9 FF23			 jmp int31okax			 ; return ok, with AX
1  3944
1  3945	    1E16  8B D9			 @@f0:	 mov bx,cx			 ; reset number	of selectors to	find
1  3946	    1E18  2D 0008		 @@f1:	 sub ax,8			 ; dec current selector	counter
1  3947	    1E1B  3D 0050			 cmp ax,8*SYSSELECTORS		 ; more	descriptors to go?
1  3948	    1E1E  73 C9				 jae @@l0			 ; if yes, loop
1  3949	    1E20  E9 FE92			 jmp int31fail8011		 ; did not find	descriptors
1  3950
1  3951
1  3952					 ;=============================================================================
1  3953	    1E23			 int310001:				 ; free	descriptor
1  3954	    1E23  8C C8				 mov ax,cs
1  3955	    1E25  3B C3				 cmp ax,bx
1  3956	    1E27  0F 84	FEA8			 jz int31fail8022		 ; cannot free CS selector
1  3957	    1E2B  8C D0				 mov ax,ss
1  3958	    1E2D  3B C3				 cmp ax,bx
1  3959	    1E2F  0F 84	FEA0			 jz int31fail8022		 ; cannot free SS selector
1  3960	    1E33  E8 FF18			 call int31testsel		 ; test	for valid selector BX
1  3961	    1E36  66| 33 C0			 xor eax,eax
1  3962	    1E39  66| 67| 89 04	1F		 mov [edi+ebx+0],eax		 ; mark	descriptor as free
1  3963	    1E3E  66| 67| 89 44	1F 04		 mov [edi+ebx+4],eax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 71
kernel.asm



1  3964
1  3965	    1E44  B9 0004			 mov cx,4			 ; zero	any segregs loaded with	BX
1  3966	    1E47  66| 67| 8D 6C	24 20		 lea ebp,[esp+32]		 ; EBP -> selectors on stack
1  3967	    1E4D  67| 39 5D 00		 @@l0:	 cmp word ptr [ebp],bx		 ; selector = BX?
1  3968	    1E51  75 06	90 90			 jne @@f0			 ; if no, continue loop
1  3969
1  3970	    1E55  67| 89 45 00			 mov [ebp],ax			 ; zero	selector on stack
1  3971
1  3972	    1E59  66| 83 C5 02		 @@f0:	 add ebp,2			 ; increment selector ptr
1  3973	    1E5D  E2 EE				 loop @@l0			 ; loop
1  3974	    1E5F  E9 FEDC			 jmp int31ok			 ; return ok
1  3975
1  3976
1  3977					 ;=============================================================================
1  3978	    1E62			 int310002:				 ; map segment to selector
1  3979	    1E62  2E: 8E 1E 0010		 mov ds,cs:seldata
1  3980
1  3981	    1E67  B9 0010			 mov cx,16			 ; max 16 selectors
1  3982	    1E6A  BE 008Ar			 mov si,offs segmentbases	 ; check, if segment already mapped
1  3983	    1E6D  8B 04			 @@0:	 mov ax,[si+0]			 ; is selector zero (free entry)
1  3984	    1E6F  85 C0				 test ax,ax
1  3985	    1E71  74 09	90 90			 jz @@1				 ; if yes, loop
1  3986	    1E75  3B 5C	02			 cmp bx,[si+2]			 ; compare segment values
1  3987	    1E78  0F 84	FEBD			 jz int31okax			 ; if already mapped, done
1  3988	    1E7C  83 C6	04		 @@1:	 add si,4
1  3989	    1E7F  E2 EC				 loop @@0
1  3990
1  3991	    1E81  B1 10				 mov cl,16
1  3992	    1E83  BE 008Ar			 mov si,offs segmentbases	 ; search for a	free entry
1  3993	    1E86  83 3C	00		 @@2:	 cmp word ptr [si],0		 ; this	field free?
1  3994	    1E89  74 0A	90 90			 jz @@3				 ; if yes, use it
1  3995	    1E8D  83 C6	04			 add si,4
1  3996	    1E90  E2 F4				 loop @@2
1  3997	    1E92  E9 FE1B			 jmp int31fail8010		 ; no entry free
1  3998
1  3999	    1E95  89 5C	02		 @@3:	 mov [si+2],bx			 ; store segment
1  4000	    1E98  66| 0F B7 FB			 movzx edi,bx			 ; convert to linear address
1  4001	    1E9C  66| C1 E7 04			 shl edi,4
1  4002	    1EA0  B1 01				 mov cl,1
1  4003	    1EA2  33 C0				 xor ax,ax
1  4004	    1EA4  CD 31				 int 31h			 ; allocate selector
1  4005	    1EA6  0F 82	FE51			 jc int31failax
1  4006	    1EAA  89 04				 mov [si+0],ax			 ; store selector
1  4007
1  4008	    1EAC  8B D8				 mov bx,ax
1  4009	    1EAE  33 C9				 xor cx,cx
1  4010	    1EB0  BA FFFF			 mov dx,-1
1  4011	    1EB3  B8 0008			 mov ax,8
1  4012	    1EB6  CD 31				 int 31h			 ; set descriptor limit	64k
1  4013
1  4014	    1EB8  8B D7				 mov dx,di
1  4015	    1EBA  66| C1 EF 10			 shr edi,16
1  4016	    1EBE  8B CF				 mov cx,di
1  4017	    1EC0  B8 0007			 mov ax,7
1  4018	    1EC3  CD 31				 int 31h			 ; set descriptor base
1  4019
1  4020	    1EC5  B9 0092			 mov cx,0092h
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 72
kernel.asm



1  4021	    1EC8  B8 0009			 mov ax,9
1  4022	    1ECB  CD 31				 int 31h			 ; set access rights
1  4023
1  4024	    1ECD  8B C3				 mov ax,bx			 ; return selector
1  4025	    1ECF  E9 FE67			 jmp int31okax
1  4026
1  4027
1  4028
1  4029					 ;=============================================================================
1  4030	    1ED2			 int310003:				 ; get selector	increment value
1  4031	    1ED2  B8 0008			 mov ax,8			 ; selector increment value is 8
1  4032	    1ED5  E9 FE61			 jmp int31okax			 ; return ok, with AX
1  4033
1  4034
1  4035					 ;=============================================================================
1  4036	    1ED8			 int310006:				 ; get segment base address
1  4037	    1ED8  E8 FE73			 call int31testsel		 ; test	for valid selector BX
1  4038	    1EDB  67| 8B 54 1F 02		 mov dx,word ptr ds:[edi+ebx+2]	 ; low word of 32bit linear address
1  4039	    1EE0  67| 8A 4C 1F 04		 mov cl,byte ptr ds:[edi+ebx+4]	 ; high	word of	32bit linear address
1  4040	    1EE5  67| 8A 6C 1F 07		 mov ch,byte ptr ds:[edi+ebx+7]
1  4041	    1EEA  E9 FE2C			 jmp int31okdx			 ; return ok, with DX, CX, AX
1  4042
1  4043
1  4044					 ;=============================================================================
1  4045	    1EED			 int310007:				 ; set segment base address
1  4046	    1EED  E8 FE5E			 call int31testsel		 ; test	for valid selector BX
1  4047	    1EF0  67| 89 54 1F 02		 mov word ptr ds:[edi+ebx+2],dx	 ; low word of 32bit linear address
1  4048	    1EF5  67| 88 4C 1F 04		 mov byte ptr ds:[edi+ebx+4],cl	 ; high	word of	32bit linear address
1  4049	    1EFA  67| 88 6C 1F 07		 mov byte ptr ds:[edi+ebx+7],ch
1  4050	    1EFF  E9 FE3C			 jmp int31ok			 ; return ok
1  4051
1  4052
1  4053					 ;=============================================================================
1  4054	    1F02			 int310008:				 ; set segment limit
1  4055	    1F02  E8 FE49			 call int31testsel		 ; test	for valid selector BX
1  4056	    1F05  83 F9	0F			 cmp cx,0Fh			 ; is limit greater than 1M?
1  4057	    1F08  76 10	90 90			 jbe @@1			 ; if not, jump
1  4058
1  4059	    1F0C  81 CA	0FFF			 or dx,0FFFh			 ; auto-adjust limit
1  4060	    1F10  0F AC	CA 0C			 shrd dx,cx,12			 ; DX =	low 16 bits of page limit
1  4061	    1F14  C1 E9	0C			 shr cx,12			 ; CL =	high 4 bits of page limit
1  4062	    1F17  80 C9	80			 or cl,80h			 ; set granularity bit in CL
1  4063
1  4064	    1F1A  67| 89 14 1F		 @@1:	 mov word ptr ds:[edi+ebx],dx	 ; put low word	of limit
1  4065	    1F1E  67| 80 64 1F 06 50		 and byte ptr ds:[edi+ebx+6],50h ; mask	off G and high nibble of limit
1  4066	    1F24  67| 08 4C 1F 06		 or byte ptr ds:[edi+ebx+6],cl	 ; put high nibble of limit
1  4067	    1F29  E9 FE12			 jmp int31ok			 ; return ok
1  4068
1  4069
1  4070					 ;=============================================================================
1  4071	    1F2C			 int310009:				 ; set descriptor access rights
1  4072	    1F2C  E8 FE1F			 call int31testsel		 ; test	for valid selector BX
1  4073	    1F2F  E8 FE3F			 call int31testaccess		 ; test	access bits in CX
1  4074
1  4075	    1F32  80 CD	10			 or ch,10h			 ; set AVL bit,	descriptor used
1  4076	    1F35  80 E5	D0			 and ch,0D0h			 ; mask	off low	nibble of CH
1  4077	    1F38  67| 80 64 1F 06 0F		 and byte ptr ds:[edi+ebx+6],0Fh ; mask	off high nibble	access rights
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 73
kernel.asm



1  4078	    1F3E  67| 08 6C 1F 06		 or byte ptr ds:[edi+ebx+6],ch	 ; or in high access rights byte
1  4079	    1F43  67| 88 4C 1F 05		 mov byte ptr ds:[edi+ebx+5],cl	 ; put low access rights byte
1  4080	    1F48  E9 FDF3			 jmp int31ok			 ; return ok
1  4081
1  4082
1  4083					 ;=============================================================================
1  4084	    1F4B			 int31000A:				 ; create alias	descriptor
1  4085	    1F4B  E8 FE00			 call int31testsel		 ; test	for valid selector BX
1  4086
1  4087	    1F4E  33 C0				 xor ax,ax			 ; allocate descriptor
1  4088	    1F50  B9 0001			 mov cx,1
1  4089	    1F53  CD 31				 int 31h
1  4090	    1F55  0F 82	FD5C			 jc int31fail8011		 ; if failed, descriptor unavailable
1  4091
1  4092	    1F59  50				 push ax			 ; preserve allocated selector
1  4093	    1F5A  1E				 push ds			 ; copy	descriptor and set type	data
1  4094	    1F5B  07				 pop es
1  4095	    1F5C  66| 0F B7 F8			 movzx edi,ax			 ; EDI = target	selector
1  4096	    1F60  66| 2E: 8B 36	0032r		 mov esi,cs:gdtbase		 ; ESI -> GDT
1  4097	    1F66  66| 03 FE			 add edi,esi			 ; adjust to target descriptor in GDT
1  4098	    1F69  66| 03 F3			 add esi,ebx			 ; adjust to source descriptor in GDT
1  4099
1  4100	    1F6C  66| 67| A5			 movs dword ptr	es:[edi],ds:[esi]; copy	descriptor
1  4101	    1F6F  66| 67| AD			 lods dword ptr	ds:[esi]
1  4102	    1F72  B4 92				 mov ah,92h			 ; set descriptor type - R/W up	data
1  4103	    1F74  66| 67| AB			 stos dword ptr	es:[edi]
1  4104	    1F77  58				 pop ax				 ; restore allocated selector
1  4105	    1F78  E9 FDBE			 jmp int31okax			 ; return ok, with AX
1  4106
1  4107
1  4108					 ;=============================================================================
1  4109	    1F7B			 int31000B:				 ; get descriptor
1  4110	    1F7B  E8 FDD0			 call int31testsel		 ; test	for valid selector BX
1  4111	    1F7E  66| 67| 8D 34	1F		 lea esi,[edi+ebx]		 ; ESI -> descriptor in	GDT
1  4112	    1F83  66| 67| 8B 3C	24		 mov edi,[esp]			 ; get EDI buffer ptr from stack
1  4113	    1F88  66| 67| A5			 movs dword ptr	es:[edi],ds:[esi]; copy	descriptor
1  4114	    1F8B  66| 67| A5			 movs dword ptr	es:[edi],ds:[esi]
1  4115	    1F8E  E9 FDAD			 jmp int31ok			 ; return ok
1  4116
1  4117
1  4118					 ;=============================================================================
1  4119	    1F91			 int31000C:				 ; set descriptor
1  4120	    1F91  E8 FDBA			 call int31testsel		 ; test	for valid selector BX
1  4121	    1F94  66| 67| 8B 34	24		 mov esi,[esp]			 ; ESI = EDI buffer ptr	from stack
1  4122	    1F99  26: 67| 8B 4E	05		 mov cx,es:[esi+5]		 ; get access rights from descriptor
1  4123	    1F9E  E8 FDD0			 call int31testaccess		 ; test	access bits in CX
1  4124
1  4125	    1FA1  1E				 push ds			 ; swap	DS and ES, target and source
1  4126	    1FA2  06				 push es
1  4127	    1FA3  1F				 pop ds
1  4128	    1FA4  07				 pop es
1  4129
1  4130	    1FA5  66| 03 FB			 add edi,ebx			 ; adjust EDI to descriptor in GDT
1  4131	    1FA8  66| 67| A5			 movs dword ptr	es:[edi],ds:[esi]; copy	descriptor
1  4132	    1FAB  66| 67| AD			 lods dword ptr	ds:[esi]
1  4133	    1FAE  0C 10				 or al,10h			 ; set descriptor AVL bit
1  4134	    1FB0  67| AB			 stos word ptr es:[edi]
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 74
kernel.asm



1  4135	    1FB2  E9 FD89			 jmp int31ok			 ; return ok
1  4136
1  4137
1  4138					 ;=============================================================================
1  4139	    1FB5			 int31000E:				 ; get multiple	descriptors
1  4140	    1FB5  B8 000B			 mov ax,000Bh			 ; function 000bh, get descriptor
1  4141	    1FB8  EB 04	90			 jmp int31000EF			 ; go to common	function
1  4142
1  4143
1  4144					 ;=============================================================================
1  4145	    1FBB			 int31000F:				 ; set multiple	descriptors
1  4146	    1FBB  B8 000C			 mov ax,000Ch			 ; function 000ch, set descriptor
1  4147
1  4148	    1FBE			 int31000EF:				 ; common to funcions 000eh and	000fh
1  4149	    1FBE  85 C9				 test cx,cx			 ; if CX = 0, return ok	immediately
1  4150	    1FC0  0F 84	FD7A			 jz int31ok
1  4151
1  4152	    1FC4  8B D1				 mov dx,cx			 ; DX =	number of descriptors
1  4153	    1FC6  33 C9				 xor cx,cx			 ; CX =	successful counter
1  4154	    1FC8  26: 67| 8B 1F		 @@l0:	 mov bx,es:[edi]		 ; BX =	selector to get
1  4155	    1FCC  66| 83 C7 02			 add edi,2
1  4156	    1FD0  CD 31				 int 31h			 ; get/set descriptor
1  4157	    1FD2  0F 82	FD20			 jc int31failcx			 ; if error, fail with AX and CX
1  4158
1  4159	    1FD6  66| 83 C7 08			 add edi,8			 ; increment descriptor	ptr
1  4160	    1FDA  41				 inc cx				 ; increment successful	copy counter
1  4161	    1FDB  4A				 dec dx				 ; decrement loop counter
1  4162	    1FDC  75 EA				 jnz @@l0			 ; if more descriptors to go, loop
1  4163	    1FDE  E9 FD5D			 jmp int31ok			 ; return ok
1  4164
1  4165
1  4166
1  4167
1  4168
1  4169
1  4170					 ;=============================================================================
1  4171					 ; DOS MEMORY FUNCTIONS
1  4172					 ;=============================================================================
1  4173
1  4174					 ;=============================================================================
1  4175	    1FE1			 int310100:				 ; allocate DOS	memory block
1  4176	    1FE1  B4 48				 mov ah,48h			 ; DOS alloc memory function
1  4177	    1FE3  E8 0088			 call int31010x_f2		 ; allocate memory
1  4178	    1FE6  0F 82	FD04			 jc int31failbx			 ; if fail, exit with AX=err, BX=maxmem
1  4179
1  4180	    1FEA  8B D0				 mov dx,ax			 ; DX=segment of DOS memory block
1  4181	    1FEC  33 C0				 xor ax,ax			 ; allocate descriptor
1  4182	    1FEE  B9 0001			 mov cx,1
1  4183	    1FF1  CD 31				 int 31h
1  4184	    1FF3  73 0A	90 90			 jnc @@1
1  4185	    1FF7  B4 49				 mov ah,49h			 ; if error allocating descriptor
1  4186	    1FF9  E8 0072			 call int31010x_f2		 ; free	what was allocated
1  4187	    1FFC  E9 FCB6			 jmp int31fail8011		 ; and exit with error 8011h
1  4188
1  4189	    1FFF  67| 89 44 24 14	 @@1:	 mov [esp+14h],ax		 ; set selector	in DX
1  4190	    2004  67| 89 54 24 1C		 mov [esp+1Ch],dx		 ; set base address in AX
1  4191	    2009  8B D8				 mov bx,ax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 75
kernel.asm



1  4192	    200B  8B CA				 mov cx,dx
1  4193	    200D  C1 E2	04			 shl dx,4
1  4194	    2010  C1 E9	0C			 shr cx,12
1  4195	    2013  B8 0007			 mov ax,0007h			 ; set selector	base
1  4196	    2016  CD 31				 int 31h
1  4197
1  4198	    2018  B9 0092			 mov cx,0092h			 ; set access rights
1  4199	    201B  B0 09				 mov al,09h
1  4200	    201D  CD 31				 int 31h
1  4201	    201F  EB 1E	90			 jmp int31010x			 ; set selector	size
1  4202
1  4203
1  4204					 ;=============================================================================
1  4205	    2022			 int310101:				 ; free	DOS block memory
1  4206	    2022  B4 49				 mov ah,49h
1  4207	    2024  8B F2				 mov si,dx			 ; preserve DX = selector
1  4208	    2026  E8 0030			 call int31010x_f1
1  4209	    2029  0F 82	FCCE			 jc int31failax
1  4210	    202D  8B DE				 mov bx,si			 ; restore selector in BX
1  4211	    202F  E9 FDF1			 jmp int310001
1  4212
1  4213
1  4214					 ;=============================================================================
1  4215	    2032			 int310102:				 ; resize DOS block memory
1  4216	    2032  B4 4A				 mov ah,4Ah
1  4217	    2034  8B F2				 mov si,dx			 ; preserve DX = selector
1  4218	    2036  E8 0020			 call int31010x_f1
1  4219	    2039  0F 82	FCB1			 jc int31failbx
1  4220	    203D  8B DE				 mov bx,si			 ; restore selector in BX
1  4221
1  4222	    203F			 int31010x:
1  4223	    203F  66| 67| 0F B7	54 24 +		 movzx edx,word	ptr [esp+10h]	 ; get original	size
   4224		  10
1  4225	    2046  66| C1 E2 04			 shl edx,4			 ; convert para	to bytes
1  4226	    204A  66| 4A			 dec edx			 ; limit=size-1
1  4227	    204C  66| 0F A4 D1 10		 shld ecx,edx,16
1  4228	    2051  B8 0008			 mov ax,0008h			 ; set limit
1  4229	    2054  CD 31				 int 31h
1  4230	    2056  E9 FCE5			 jmp int31ok
1  4231
1  4232
1  4233					 ;-----------------------------------------------------------------------------
1  4234	    2059			 int31010x_f1:
1  4235	    2059  5D				 pop bp
1  4236	    205A  50 53				 push ax bx
1  4237	    205C  8B DA				 mov bx,dx		 ; BX =	selector
1  4238	    205E  B8 0006			 mov ax,0006h		 ; get base
1  4239	    2061  CD 31				 int 31h
1  4240	    2063  5B 58				 pop bx	ax
1  4241	    2065  0F 82	FC92			 jc int31failax
1  4242	    2069  0F AC	CA 04			 shrd dx,cx,4		 ; adjust CX:DX	to segment value
1  4243	    206D  55				 push bp
1  4244
1  4245	    206E			 int31010x_f2:
1  4246	    206E  33 C9				 xor cx,cx
1  4247	    2070  51				 push cx		 ; set real mode SS:SP
1  4248	    2071  51				 push cx
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 76
kernel.asm



1  4249	    2072  66| 83 EC 0A			 sub esp,10
1  4250	    2076  52				 push dx		 ; set real mode ES
1  4251	    2077  51				 push cx		 ; set real mode flags
1  4252	    2078  66| 60			 pushad			 ; set real mode registers
1  4253	    207A  16				 push ss
1  4254	    207B  07				 pop es
1  4255	    207C  66| 8B FC			 mov edi,esp
1  4256	    207F  B3 21				 mov bl,21h
1  4257	    2081  B8 0300			 mov ax,0300h
1  4258	    2084  CD 31				 int 31h
1  4259	    2086  67| 8B 5C 24 10		 mov bx,[esp+10h]	 ; get BX from structure
1  4260	    208B  67| 8B 44 24 1C		 mov ax,[esp+1Ch]	 ; get AX from structure
1  4261	    2090  66| 67| 8D 64	24 32		 lea esp,[esp+32h]
1  4262	    2096  5D				 pop bp
1  4263	    2097  0F 82	FC60			 jc int31failax		 ; if error, fail
1  4264	    209B  67| 0F BA 64 24 EC  +		 bt word ptr [esp-14h],0
   4265		  00
1  4266	    20A2  FF E5				 jmp bp
1  4267
1  4268
1  4269
1  4270
1  4271
1  4272
1  4273					 ;=============================================================================
1  4274					 ; INTERRUPT FUNCTIONS
1  4275					 ;=============================================================================
1  4276
1  4277					 ;=============================================================================
1  4278	    20A4			 int310200:				 ; get real mode interrupt vector
1  4279	    20A4  66| 0F B6 DB			 movzx ebx,bl			 ; EBX = BL (interrupt number)
1  4280	    20A8  67| 8B 14 9D	      +		 mov dx,[ebx*4+0]		 ; load	real mode vector offset
   4281		  00000000
1  4282	    20B0  67| 8B 0C 9D	      +		 mov cx,[ebx*4+2]		 ; load	real mode vector segment
   4283		  00000002
1  4284	    20B8  E9 FC5E			 jmp int31okdx			 ; return ok, with AX, CX, DX
1  4285
1  4286
1  4287					 ;=============================================================================
1  4288	    20BB			 int310201:				 ; set real mode interrupt vector
1  4289	    20BB  0F 21	FD			 mov ebp,dr7
1  4290	    20BE  66| 33 C0			 xor eax,eax			 ; reset null-ptr protection
1  4291	    20C1  0F 23	F8			 mov dr7,eax
1  4292	    20C4  66| 0F B6 DB			 movzx ebx,bl			 ; EBX = BL (interrupt number)
1  4293	    20C8  67| 89 14 9D	      +		 mov [ebx*4+0],dx		 ; set real mode vector	offset
   4294		  00000000
1  4295	    20D0  67| 89 0C 9D	      +		 mov [ebx*4+2],cx		 ; set real mode vector	segment
   4296		  00000002
1  4297	    20D8  0F 23	FD			 mov dr7,ebp
1  4298	    20DB  E9 FC60			 jmp int31ok			 ; return ok
1  4299
1  4300
1  4301					 ;=============================================================================
1  4302	    20DE			 int310202:				 ; get protected mode exception	handler
1  4303	    20DE  2E: 8E 1E 0010		 mov ds,cs:seldata
1  4304	    20E3  80 FB	20			 cmp bl,20h			 ; must	be in range 00-1Fh
1  4305	    20E6  0F 83	FBE4			 jae int31fail8021		 ; invalid value
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 77
kernel.asm



1  4306
1  4307	    20EA  33 C9				 xor cx,cx
1  4308	    20EC  66| 33 D2			 xor edx,edx
1  4309	    20EF  80 FB	10			 cmp bl,10h			 ; if interrupt	not in range 00-0Fh
1  4310	    20F2  73 57	90 90			 jae @@done			 ; return 0000:00000000h
1  4311	    20F6  F6 06	0000r 02		 test pm32_mode,00000010b	 ; if no internal exception handling
1  4312	    20FB  74 09	90 90			 jz @@0				 ; then	read as	is
1  4313	    20FF  E8 FCA0			 call checkint
1  4314	    2102  74 21	90 90			 jz @@1
1  4315
1  4316	    2106  66| 0F B6 DB		 @@0:	 movzx ebx,bl
1  4317	    210A  66| C1 E3 03			 shl ebx,3			 ; adjust for location in IDT
1  4318	    210E  66| 03 1E 003Ar		 add ebx,idtbase		 ; add base of IDT
1  4319	    2113  B8 0018			 mov ds,selzero
**Error** TEXT\KERNEL\int31h.asm(729) Illegal use of segment register
1  4320	    2116  66| 67| 8B 53	04		 mov edx,dword ptr [ebx+4]	 ; get high word of offset
1  4321	    211B  67| 8B 13			 mov dx,word ptr [ebx+0]	 ; get low word	of offset
1  4322	    211E  67| 8B 4B 02			 mov cx,word ptr [ebx+2]	 ; get selector
1  4323	    2122  EB 27	90			 jmp @@done
1  4324
1  4325	    2125  0F A3	1E 00D0r	 @@1:	 bt excset_pm,bx		 ; check if EXC	is installed
1  4326	    212A  66| 67| 8D 14	9D    +		 lea edx,exc_matrix[ebx*4]	 ; load	default	EIP
   4327		  00001650r
1  4328	    2133  B9 0008			 mov cx,SELCODE			 ; load	default	CS
1  4329	    2136  73 13	90 90			 jnc @@done			 ; if EXC not installed, then done
1  4330	    213A  66| 67| 8B 14	DD    +		 mov edx,dptr exctab_pm[ebx*8+0] ; get EIP
   4331		  00000192r
1  4332	    2143  67| 8B 0C DD	      +		 mov cx,wptr exctab_pm[ebx*8+4]	 ; get CS
   4333		  00000196r
1  4334	    214B  67| 8B 44 24 1C	 @@done: mov ax,[esp+28]
1  4335	    2150  E9 FBBD			 jmp int31okedx			 ; return ok, with AX, CX, EDX
1  4336
1  4337
1  4338					 ;=============================================================================
1  4339	    2153			 int310203:				 ; set protected mode exception	handler
1  4340	    2153  87 D9				 xchg bx,cx			 ; swap	int number with	int selector
1  4341	    2155  E8 FBF6			 call int31testsel		 ; test	for valid selector BX
1  4342	    2158  87 D9				 xchg bx,cx
1  4343
1  4344	    215A  2E: 8E 1E 0010		 mov ds,cs:seldata
1  4345	    215F  80 FB	20			 cmp bl,20h			 ; must	be in range 00-1Fh
1  4346	    2162  0F 83	FB68			 jae int31fail8021		 ; invalid value
1  4347	    2166  80 FB	10			 cmp bl,10h			 ; only	16 exceptions are supported
1  4348	    2169  73 6E	90 90			 jae @@done
1  4349	    216D  66| 0F B7 C9			 movzx ecx,cx
1  4350	    2171  F6 06	0000r 02		 test pm32_mode,00000010b	 ; if no internal exception handling
1  4351	    2176  74 09	90 90			 jz @@0				 ; then	set as is
1  4352	    217A  E8 FC25			 call checkint
1  4353	    217D  74 24	90 90			 jz @@1
1  4354
1  4355	    2181  66| 0F B6 DB		 @@0:	 movzx ebx,bl
1  4356	    2185  66| C1 E3 03			 shl ebx,3			 ; adjust for location in IDT
1  4357	    2189  66| 03 1E 003Ar		 add ebx,idtbase		 ; add base of IDT
1  4358	    218E  B8 0018			 mov ds,selzero
**Error** TEXT\KERNEL\int31h.asm(765) Illegal use of segment register
1  4359	    2191  67| 89 13			 mov word ptr [ebx+0],dx	 ; set low word	of offset
1  4360	    2194  66| C1 EA 10			 shr edx,16
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 78
kernel.asm



1  4361	    2198  67| 89 53 06			 mov word ptr [ebx+6],dx	 ; set high word of offset
1  4362	    219C  67| 89 4B 02			 mov word ptr [ebx+2],cx	 ; set selector
1  4363	    21A0  EB 37	90			 jmp @@done
1  4364
1  4365	    21A3  0F AB	1E 00D0r	 @@1:	 bts excset_pm,bx		 ; prepare and set installed bit
1  4366	    21A8  66| 67| 89 14	DD    +		 mov dptr exctab_pm[ebx*8+0],edx ; set EIP
   4367		  00000192r
1  4368	    21B1  67| 89 0C DD	      +		 mov wptr exctab_pm[ebx*8+4],cx	 ; set CS
   4369		  00000196r
1  4370	    21B9  83 F9	08			 cmp cx,SELCODE			 ; if selector <> kernel selector
1  4371	    21BC  75 1B	90 90			 jnz @@done			 ; then	we are done
1  4372	    21C0  66| 33 C0			 xor eax,eax
1  4373	    21C3  0F B3	1E 00D0r		 btr excset_pm,bx		 ; reset installed bit
1  4374	    21C8  66| 67| 89 04	DD    +		 mov dptr exctab_pm[ebx*8+0],eax ; reset EIP
   4375		  00000192r
1  4376	    21D1  67| 89 04 DD	      +		 mov wptr exctab_pm[ebx*8+4],ax	 ; reset CS
   4377		  00000196r
1  4378	    21D9  E9 FB62		 @@done: jmp int31ok			 ; return ok
1  4379
1  4380
1  4381					 ;=============================================================================
1  4382	    21DC			 int310204:				 ; get protected mode interrupt	vector
1  4383	    21DC  2E: 8E 1E 0010		 mov ds,cs:seldata
1  4384	    21E1  F6 06	0000r 02		 test pm32_mode,00000010b	 ; if no internal exception handling
1  4385	    21E6  74 09	90 90			 jz @@0				 ; then	read as	is
1  4386	    21EA  E8 FBB5			 call checkint			 ; check if one	of IRQs
1  4387	    21ED  74 21	90 90			 jz @@1				 ; if one of IRQs, read	from buffer
1  4388
1  4389	    21F1  66| 0F B6 DB		 @@0:	 movzx ebx,bl
1  4390	    21F5  66| C1 E3 03			 shl ebx,3			 ; adjust for location in IDT
1  4391	    21F9  66| 03 1E 003Ar		 add ebx,idtbase		 ; add base of IDT
1  4392	    21FE  B8 0018			 mov ds,selzero
**Error** TEXT\KERNEL\int31h.asm(795) Illegal use of segment register
1  4393	    2201  66| 67| 8B 53	04		 mov edx,dword ptr [ebx+4]	 ; get high word of offset
1  4394	    2206  67| 8B 13			 mov dx,word ptr [ebx+0]	 ; get low word	of offset
1  4395	    2209  67| 8B 4B 02			 mov cx,word ptr [ebx+2]	 ; get selector
1  4396	    220D  EB 2E	90			 jmp @@done
1  4397
1  4398	    2210  0F A3	36 00CEr	 @@1:	 bt irqset_pm,si		 ; check if IRQ	is installed
1  4399	    2215  73 1A	90 90			 jnc @@2			 ; if not, return standard handler
1  4400	    2219  A8 F0				 test al,0F0h			 ; check if IRQ	is above INT 00-0Fh
1  4401	    221B  75 D4				 jnz @@0			 ; if yes, read	as is
1  4402	    221D  66| 67| 8B 14	F5    +		 mov edx,dptr irqtab_pm[esi*8+0] ; get EIP
   4403		  00000112r
1  4404	    2226  67| 8B 0C F5	      +		 mov cx,wptr irqtab_pm[esi*8+4]	 ; get CS
   4405		  00000116r
1  4406	    222E  EB 0D	90			 jmp @@done
1  4407	    2231  66| 67| 8D 14	B5    +	 @@2:	 lea edx,std_matrix[esi*4]	 ; load	standard EIP
   4408		  000015D0r
1  4409	    223A  B9 0008			 mov cx,SELCODE			 ; load	standard CS
1  4410	    223D  67| 8B 44 24 1C	 @@done: mov ax,[esp+28]
1  4411	    2242  E9 FACB			 jmp int31okedx			 ; return ok, with AX, CX, EDX
1  4412
1  4413
1  4414					 ;=============================================================================
1  4415	    2245			 int310205:				 ; set protected mode interrupt	vector
1  4416	    2245  87 D9				 xchg bx,cx			 ; swap	int number with	int selector
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 79
kernel.asm



1  4417	    2247  E8 FB04			 call int31testsel		 ; test	for valid selector BX
1  4418	    224A  87 D9				 xchg bx,cx
1  4419
1  4420	    224C  2E: 8E 1E 0010		 mov ds,cs:seldata
1  4421	    2251  B8 0018			 mov es,selzero
**Error** TEXT\KERNEL\int31h.asm(821) Illegal use of segment register
1  4422	    2254  66| 0F B7 C9			 movzx ecx,cx			 ; ECX = CX (selector)
1  4423
1  4424	    2258  F6 06	0000r 02		 test pm32_mode,00000010b	 ; if no internal exception handling
1  4425	    225D  74 25	90 90			 jz @@0				 ; then	set as is
1  4426	    2261  E8 FB3E			 call checkint			 ; check if one	of IRQs
1  4427	    2264  74 40	90 90			 jz @@1				 ; if one of IRQs, install in buffer
1  4428	    2268  80 FB	1B			 cmp bl,1Bh			 ; process special interrupts
1  4429	    226B  0F 84	00B7			 jz @@1Bh
1  4430	    226F  80 FB	1C			 cmp bl,1Ch
1  4431	    2272  0F 84	00C7			 jz @@1Ch
1  4432	    2276  80 FB	23			 cmp bl,23h
1  4433	    2279  0F 84	00D7			 jz @@23h
1  4434	    227D  80 FB	24			 cmp bl,24h
1  4435	    2280  0F 84	00E7			 jz @@24h
1  4436
1  4437	    2284  66| 0F B6 DB		 @@0:	 movzx ebx,bl
1  4438	    2288  66| C1 E3 03			 shl ebx,3			 ; adjust for location in IDT
1  4439	    228C  66| 03 1E 003Ar		 add ebx,idtbase		 ; add base of IDT
1  4440	    2291  26: 67| 89 13			 mov word ptr es:[ebx+0],dx	 ; set low word	of offset
1  4441	    2295  66| C1 EA 10			 shr edx,16
1  4442	    2299  26: 67| 89 53	06		 mov word ptr es:[ebx+6],dx	 ; set high word of offset
1  4443	    229E  26: 67| 89 4B	02		 mov word ptr es:[ebx+2],cx	 ; set selector
1  4444	    22A3  EB 7E	90			 jmp @@done
1  4445
1  4446	    22A6  83 F9	08		 @@1:	 cmp cx,SELCODE			 ; check if restoring IRQ
1  4447	    22A9  75 3A	90 90			 jnz @@2			 ; if not, jump
1  4448	    22AD  0F B3	36 00CCr		 btr irqset_rm,si		 ; reset IRQ installed bit (RM)
1  4449	    22B2  0F B3	36 00CEr		 btr irqset_pm,si		 ; reset IRQ installed bit (PM)
1  4450	    22B7  66| 67| 8B 2C	B5    +		 mov ebp,irqtab_rm[esi*4]	 ; restore real	mode interrupt
   4451		  000000D2r
1  4452	    22C0  66| 26: 67| 89 2C 9D+		 mov es:[ebx*4],ebp
   4453		  00000000
1  4454	    22CA  A8 F0				 test al,0F0h			 ; check if IRQ	above INT 00-0Fh
1  4455	    22CC  75 B6				 jnz @@0			 ; if yes, restore prot. mode IRQ
1  4456	    22CE  66| 33 C0			 xor eax,eax
1  4457	    22D1  66| 67| 89 04	F5    +		 mov dptr irqtab_pm[esi*8+0],eax ; reset EIP
   4458		  00000112r
1  4459	    22DA  67| 89 04 F5	      +		 mov wptr irqtab_pm[esi*8+4],ax	 ; reset CS
   4460		  00000116r
1  4461	    22E2  EB 3F	90			 jmp @@done
1  4462
1  4463	    22E5  0F AB	36 00CCr	 @@2:	 bts irqset_rm,si		 ; set IRQ installed bit (RM)
1  4464	    22EA  0F AB	36 00CEr		 bts irqset_pm,si		 ; set IRQ installed bit (PM)
1  4465	    22EF  BF 0000s			 mov di,_KERNEL
1  4466	    22F2  66| C1 E7 10			 shl edi,16
1  4467	    22F6  66| 67| 8D 2C	B5    +		 lea ebp,back_matrix[esi*4]	 ; get address of real mode IRQ	handler
   4468		  00001610r
1  4469	    22FF  66| 03 EF			 add ebp,edi
1  4470	    2302  66| 26: 67| 89 2C 9D+		 mov es:[ebx*4],ebp		 ; install real	mode IRQ callback
   4471		  00000000
1  4472	    230C  66| 67| 89 14	F5    +		 mov dptr irqtab_pm[esi*8+0],edx ; install EIP (into IRQ buffer)
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 80
kernel.asm



   4473		  00000112r
1  4474	    2315  67| 89 0C F5	      +		 mov wptr irqtab_pm[esi*8+4],cx	 ; install CS (into IRQ	buffer)
   4475		  00000116r
1  4476	    231D  A8 F0				 test al,0F0h			 ; check if IRQ	above INT 00-0Fh
1  4477	    231F  0F 85	FF61			 jnz @@0			 ; if yes, install as is
1  4478	    2323  E9 FA18		 @@done: jmp int31ok			 ; return ok
1  4479
1  4480	    2326  83 F9	08		 @@1Bh:	 cmp cx,SELCODE			 ; install real	mode INT 1Bh callback
1  4481	    2329  66| A1 023Cr			 mov eax,newint1Bh
1  4482	    232D  75 06	90 90			 jnz @@1Bh0
1  4483	    2331  66| A1 0224r			 mov eax,oldint1Bh
1  4484	    2335  66| 26: A3 006C	 @@1Bh0: mov es:[4*1Bh],eax
1  4485	    233A  E9 FF47			 jmp @@0
1  4486
1  4487	    233D  83 F9	08		 @@1Ch:	 cmp cx,SELCODE			 ; install real	mode INT 1Ch callback
1  4488	    2340  66| A1 0240r			 mov eax,newint1Ch
1  4489	    2344  75 06	90 90			 jnz @@1Ch0
1  4490	    2348  66| A1 0228r			 mov eax,oldint1Ch
1  4491	    234C  66| 26: A3 0070	 @@1Ch0: mov es:[4*1Ch],eax
1  4492	    2351  E9 FF30			 jmp @@0
1  4493
1  4494	    2354  83 F9	08		 @@23h:	 cmp cx,SELCODE			 ; install real	mode INT 23h callback
1  4495	    2357  66| A1 0244r			 mov eax,newint23h
1  4496	    235B  75 06	90 90			 jnz @@23h0
1  4497	    235F  66| A1 0230r			 mov eax,oldint23h
1  4498	    2363  66| 26: A3 008C	 @@23h0: mov es:[4*23h],eax
1  4499	    2368  E9 FF19			 jmp @@0
1  4500
1  4501	    236B  83 F9	08		 @@24h:	 cmp cx,SELCODE			 ; install real	mode INT 24h callback
1  4502	    236E  66| A1 0248r			 mov eax,newint24h
1  4503	    2372  75 06	90 90			 jnz @@24h0
1  4504	    2376  66| A1 0234r			 mov eax,oldint24h
1  4505	    237A  66| 26: A3 0090	 @@24h0: mov es:[4*24h],eax
1  4506	    237F  E9 FF02			 jmp @@0
1  4507
1  4508
1  4509
1  4510					 ;=============================================================================
1  4511	    2382			 int310900:				 ; get and disable interrupt state
1  4512	    2382  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  4513	    2386  1F				 pop ds				 ; restore DS
1  4514	    2387  67| 0F BA 74 24 08  +		 btr word ptr [esp+8],9		 ; test	and clear IF bit in EFLAGS
   4515		  09
1  4516	    238E  0F 92	C0			 setc al			 ; set AL = carry (IF flag from	EFLAGS)
1  4517	    2391  E9 F9B2			 jmp int31oknopop		 ; return ok, dont pop registers
1  4518
1  4519
1  4520					 ;=============================================================================
1  4521	    2394			 int310901:				 ; get and enable interrupt state
1  4522	    2394  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  4523	    2398  1F				 pop ds				 ; restore DS
1  4524	    2399  67| 0F BA 6C 24 08  +		 bts word ptr [esp+8],9		 ; test	and set	IF bit in EFLAGS
   4525		  09
1  4526	    23A0  0F 92	C0			 setc al			 ; set AL = carry (IF flag from	EFLAGS)
1  4527	    23A3  E9 F9A0			 jmp int31oknopop		 ; return ok, dont pop registers
1  4528
1  4529
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 81
kernel.asm



1  4530					 ;=============================================================================
1  4531	    23A6			 int310902:				 ; get interrupt state
1  4532	    23A6  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  4533	    23AA  1F				 pop ds				 ; restore DS
1  4534	    23AB  67| 0F BA 64 24 08  +		 bt word ptr [esp+8],9		 ; just	test IF	bit in EFLAGS
   4535		  09
1  4536	    23B2  0F 92	C0			 setc al			 ; set AL = carry (IF flag from	EFLAGS)
1  4537	    23B5  E9 F98E			 jmp int31oknopop		 ; return ok, dont pop registers
1  4538
1  4539
1  4540
1  4541
1  4542
1  4543
1  4544					 ;=============================================================================
1  4545					 ; REAL/PROTECTED MODE TRANSLATION FUNCTIONS
1  4546					 ;=============================================================================
1  4547
1  4548					 ;=============================================================================
1  4549	    23B8			 int310301:				 ; call	real mode FAR procedure
1  4550	    23B8			 int310302:				 ; call	real mode IRET procedure
1  4551	    23B8  66| 26: 67| 8B 6F 2A		 mov ebp,dword ptr es:[edi+2Ah]	 ; get target CS:IP from structure
1  4552	    23BE  EB 0E	90			 jmp int3103			 ; go to common	code
1  4553
1  4554
1  4555					 ;=============================================================================
1  4556	    23C1			 int310300:				 ; simulate real mode interrupt
1  4557	    23C1  66| 0F B6 DB			 movzx ebx,bl			 ; get real mode INT CS:IP
1  4558	    23C5  66| 67| 8B 2C	9D    +		 mov ebp,dword ptr ds:[ebx*4]	 ; read	from real mode interrupt table
   4559		  00000000
1  4560
1  4561	    23CE			 int3103:				 ; common to 0300h, 0301h, and 0302h
1  4562	    23CE  2E: 8E 2E 0010		 mov gs,cs:seldata
1  4563	    23D3  66| 26: 67| 0F B7 5F+		 movzx ebx,word	ptr es:[edi+2Eh] ; EBX = SP from register structure
   4564		  2E
1  4565	    23DA  66| 26: 67| 0F B7 57+		 movzx edx,word	ptr es:[edi+30h] ; EDX = SS from register structure
   4566		  30
1  4567	    23E1  8B C3				 mov ax,bx			 ; check if caller provided stack
1  4568	    23E3  0B C2				 or ax,dx
1  4569	    23E5  75 1F	90 90			 jnz @@f3			 ; if yes, go on to setup stack
1  4570
1  4571	    23E9  2E: 8B 16 02B0r		 mov dx,cs:rmstacktop		 ; DX =	SS for real mode redirection
1  4572	    23EE  2E: 8B 1E 02ACr		 mov bx,cs:rmstacklen		 ; get size of real mode stack
1  4573	    23F3  2B D3				 sub dx,bx			 ; adjust DX to	next stack location
1  4574	    23F5  2E: 3B 16 02AEr		 cmp dx,cs:rmstackbase		 ; exceeded real mode stack space?
1  4575	    23FA  0F 82	F8BC			 jb int31fail8012		 ; if yes, error 8012h
1  4576	    23FE  65: 89 16 02B0r		 mov gs:rmstacktop,dx		 ; update ptr for possible reenterancy
1  4577	    2403  C1 E3	04			 shl bx,4			 ; adjust BX from paragraphs to	bytes
1  4578
1  4579	    2406  66| 67| 8D 3C	95    +	 @@f3:	 lea edi,[edx*4]		 ; EDI -> top of real mode stack
   4580		  00000000
1  4581	    240F  66| 67| 8D 3C	BB		 lea edi,[edi*4+ebx]
1  4582
1  4583	    2414  8C D0				 mov ax,ss
1  4584	    2416  65: 87 06 02C0r		 xchg ax,gs:rmstackss		 ; preserve and	set new	top of stack
1  4585	    241B  50				 push ax			 ; parms for possible reenterancy
1  4586	    241C  66| 67| 8D 44	24 FC		 lea eax,[esp-4]
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 82
kernel.asm



1  4587	    2422  66| 65: 87 06	02BCr		 xchg eax,gs:rmstackesp
1  4588	    2428  66| 50			 push eax
1  4589
1  4590	    242A  66| 0F B7 C9			 movzx ecx,cx
1  4591	    242E  8B C1				 mov ax,cx			 ; EAX = length	of stack parms
1  4592	    2430  03 C0				 add ax,ax			 ; convert words to bytes
1  4593	    2432  83 EB	2E			 sub bx,2Eh			 ; adjust real mode SP for needed vars
1  4594	    2435  2B D8				 sub bx,ax			 ; adjust real mode SP for stack parms
1  4595
1  4596	    2437  1E 06				 push ds es			 ; swap	DS and ES
1  4597	    2439  1F 07				 pop ds	es
1  4598
1  4599	    243B  FD				 std				 ; string copy backwards
1  4600	    243C  66| 83 EF 02			 sub edi,2			 ; copy	stack parms from protected mode
1  4601	    2440  66| 67| 8D 74	4C 3E		 lea esi,[ecx*2+esp+3Eh]	 ; stack to real mode stack
1  4602	    2446  F3> 36: 67| A5		 rep movs word ptr es:[edi],ss:[esi]
1  4603
1  4604	    244A  66| 67| 8B 74	24 06		 mov esi,[esp+06h]		 ; ESI = offset	of structure from stack
1  4605	    2450  67| 8B 46 20			 mov ax,ds:[esi+20h]		 ; AX =	FLAGS from register structure
1  4606	    2454  67| 80 7C 24 22 01		 cmp byte ptr [esp+22h],1	 ; check AL on stack for function code
1  4607	    245A  74 0A	90 90			 jz @@f4			 ; if function 0301h, go on
1  4608	    245E  80 E4	FC			 and ah,0FCh			 ; 0300h or 0302h, clear IF and	TF flag
1  4609	    2461  67| AB			 stos word ptr es:[edi]		 ; put flags on	real mode stack
1  4610	    2463  83 EB	02			 sub bx,2
1  4611
1  4612	    2466  FC			 @@f4:	 cld				 ; string copy forward
1  4613	    2467  66| 67| 8D 3C	95    +		 lea edi,[edx*4]		 ; EDI -> bottom of stack
   4614		  00000000
1  4615	    2470  66| 67| 8D 3C	BB		 lea edi,[edi*4+ebx]
1  4616	    2475  B1 08				 mov cl,8			 ; copy	general	regs to	real mode stack
1  4617	    2477  F3> 66| 67| A5		 rep movs dword	ptr es:[edi],ds:[esi]
1  4618	    247B  66| 83 C6 06			 add esi,6			 ; copy	FS and GS to real mode stack
1  4619	    247F  66| 67| A5			 movs dword ptr	es:[edi],ds:[esi]
1  4620
1  4621	    2482  26: 67| C7 47	08    +		 mov word ptr es:[edi+8],_KERNEL ; return address from call
   4622		  0000s
1  4623	    2489  26: 67| C7 47	06    +		 mov word ptr es:[edi+6],offs @@f1
   4624		  24B5r
1  4625	    2490  26: 67| 89 47	04		 mov word ptr es:[edi+4],ax	 ; store FLAGS for real	mode IRET maybe
1  4626	    2495  66| 26: 67| 89 2F		 mov dword ptr es:[edi],ebp	 ; put call address to real mode stack
1  4627	    249A  67| 8B 46 FA			 mov ax,[esi-6]			 ; real	mode DS	from register structure
1  4628	    249E  67| 8B 4E F8			 mov cx,[esi-8]			 ; real	mode ES	from register structure
1  4629	    24A2  BE 0000s			 mov si,_KERNEL			 ; real	mode target CS:IP
1  4630	    24A5  BF 24AEr			 mov di,offs @@f0
1  4631	    24A8  66				 db 66h				 ; JMP DWORD PTR, as in	32bit offset,
1  4632	    24A9  2E: FF 26 0046r		 jmp word ptr cs:pmtormswrout	 ;  not	seg:16bit offset
1  4633
1  4634	    24AE  66| 61		 @@f0:	 popad				 ; load	regs with call values
1  4635	    24B0  0F A1	0F A9			 pop fs	gs
1  4636	    24B4  CF				 iret				 ; go to call address
1  4637
1  4638	    24B5  0F A8	0F A0 1E 06	 @@f1:	 push gs fs ds es		 ; store registers on stack
1  4639	    24BB  9C				 pushf				 ; store flags on stack
1  4640	    24BC  FA				 cli
1  4641	    24BD  66| 60			 pushad
1  4642
1  4643	    24BF  66| 33 C0			 xor eax,eax
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 83
kernel.asm



1  4644	    24C2  8C D0				 mov ax,ss			 ; EAX = linear	ptr to SS
1  4645	    24C4  66| 33 ED			 xor ebp,ebp
1  4646	    24C7  66| C1 E0 04			 shl eax,4
1  4647	    24CB  8B EC				 mov bp,sp			 ; EBP = SP
1  4648	    24CD  66| 03 E8			 add ebp,eax			 ; EBP -> stored regs on stack
1  4649
1  4650	    24D0  2E: 8B 16 02C0r		 mov dx,cs:rmstackss		 ; get protected mode SS:ESP from stack
1  4651	    24D5  66| 2E: 8B 1E	02BCr		 mov ebx,cs:rmstackesp
1  4652	    24DB  B8 0018			 mov ax,SELZERO			 ; DS selector value for protected mode
1  4653	    24DE  B9 0010			 mov cx,SELDATA			 ; ES selector value for protected mode
1  4654	    24E1  BE 0008			 mov si,SELCODE			 ; target CS:EIP in protected mode
1  4655	    24E4  66| BF 000024EFr		 mov edi,offs @@f2
1  4656	    24EA  2E: FF 26 0044r		 jmp cs:rmtopmswrout		 ; go back to protected	mode
1  4657
1  4658	    24EF  06			 @@f2:	 push es
1  4659	    24F0  0F A9				 pop gs
1  4660	    24F2  66| 26: 8F 06	02BCr		 pop es:rmstackesp
**Error** TEXT\KERNEL\int31h.asm(1042) Forward reference needs override
1  4661	    24F7  26: 8F 06 02C0r		 pop es:rmstackss
1  4662	    24FC  66| 8B F5			 mov esi,ebp			 ; copy	return regs from real mode
1  4663	    24FF  66| 67| 8B 3C	24		 mov edi,[esp]			 ; get structure offset	from stack
1  4664	    2504  67| 8E 44 24 24		 mov es,[esp+24h]
1  4665	    2509  66| B9 00000015		 mov ecx,15h			 ;  stack to register structure
1  4666	    250F  FC				 cld
1  4667	    2510  F3> 67| A5			 rep movs word ptr es:[edi],ds:[esi]
1  4668
1  4669	    2513  66| 26: 67| 83 7F 04+		 cmp dword ptr es:[edi+4],0	 ; stack provided by caller?
   4670		  00
1  4671	    251A  0F 85	F820			 jne int31ok			 ; if yes, done	now
1  4672	    251E  2E: A1 02ACr			 mov ax,cs:rmstacklen		 ; restore top of real mode stack
1  4673	    2522  65: 01 06 02B0r		 add gs:rmstacktop,ax
1  4674	    2527  E9 F814			 jmp int31ok			 ; return ok
1  4675
1  4676
1  4677					 ;=============================================================================
1  4678	    252A			 int310303:				 ; allocate real mode callback address
1  4679	    252A  2E: 8A 1E 0003r		 mov bl,cs:pm32_callbacks	 ; CL =	total number of	callbacks
1  4680	    252F  84 DB				 test bl,bl			 ; are there any?
1  4681	    2531  0F 84	F78F			 jz int31fail8015		 ; if no, error	8015h
1  4682
1  4683	    2535  66| 2E: 8B 16	02C4r		 mov edx,cs:callbackbase	 ; EDX -> base of callbacks
1  4684	    253B  66| 8B CA			 mov ecx,edx			 ; for later use
1  4685
1  4686	    253E  67| 83 7A 03 00	 @@l0:	 cmp word ptr [edx+3],0		 ; is this callback free?
1  4687	    2543  74 0D	90 90			 jz @@f0			 ; if yes, allocate
1  4688	    2547  66| 83 C2 19			 add edx,25			 ; increment ptr to callback
1  4689	    254B  FE CB				 dec bl				 ; decrement loop counter
1  4690	    254D  75 EF				 jnz @@l0			 ; if more callbacks to	check, loop
1  4691	    254F  E9 F772			 jmp int31fail8015		 ; no free callback, error 8015h
1  4692
1  4693	    2552  67| 8B 5C 24 26	 @@f0:	 mov bx,[esp+38]		 ; BX =	caller DS from stack
1  4694	    2557  67| 89 5A 03			 mov [edx+3],bx			 ; store callback parms	in callback
1  4695	    255B  66| 67| 89 72	07		 mov [edx+7],esi
1  4696	    2560  67| 8C 42 0C			 mov [edx+12],es
1  4697	    2564  66| 67| 89 7A	10		 mov [edx+16],edi
1  4698	    2569  66| 2B D1			 sub edx,ecx			 ; DX =	offset of callback
1  4699	    256C  66| C1 E9 04			 shr ecx,4			 ; CX =	segment	of callback
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 84
kernel.asm



1  4700	    2570  E9 F7A6			 jmp int31okdx			 ; return ok, with DX, CX, AX
1  4701
1  4702
1  4703					 ;=============================================================================
1  4704	    2573			 int310304:				 ; free	real mode callback address
1  4705	    2573  2E: 3B 0E 02C8r		 cmp cx,cs:callbackseg		 ; valid callback segment?
1  4706	    2578  0F 85	F761			 jne int31fail8024		 ; if no, error	8024h
1  4707
1  4708	    257C  66| 0F B7 DA			 movzx ebx,dx			 ; EBX = offset	of callback
1  4709	    2580  33 C0				 xor ax,ax			 ; check if valid offset
1  4710	    2582  92				 xchg dx,ax
1  4711	    2583  B9 0019			 mov cx,25
1  4712	    2586  F7 F1				 div cx
1  4713	    2588  85 D2				 test dx,dx			 ; is there a remainder
1  4714	    258A  0F 85	F74F			 jnz int31fail8024		 ; if yes, not valid, error 8024h
1  4715	    258E  84 E4				 test ah,ah			 ; callback index too big?
1  4716	    2590  0F 85	F749			 jnz int31fail8024		 ; if yes, not valid, error 8024h
1  4717	    2594  2E: 3A 06 0003r		 cmp al,cs:pm32_callbacks	 ; callback index out of range?
1  4718	    2599  0F 83	F740			 jae int31fail8024		 ; if yes, not valid, error 8024h
1  4719
1  4720	    259D  66| 2E: 03 1E	02C4r		 add ebx,cs:callbackbase	 ; EBX -> callback
1  4721	    25A3  67| C7 43 03 0000		 mov word ptr [ebx+3],0		 ; set callback	as free
1  4722	    25A9  E9 F792			 jmp int31ok			 ; return ok
1  4723
1  4724
1  4725
1  4726
1  4727
1  4728
1  4729					 ;=============================================================================
1  4730					 ; MISC	FUNCTIONS
1  4731					 ;=============================================================================
1  4732
1  4733					 ;=============================================================================
1  4734	    25AC			 int310305:				 ; get state save/restore addresses
1  4735	    25AC  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  4736	    25B0  1F				 pop ds				 ; restore DS
1  4737	    25B1  33 C0				 xor ax,ax			 ; size	needed is none
1  4738	    25B3  2E: 8B 1E 0016r		 mov bx,cs:kernel_code		 ; real	mode seg of same RETF
1  4739	    25B8  B9 11CCr			 mov cx,offs vxr_saverestorerm	 ; same	offset of 16bit	RETF
1  4740	    25BB  8C CE				 mov si,cs			 ; selector of routine is this one
1  4741	    25BD  66| BF 000011CBr		 mov edi,offs vxr_saverestorepm	 ; offset of simple 32bit RETF
1  4742	    25C3  E9 F780			 jmp int31oknopop		 ; return ok, dont pop registers
1  4743
1  4744
1  4745					 ;=============================================================================
1  4746	    25C6			 int310306:				 ; get raw mode	switch addresses
1  4747	    25C6  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  4748	    25CA  1F				 pop ds				 ; restore DS
1  4749	    25CB  8C CE				 mov si,cs			 ; selector of pmtorm rout is this one
1  4750	    25CD  66| 2E: 8B 3E	0046r		 mov edi,cs:pmtormswrout	 ; offset in this seg of rout
1  4751	    25D3  2E: 8B 1E 0016r		 mov bx,cs:kernel_code		 ; real	mode seg of rmtopm rout
1  4752	    25D8  2E: 8B 0E 0044r		 mov cx,cs:rmtopmswrout		 ; offset of rout in real mode
1  4753	    25DD  E9 F766			 jmp int31oknopop		 ; return ok, dont pop registers
1  4754
1  4755
1  4756					 ;=============================================================================
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 85
kernel.asm



1  4757	    25E0			 int310400:				 ; get version
1  4758	    25E0  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  4759	    25E4  1F				 pop ds				 ; restore DS
1  4760	    25E5  B8 005A			 mov ax,005Ah			 ; return version 0.9
1  4761	    25E8  BB 0003			 mov bx,0003h			 ; capabilities
1  4762	    25EB  2E: 80 3E 001Ar 02		 cmp cs:pmodetype,2
1  4763	    25F1  75 04	90 90			 jnz @@1
1  4764	    25F5  B3 01				 mov bl,1
1  4765	    25F7  2E: 8A 0E 0018r	 @@1:	 mov cl,cs:cputype		 ; processor type
1  4766	    25FC  2E: 8B 16 001Cr		 mov dx,word ptr cs:picslave	 ; master and slave PIC	values
1  4767	    2601  E9 F742			 jmp int31oknopop		 ; return ok, don't pop	registers
1  4768
1  4769
1  4770					 ;=============================================================================
1  4771	    2604			 int310A00:				 ; vendor specific extensions
1  4772	    2604  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  4773	    2608  1F				 pop ds				 ; restore DS
1  4774
1  4775	    2609  06 66| 57 66|	51 66|+		 push es edi ecx esi		 ; save	regs that will be modified
   4776		  56
1  4777	    2610  0E				 push cs			 ; ES =	CS
1  4778	    2611  07				 pop es
1  4779
1  4780	    2612  66| B9 0000000F		 mov ecx,15			 ; search for vendor1 string
1  4781	    2618  66| BF 00002696r		 mov edi,offs @@str1
1  4782	    261E  66| 56			 push esi
1  4783	    2620  F3> 67| A6			 repe cmps byte	ptr ds:[esi],es:[edi]
1  4784	    2623  66| 5E			 pop esi
1  4785	    2625  66| BF 000026BCr		 mov edi,offs @@ent1		 ; ES:EDI = sel:offset of entry	SUNSYS
1  4786	    262B  74 2C	90 90			 jz @@0				 ; if found, jump
1  4787	    262F  2E: F6 06 0000r 80		 test cs:pm32_mode,10000000b	 ; check if to ignore DOS/4G extensions
1  4788	    2635  75 52	90 90			 jnz @@err			 ; if not, we are done
1  4789	    2639  B1 10				 mov cl,16			 ; search for vendor2 string
1  4790	    263B  66| BF 000026A5r		 mov edi,offs @@str2
1  4791	    2641  F3> 67| A6			 repe cmps byte	ptr ds:[esi],es:[edi]
1  4792	    2644  75 43	90 90			 jnz @@err			 ; if not found, done
1  4793	    2648  66| BF 000026B5r		 mov edi,offs @@ent2		 ; ES:EDI = sel:offset of entry	DOS/4G
1  4794	    264E  66| 5E 66| 59			 pop esi ecx
1  4795	    2652  66| 83 C4 06			 add esp,6
1  4796	    2656  E9 F6ED			 jmp int31oknopop
1  4797
1  4798	    2659  66| 83 C4 0E		 @@0:	 add esp,14
1  4799	    265D  66| 33 C0			 xor eax,eax			 ; clear high words
1  4800	    2660  66| 8B D8			 mov ebx,eax
1  4801	    2663  66| 8B C8			 mov ecx,eax
1  4802	    2666  66| 8B D0			 mov edx,eax
1  4803	    2669  2E: A1 0014r			 mov ax,cs:client_version	 ; AX =	DOS Extender Version Number
1  4804	    266D  2E: 8A 1E 0000r		 mov bl,cs:pm32_mode		 ; BL =	kernel configuration
1  4805	    2672  2E: 8A 3E 001Ar		 mov bh,cs:pmodetype		 ; BH =	system software	type
1  4806	    2677  2E: 8A 0E 0018r		 mov cl,cs:cputype		 ; CL =	processor type
1  4807	    267C  2E: 8A 2E 0019r		 mov ch,cs:fputype		 ; CH =	FPU type
1  4808	    2681  2E: 8B 16 001Cr		 mov dx,word ptr cs:picslave	 ; DX =	PIC values (unremapped)
1  4809	    2686  E9 F6BD			 jmp int31oknopop
1  4810
1  4811	    2689  66| 5E 66| 59	66| 5F+	 @@err:	 pop esi ecx edi es		 ; if none of the strings was idetified
   4812		  07
1  4813	    2690  B8 8001			 mov ax,8001h			 ; return with AX=8001h
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 86
kernel.asm



1  4814	    2693  E9 F672			 jmp int31failnopop
1  4815
1  4816	    2696  53 55	4E 53 59 53 20+	 @@str1	 db 'SUNSYS DOS/32A',0		 ; vendor1 API ID-string (DOS/32A)
   4817		  44 4F	53 2F 33 32 41+
   4818		  00
1  4819	    26A5  52 41	54 49 4F 4E 41+	 @@str2	 db 'RATIONAL DOS/4G',0		 ; vendor2 API ID-string (DOS/4G)
   4820		  4C 20	44 4F 53 2F 34+
   4821		  47 00
1  4822
1  4823	    26B5  B0 84			 @@ent2: mov al,84h			 ; vendor2 API entry point (DOS/4G)
1  4824	    26B7  2E: FF 2E 0010r		 jmp dword ptr cs:client_call
1  4825
1  4826	    26BC  84 C0			 @@ent1: test al,al			 ; vendor1 API entry point (DOS/32A)
1  4827	    26BE  74 3B	90 90			 jz API_func00
1  4828	    26C2  3C 01				 cmp al,01h
1  4829	    26C4  74 55	90 90			 jz API_func01
1  4830	    26C8  3C 02				 cmp al,02h
1  4831	    26CA  74 70	90 90			 jz API_func02
1  4832	    26CE  3C 03				 cmp al,03h
1  4833	    26D0  74 7C	90 90			 jz API_func03
1  4834	    26D4  3C 04				 cmp al,04h
1  4835	    26D6  0F 84	008C			 jz API_func04
1  4836	    26DA  3C 05				 cmp al,05h
1  4837	    26DC  0F 84	00A8			 jz API_func05
1  4838	    26E0  3C 06				 cmp al,06h
1  4839	    26E2  0F 84	00C0			 jz API_func06
1  4840	    26E6  3C 07				 cmp al,07h
1  4841	    26E8  0F 84	00D2			 jz API_func07
1  4842	    26EC  3C 08				 cmp al,08h
1  4843	    26EE  0F 84	00D9			 jz API_func08
1  4844	    26F2  3C 09				 cmp al,09h
1  4845	    26F4  0F 84	00E5			 jz API_func09
1  4846	    26F8  F9				 stc
1  4847	    26F9  66				 db 66h
1  4848	    26FA  CB				 retf
1  4849
1  4850
1  4851
1  4852	    26FB			 API_func00:			 ; API function	00h: get access	to IDT & GDT
1  4853	    26FB  BB 0018			 mov bx,SELZERO
1  4854	    26FE  66| 2E: 0F B7	0E    +		 movzx ecx,cs:gdtlimit	 ; ECX = GDT limit
   4855		  0030r
1  4856	    2705  66| 2E: 0F B7	16    +		 movzx edx,cs:idtlimit	 ; EDX = IDT limit
   4857		  0038r
1  4858	    270C  66| 2E: 8B 36	0032r		 mov esi,cs:gdtbase	 ; BX:ESI = pointer to GDT
1  4859	    2712  66| 2E: 8B 3E	003Ar		 mov edi,cs:idtbase	 ; BX:EDI = pointer to IDT
1  4860	    2718  E9 00CB			 jmp API_funcok
1  4861
1  4862	    271B			 API_func01:			 ; API function	01h: get access	to PageTables
1  4863	    271B  BB 0018			 mov bx,SELZERO
1  4864	    271E  66| 2E: 0F B6	0E    +		 movzx ecx,cs:pagetables	 ; ECX = number	of allocated pagetables
   4865		  001Br
1  4866	    2725  66| 2E: 0F B6	16    +		 movzx edx,cs:pm32_maxfpages	 ; EDX = number	of allocated phystables
   4867		  0002r
1  4868	    272C  66| 2E: 8B 36	0260r		 mov esi,cs:pagetablebase	 ; BX:ESI = pointer to 0th pagetable
1  4869	    2732  66| 2E: 8B 3E	026Cr		 mov edi,cs:phystablebase	 ; BX:EDI = pointer to phystable
1  4870	    2738  41				 inc cx
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 87
kernel.asm



1  4871	    2739  E9 00AA			 jmp API_funcok
1  4872
1  4873	    273C			 API_func02:			 ; API function	02: get	access to INT tables
1  4874	    273C  BB 0010			 mov bx,SELDATA
1  4875	    273F  66| BE 000000CCr		 mov esi,offs irqset_rm	 ; BX:ESI = pointer to INT switches
1  4876	    2745  66| BF 000000D2r		 mov edi,offs irqtab_rm	 ; BX:EDI = pointer to INT tables
1  4877	    274B  E9 0098			 jmp API_funcok
1  4878
1  4879	    274E			 API_func03:			 ; API function	03: get	access to EXT memory
1  4880	    274E  BB 0018			 mov bx,SELZERO
1  4881	    2751  66| 2E: 8B 0E	0080r		 mov ecx,cs:mem_free	 ; ECX = size of allocated memory
1  4882	    2757  66| 2E: 8B 16	007Cr		 mov edx,cs:mem_ptr	 ; EDX = pointer to allocated memory
1  4883	    275D  66| 2E: 8B 36	0084r		 mov esi,cs:mem_top	 ; ESI = top of	allocated memory
1  4884	    2763  E9 0080			 jmp API_funcok
1  4885
1  4886	    2766			 API_func04:			 ; API function	04: get	access to rm-stacks
1  4887	    2766  BB 0018			 mov bx,SELZERO
1  4888	    2769  66| 2E: 0F B7	0E    +		 movzx ecx,cs:rmstacklen	 ; ECX = size of one stack
   4889		  02ACr
1  4890	    2770  66| 2E: 0F B7	16    +		 movzx edx,cs:rmstacktop	 ; EDX = pointer to top	of stack
   4891		  02B0r
1  4892	    2777  66| 2E: 0F B7	36    +		 movzx esi,cs:rmstackbase	 ; ESI = base of stack area
   4893		  02AEr
1  4894	    277E  66| 2E: 0F B7	3E    +		 movzx edi,cs:rmstacktop2	 ; EDI = default top of	stack
   4895		  02B2r
1  4896	    2785  EB 5F	90			 jmp API_funcok
1  4897
1  4898	    2788			 API_func05:			 ; API function	05: get	access to pm-stacks
1  4899	    2788  BB 0018			 mov bx,SELZERO
1  4900	    278B  66| 2E: 8B 0E	029Cr		 mov ecx,cs:pmstacklen	 ; ECX = size of one stack
1  4901	    2791  66| 2E: 8B 16	02A4r		 mov edx,cs:pmstacktop	 ; EDX = pointer to top	of stack
1  4902	    2797  66| 2E: 8B 36	02A0r		 mov esi,cs:pmstackbase	 ; ESI = base of stack area
1  4903	    279D  66| 2E: 8B 3E	02A8r		 mov edi,cs:pmstacktop2	 ; EDI = default top of	stack
1  4904	    27A3  EB 41	90			 jmp API_funcok
1  4905
1  4906	    27A6			 API_func06:			 ; API function	06: get	kernel selectors
1  4907	    27A6  BB 0008			 mov bx,SELCODE				 ; BX =	Kernel code selector
1  4908	    27A9  B9 0010			 mov cx,SELDATA				 ; CX =	Kernel data selector
1  4909	    27AC  BA 0018			 mov dx,SELZERO				 ; DX =	Kernel zero selector
1  4910	    27AF  66| 2E: 0F B7	36    +		 movzx esi,word	ptr cs:kernel_code	 ; ESI = Kernel	code segment
   4911		  0016r
1  4912	    27B6  2E: 8B 3E 0012r		 mov di,word ptr cs:client_call[2]	 ; DI =	Client code selector
1  4913	    27BB  EB 29	90			 jmp API_funcok
1  4914
1  4915	    27BE			 API_func07:			 ; API function	07: get	critical handler entry
1  4916	    27BE  2E: 8B 0E 0012r		 mov cx,cs:client_call[2]	 ; CX =	default	16bit selector
1  4917	    27C3  2E: 8B 16 0010r		 mov dx,cs:client_call[0]	 ; DX =	default	16bit offset
1  4918	    27C8  EB 1C	90			 jmp API_funcok
1  4919
1  4920	    27CB			 API_func08:			 ; API function	08: set	critical handler entry
1  4921	    27CB  1E				 push ds
1  4922	    27CC  2E: 8E 1E 0010		 mov ds,cs:seldata
1  4923	    27D1  89 0E	0012r			 mov client_call[2],cx		 ; CX =	custom 16bit selector
1  4924	    27D5  89 16	0010r			 mov client_call[0],dx		 ; DX =	custom 16bit offset
1  4925	    27D9  1F				 pop ds
1  4926	    27DA  EB 0A	90			 jmp API_funcok
1  4927
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 88
kernel.asm



1  4928	    27DD			 API_func09:			 ; API function	09: get	access to p. counters
1  4929	    27DD  B9 0010			 mov cx,SELDATA			 ; CX =	Kernel data selector
1  4930	    27E0  66| BA 0000027Cr		 mov edx,offs _pc_base		 ; EDX = base of performance counters
1  4931
1  4932	    27E6			 API_funcok:
1  4933	    27E6  F8				 clc
1  4934	    27E7  66				 db 66h
1  4935	    27E8  CB				 retf
1  4936
1  4937
1  4938
1  4939
1  4940
1  4941
1  4942					 ;=============================================================================
1  4943					 ; MEMORY FUNCTIONS
1  4944					 ;=============================================================================
1  4945
1  4946					 ;=============================================================================
1  4947	    27E9			 int310500:				 ; get free memory information
1  4948	    27E9  66| 83 C8 FF			 or eax,-1
1  4949	    27ED  66| B9 0000000C		 mov ecx,0Ch
1  4950	    27F3  66| 57			 push edi
1  4951	    27F5  F3> 66| 67| AB		 rep stos dword	ptr es:[edi]
1  4952	    27F9  66| 5F			 pop edi
1  4953	    27FB  66| 2E: A1 007Cr		 mov eax,cs:mem_ptr
1  4954	    2800  66| 2E: 0B 06	0080r		 or eax,cs:mem_free
1  4955	    2806  74 08	90 90			 jz @@1
1  4956	    280A  E8 01A7			 call int31_checkblocks
1  4957	    280D  E8 0269			 call int31_getfreemem
1  4958
1  4959	    2810  66| 8B D8		 @@1:	 mov ebx,eax
1  4960	    2813  66| 8B D0			 mov edx,eax			 ; EDX = largest free block
1  4961	    2816  66| 2E: A1 0080r		 mov eax,cs:mem_free
1  4962	    281B  66| C1 E8 0C			 shr eax,12			 ; EAX = total memory pages
1  4963	    281F  66| C1 EB 0C			 shr ebx,12			 ; EBX = free pages left
1  4964	    2823  66| C1 E9 0C			 shr ecx,12			 ; ECX = total allocated memory
1  4965	    2827  06				 push es
1  4966	    2828  1F				 pop ds
1  4967	    2829  66| 67| 89 17			 mov [edi+00h],edx		 ; 00h - largest free block
1  4968	    282D  66| 67| 89 5F	04		 mov [edi+04h],ebx		 ; 04h - max unlocked pages
1  4969	    2832  66| 67| 89 5F	08		 mov [edi+08h],ebx		 ; 08h - max locked pages
1  4970	    2837  66| 67| 89 47	0C		 mov [edi+0Ch],eax		 ; 0Ch - total linear space
1  4971	    283C  66| 67| 89 5F	10		 mov [edi+10h],ebx		 ; 10h -
1  4972	    2841  66| 67| 89 4F	14		 mov [edi+14h],ecx		 ; 14h -
1  4973	    2846  66| 67| 89 47	18		 mov [edi+18h],eax		 ; 18h - total pages
1  4974	    284B  66| 67| 89 4F	1C		 mov [edi+1Ch],ecx		 ; 1Ch - total free mem	in pages
1  4975	    2850  E9 F4EB			 jmp int31ok
1  4976
1  4977
1  4978					 ;=============================================================================
1  4979	    2853			 int310501:				 ; allocate memory block
1  4980	    2853  E8 0148			 call int31_checkifmemavail
1  4981	    2856  E8 0200			 call int31_testbxcxtoebx	 ; convert BX:CX to EBX
1  4982	    2859  E8 0158			 call int31_checkblocks
1  4983	    285C  66| 2E: 8B 36	007Cr		 mov esi,cs:mem_ptr		 ; get pointer to memory
1  4984	    2862  66| 67| 8B 46	04	 @@1:	 mov eax,[esi+04h]		 ; get block size
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 89
kernel.asm



1  4985	    2867  66| 0F BA F0 1F		 btr eax,31			 ; check if memory block is used
1  4986	    286C  72 09	90 90			 jc @@2				 ; if yes, jump
1  4987	    2870  66| 3B C3			 cmp eax,ebx			 ; check if block is large enough
1  4988	    2873  0F 83	0238			 jae int31_allocblock		 ; if yes, allocate block
1  4989	    2877  66| 67| 8D 74	06 10	 @@2:	 lea esi,[esi+eax+10h]		 ; load	address	of next	memory block
1  4990	    287D  66| 2E: 3B 36	0084r		 cmp esi,cs:mem_top		 ; check if at top of memory
1  4991	    2883  72 DD				 jb @@1				 ; if not, loop
1  4992	    2885  E9 F437			 jmp int31fail8013		 ; fail: not enough memory
1  4993
1  4994
1  4995					 ;=============================================================================
1  4996	    2888			 int310502:				 ; free	memory block
1  4997	    2888  66| C1 E6 10			 shl esi,16			 ; convert SI:DI to ESI
1  4998	    288C  8B F7				 mov si,di
1  4999	    288E  E8 010D			 call int31_checkifmemavail
1  5000	    2891  E8 0120			 call int31_checkblocks
1  5001	    2894  E8 0191			 call int31_checkhandle
1  5002	    2897  66| 67| 0F BA	76 04 +		 btr dword ptr [esi+04h],31	 ; set block as	free
   5003		  1F
1  5004	    289E  E8 026E			 call int31_linkfreeblocks
1  5005	    28A1  E9 F49A			 jmp int31ok
1  5006
1  5007
1  5008					 ;=============================================================================
1  5009	    28A4			 int310503:				 ; resize memory block
1  5010	    28A4  66| C1 E6 10			 shl esi,16			 ; convert SI:DI to ESI
1  5011	    28A8  8B F7				 mov si,di
1  5012	    28AA  E8 00F1			 call int31_checkifmemavail
1  5013	    28AD  E8 01A9			 call int31_testbxcxtoebx	 ; convert BX:CX to EBX
1  5014	    28B0  E8 0101			 call int31_checkblocks
1  5015	    28B3  E8 0172			 call int31_checkhandle
1  5016
1  5017	    28B6  66| 67| 8B 46	04		 mov eax,[esi+04h]		 ; get size of this block
1  5018	    28BB  66| 0F BA F0 1F		 btr eax,31			 ; check if block is used
1  5019	    28C0  0F 83	F414			 jnc int31fail8023		 ; if block is free, fail
1  5020	    28C4  66| 3B C3			 cmp eax,ebx			 ; check if enough memory
1  5021	    28C7  0F 83	01E4			 jae int31_allocblock		 ; if yes, reallocate block
1  5022	    28CB  66| 67| 89 46	04		 mov [esi+04h],eax		 ; set this block as free
1  5023	    28D0  66| 67| 8D 7C	06 10		 lea edi,[esi+eax+10h]		 ; get address of next block
1  5024	    28D6  66| 2E: 3B 3E	0084r		 cmp edi,cs:mem_top		 ; check if at top of memory
1  5025	    28DC  73 28	90 90			 jae @@0
1  5026	    28E0  66| 67| 8B 57	04		 mov edx,[edi+04h]		 ; get size of next block
1  5027	    28E5  66| 0F BA F2 1F		 btr edx,31			 ; check if block next to us is	free
1  5028	    28EA  72 1A	90 90			 jc @@0				 ; if not, jump
1  5029	    28EE  66| 67| 8D 54	10 10		 lea edx,[eax+edx+10h]		 ; calculate total size	(this+hdr+next)
1  5030	    28F4  66| 3B D3			 cmp edx,ebx			 ; check if enough
1  5031	    28F7  72 0D	90 90			 jb @@0				 ; if not, jump
1  5032	    28FB  66| 8B C2			 mov eax,edx			 ; set this size = (this + next)
1  5033	    28FE  66| 67| 89 46	04		 mov [esi+04h],eax		 ; link	this and next blocks
1  5034	    2903  E9 01A9			 jmp int31_allocblock		 ; and go to the allocation routine
1  5035
1  5036	    2906  66| 2E: 8B 3E	007Cr	 @@0:	 mov edi,cs:mem_ptr		 ; get pointer to memory
1  5037	    290C  66| 67| 8B 57	04	 @@1:	 mov edx,[edi+04h]		 ; get block size
1  5038	    2911  66| 0F BA F2 1F		 btr edx,31			 ; check if memory block is used
1  5039	    2916  72 09	90 90			 jc @@2				 ; if yes, jump
1  5040	    291A  66| 3B D3			 cmp edx,ebx			 ; check if block is large enough
1  5041	    291D  73 1D	90 90			 jae @@3			 ; if yes, allocate block
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 90
kernel.asm



1  5042	    2921  66| 67| 8D 7C	17 10	 @@2:	 lea edi,[edi+edx+10h]		 ; load	address	of next	memory block
1  5043	    2927  66| 2E: 3B 3E	0084r		 cmp edi,cs:mem_top		 ; check if at top of memory
1  5044	    292D  72 DD				 jb @@1				 ; if not, loop
1  5045	    292F  66| 0F BA E8 1F		 bts eax,31			 ; set this block as used
1  5046	    2934  66| 67| 89 46	04		 mov [esi+04h],eax		 ; restore state of this block
1  5047	    2939  E9 F383			 jmp int31fail8013		 ; fail: not enough memory
1  5048
1  5049	    293C  66| 56 66| 57		 @@3:	 push esi edi
1  5050	    2940  66| 8B C8			 mov ecx,eax
1  5051	    2943  66| C1 E9 02			 shr ecx,2
1  5052	    2947  66| 83 C6 10			 add esi,10h
1  5053	    294B  66| 83 C7 10			 add edi,10h
1  5054	    294F  F3> 66| 67| A5		 rep movs dword	ptr es:[edi],ds:[esi]
1  5055	    2953  8A C8				 mov cl,al
1  5056	    2955  80 E1	03			 and cl,3
1  5057	    2958  F3> 67| A4			 rep movs byte ptr es:[edi],ds:[esi]
1  5058	    295B  66| 5F 66| 5E			 pop edi esi
1  5059	    295F  E8 01AD			 call int31_linkfreeblocks
1  5060	    2962  66| 8B F7			 mov esi,edi
1  5061	    2965  66| 8B C2			 mov eax,edx
1  5062	    2968  E9 0144			 jmp int31_allocblock		 ; and go to the allocation routine
1  5063
1  5064
1  5065					 ;=============================================================================
1  5066	    296B			 int31050A:
1  5067	    296B  66| C1 E6 10			 shl esi,16			 ; convert SI:DI to ESI
1  5068	    296F  8B F7				 mov si,di
1  5069	    2971  E8 002A			 call int31_checkifmemavail
1  5070	    2974  E8 003D			 call int31_checkblocks
1  5071	    2977  E8 00AE			 call int31_checkhandle
1  5072	    297A  66| 67| 8B 5E	04		 mov ebx,[esi+04h]		 ; check if block is used
1  5073	    297F  66| 0F BA F3 1F		 btr ebx,31
1  5074	    2984  0F 83	F350			 jnc int31fail8023
1  5075	    2988  66| 83 C6 10			 add esi,10h
1  5076	    298C  66| 87 DE			 xchg ebx,esi
1  5077	    298F  8B CB				 mov cx,bx
1  5078	    2991  66| C1 EB 10			 shr ebx,16
1  5079	    2995  8B FE				 mov di,si
1  5080	    2997  66| C1 EE 10			 shr esi,16
1  5081	    299B  E9 F383			 jmp int31oksinoax
1  5082
1  5083
1  5084
1  5085
1  5086
1  5087					 ;-----------------------------------------------------------------------------
1  5088	    299E			 int31_checkifmemavail:			 ; check if memory had been allocated
1  5089	    299E  5D				 pop bp
1  5090	    299F  66| 50			 push eax
1  5091	    29A1  66| 2E: A1 007Cr		 mov eax,cs:mem_ptr
1  5092	    29A6  66| 2E: 0B 06	0080r		 or eax,cs:mem_free
1  5093	    29AC  66| 58			 pop eax
1  5094	    29AE  0F 84	F30D			 jz int31fail8013
1  5095	    29B2  FF E5				 jmp bp
1  5096
1  5097
1  5098					 ;-----------------------------------------------------------------------------
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 91
kernel.asm



1  5099	    29B4			 int31_checkblocks:			 ; check if memory had been overwritten
1  5100	    29B4  2E: F6 06 0000r 20		 test cs:pm32_mode,00100000b
1  5101	    29BA  74 55	90 90			 jz @@done
1  5102	    29BE  66| 50 66| 56			 push eax esi
1  5103	    29C2  66| 2E: 8B 36	007Cr		 mov esi,cs:mem_ptr
1  5104	    29C8  F7 C6	000F		 @@1:	 test si,000Fh			 ; blocks must be para aligned
1  5105	    29CC  75 44	90 90			 jnz @@err
1  5106	    29D0  66| B8 12345678		 mov eax,12345678h		 ; header id
1  5107	    29D6  66| 67| 3B 06			 cmp eax,[esi+00h]		 ; if no header_id at block start
1  5108	    29DA  75 36	90 90			 jnz @@err			 ; then	signal error
1  5109	    29DE  66| 67| 3B 46	0C		 cmp eax,[esi+0Ch]		 ; if no header_id at block end
1  5110	    29E3  75 2D	90 90			 jnz @@err			 ; then	signal error
1  5111	    29E7  66| 67| 8B 46	04		 mov eax,[esi+04h]		 ; get block size
1  5112	    29EC  66| 0F BA F0 1F		 btr eax,31			 ; reset the used flag
1  5113	    29F1  66| 67| 8D 74	06 10		 lea esi,[esi+eax+10h]		 ; load	address	of next	memory block
1  5114	    29F7  66| 2E: 3B 36	007Cr		 cmp esi,cs:mem_ptr
1  5115	    29FD  72 13	90 90			 jb @@err
1  5116	    2A01  66| 2E: 3B 36	0084r		 cmp esi,cs:mem_top		 ; check if at top of memory
1  5117	    2A07  77 09	90 90			 ja @@err
1  5118	    2A0B  72 BB				 jb @@1				 ; if not, loop
1  5119	    2A0D  66| 5E 66| 58			 pop esi eax
1  5120	    2A11  C3			 @@done: ret
1  5121
1  5122	    2A12  2E: 8E 1E 0010	 @@err:	 mov ds,cs:seldata
1  5123	    2A17  66| 33 C0			 xor eax,eax
1  5124	    2A1A  66| A3 007Cr			 mov mem_ptr,eax		 ; set to zero to prevent looping error
1  5125	    2A1E  66| A3 0080r			 mov mem_free,eax		 ; when	exiting
1  5126	    2A22  B0 83				 mov al,83h
1  5127	    2A24  FF 2E	0010r			 jmp dword ptr client_call
1  5128
1  5129
1  5130					 ;-----------------------------------------------------------------------------
1  5131	    2A28			 int31_checkhandle:
1  5132	    2A28  5D				 pop bp				 ; check for valid handle in ESI
1  5133	    2A29  66| 2E: 3B 36	007Cr		 cmp esi,cs:mem_ptr
1  5134	    2A2F  72 25	90 90			 jb @@1
1  5135	    2A33  66| 2E: 3B 36	0084r		 cmp esi,cs:mem_top
1  5136	    2A39  77 1B	90 90			 ja @@1
1  5137	    2A3D  66| B8 12345678		 mov eax,12345678h
1  5138	    2A43  66| 67| 3B 06			 cmp eax,[esi+00h]
1  5139	    2A47  75 0D	90 90			 jnz @@1
1  5140	    2A4B  66| 67| 3B 46	0C		 cmp eax,[esi+0Ch]
1  5141	    2A50  75 04	90 90			 jnz @@1
1  5142	    2A54  FF E5				 jmp bp
1  5143	    2A56  E9 F27F		 @@1:	 jmp int31fail8023		 ; fail: invalid handle
1  5144
1  5145
1  5146
1  5147
1  5148
1  5149					 ;-----------------------------------------------------------------------------
1  5150	    2A59			 int31_testbxcxtoebx:			 ; convert BX:CX to EBX
1  5151	    2A59  5D				 pop bp
1  5152	    2A5A  66| C1 E3 10			 shl ebx,16
1  5153	    2A5E  8B D9				 mov bx,cx
1  5154	    2A60  66| 85 DB			 test ebx,ebx
1  5155	    2A63  0F 84	F267			 jz int31fail8021		 ; BX:CX cannot	be zero
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 92
kernel.asm



1  5156	    2A67  66| 83 C3 0F			 add ebx,0Fh			 ; align EBX on	para boundary
1  5157	    2A6B  80 E3	F0			 and bl,0F0h
1  5158	    2A6E  66| 0F BA E3 1F		 bt ebx,31
1  5159	    2A73  0F 82	F257			 jc int31fail8021		 ; cannot allocate that	much memory
1  5160	    2A77  FF E5				 jmp bp
1  5161
1  5162
1  5163					 ;-----------------------------------------------------------------------------
1  5164	    2A79			 int31_getfreemem:
1  5165	    2A79  66| 33 C0			 xor eax,eax			 ; reset free memory size
1  5166	    2A7C  66| 33 C9			 xor ecx,ecx
1  5167	    2A7F  66| 2E: 8B 36	007Cr		 mov esi,cs:mem_ptr		 ; get pointer to memory
1  5168	    2A85  66| 67| 8B 56	04	 @@1:	 mov edx,[esi+04h]		 ; get block size
1  5169	    2A8A  66| 0F BA F2 1F		 btr edx,31			 ; check if memory block is used
1  5170	    2A8F  72 0F	90 90			 jc @@2				 ; if yes, jump
1  5171	    2A93  66| 03 CA			 add ecx,edx
1  5172	    2A96  66| 3B C2			 cmp eax,edx			 ; pick	largest	value
1  5173	    2A99  77 05	90 90			 ja @@2
1  5174	    2A9D  66| 8B C2			 mov eax,edx
1  5175	    2AA0  66| 67| 8D 74	16 10	 @@2:	 lea esi,[esi+edx+10h]		 ; load	addres of next memory block
1  5176	    2AA6  66| 2E: 3B 36	0084r		 cmp esi,cs:mem_top		 ; check if at top of memory
1  5177	    2AAC  72 D7				 jb @@1				 ; if not, loop
1  5178	    2AAE  C3				 ret
1  5179
1  5180
1  5181					 ;-----------------------------------------------------------------------------
1  5182	    2AAF			 int31_allocblock:
1  5183	    2AAF  66| B9 12345678		 mov ecx,12345678h
1  5184	    2AB5  66| 2E: 0F B7	16    +		 movzx edx,cs:id32_process_id
   5185		  0258r
1  5186	    2ABC  66| 2B C3			 sub eax,ebx			 ; nextsize=actualsize-allocsize
1  5187	    2ABF  66| 83 E8 10			 sub eax,10h			 ; is nextsize<16 (header size)
1  5188	    2AC3  72 1B	90 90			 jb @@1				 ; if yes, do not create next block
1  5189	    2AC7  66| 67| 8D 7C	1E 10		 lea edi,[esi+ebx+10h]		 ; EDI = ptr to	next block
1  5190	    2ACD  66| 67| 89 0F			 mov [edi+00h],ecx		 ; header ID1
1  5191	    2AD1  66| 67| 89 47	04		 mov [edi+04h],eax		 ; set next block as free/size
1  5192	    2AD6  66| 67| 89 57	08		 mov [edi+08h],edx		 ; process_ID
1  5193	    2ADB  66| 67| 89 4F	0C		 mov [edi+0Ch],ecx		 ; header ID2
1  5194
1  5195	    2AE0  66| 0F BA EB 1F	 @@1:	 bts ebx,31			 ; set this block as used
1  5196	    2AE5  66| 67| 89 0E			 mov [esi+00h],ecx		 ; header ID1
1  5197	    2AE9  66| 67| 89 5E	04		 mov [esi+04h],ebx		 ; store this block size in header
1  5198	    2AEE  66| 67| 89 56	08		 mov [esi+08h],edx		 ; process_ID
1  5199	    2AF3  66| 67| 89 4E	0C		 mov [esi+0Ch],ecx		 ; header ID2
1  5200	    2AF8  E8 0014			 call int31_linkfreeblocks
1  5201
1  5202	    2AFB  66| 67| 8D 5E	10		 lea ebx,[esi+10h]		 ; EBX = ptr to	memory block  (-header)
1  5203	    2B00  8B CB				 mov cx,bx
1  5204	    2B02  66| C1 EB 10			 shr ebx,16
1  5205	    2B06  8B FE				 mov di,si
1  5206	    2B08  66| C1 EE 10			 shr esi,16
1  5207	    2B0C  E9 F212			 jmp int31oksinoax
1  5208
1  5209
1  5210					 ;-----------------------------------------------------------------------------
1  5211	    2B0F			 int31_linkfreeblocks:
1  5212	    2B0F  66| 60			 pushad
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 93
kernel.asm



1  5213	    2B11  66| 2E: 8B 3E	007Cr		 mov edi,cs:mem_ptr		 ; EDI = ptr to	1st block handle
1  5214	    2B17  66| 2E: 8B 2E	0084r		 mov ebp,cs:mem_top
1  5215
1  5216	    2B1D  66| 67| 8B 47	04		 mov eax,[edi+04h]		 ; get 1st block size
1  5217	    2B22  66| 0F BA F0 1F		 btr eax,31
1  5218	    2B27  66| 67| 8D 74	07 10		 lea esi,[edi+eax+10h]		 ; ESI = ptr to	2nd block handle
1  5219	    2B2D  66| 3B F5			 cmp esi,ebp			 ; check if at top of memory
1  5220	    2B30  73 69	90 90			 jae @@done			 ; if yes, done
1  5221	    2B34  66| 8B F7			 mov esi,edi			 ; ESI=EDI = ptr to 1st	block
1  5222
1  5223	    2B37  66| 67| 8B 46	04	 @@1:	 mov eax,[esi+04h]		 ; get block size
1  5224	    2B3C  66| 0F BA F0 1F		 btr eax,31			 ; check if block is used
1  5225	    2B41  72 4D	90 90			 jc @@4				 ; if yes, jump
1  5226
1  5227	    2B45  66| 33 DB			 xor ebx,ebx			 ; reset amount	of free	block memory
1  5228	    2B48  66| 33 C9			 xor ecx,ecx			 ; reset number	of free	blocks in raw
1  5229	    2B4B  66| 8B FE			 mov edi,esi			 ; remember addr of first free block
1  5230	    2B4E  EB 2A	90			 jmp @@3
1  5231
1  5232	    2B51  66| 83 C1 10		 @@2:	 add ecx,10h			 ; increment number of free blocks
1  5233	    2B55  66| 67| 8B 46	04		 mov eax,[esi+04h]		 ; get block size
1  5234	    2B5A  66| 0F BA F0 1F		 btr eax,31			 ; check if block is free
1  5235	    2B5F  66| 67| 8D 1C	18		 lea ebx,[eax+ebx]		 ; amount of free memory encountered
1  5236	    2B64  73 14	90 90			 jnc @@3			 ; if yes, jump
1  5237	    2B68  66| 2B D8			 sub ebx,eax
1  5238	    2B6B  66| 83 E9 10			 sub ecx,10h
1  5239	    2B6F  66| 03 D9			 add ebx,ecx
1  5240	    2B72  66| 67| 01 5F	04		 add [edi+04h],ebx
1  5241	    2B77  EB 17	90			 jmp @@4
1  5242
1  5243	    2B7A  66| 67| 8D 74	06 10	 @@3:	 lea esi,[esi+eax+10h]		 ; calculate address of	next block
1  5244	    2B80  66| 3B F5			 cmp esi,ebp			 ; check if at top of memory
1  5245	    2B83  72 CC				 jb @@2				 ; if not, loop
1  5246	    2B85  66| 03 D9			 add ebx,ecx
1  5247	    2B88  66| 67| 01 5F	04		 add [edi+04h],ebx
1  5248	    2B8D  EB 0C	90			 jmp @@done
1  5249
1  5250	    2B90  66| 67| 8D 74	06 10	 @@4:	 lea esi,[esi+eax+10h]		 ; calculate address of	next block
1  5251	    2B96  66| 3B F5			 cmp esi,ebp			 ; check if at top of memory
1  5252	    2B99  72 9C				 jb @@1				 ; if not, loop
1  5253
1  5254	    2B9B  66| 61		 @@done: popad
1  5255	    2B9D  C3				 ret
1  5256
1  5257
1  5258
1  5259
1  5260
1  5261
1  5262					 ;=============================================================================
1  5263					 ; VIRTUAL MEMORY FUNCTIONS (not supported)
1  5264					 ;=============================================================================
1  5265
1  5266					 ;=============================================================================
1  5267	    2B9E			 int310600:
1  5268	    2B9E			 int310601:
1  5269	    2B9E			 int310602:
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 94
kernel.asm



1  5270	    2B9E			 int310603:
1  5271	    2B9E			 int310702:
1  5272	    2B9E			 int310703:
1  5273	    2B9E  E9 F19D			 jmp int31ok
1  5274
1  5275
1  5276					 ;=============================================================================
1  5277	    2BA1			 int310604:
1  5278	    2BA1  33 DB				 xor bx,bx
1  5279	    2BA3  B9 1000			 mov cx,1000h
1  5280	    2BA6  E9 F186			 jmp int31okbx
1  5281
1  5282
1  5283
1  5284
1  5285
1  5286
1  5287					 ;=============================================================================
1  5288					 ; PHYSICAL MEMORY MAPPING FUNCTIONS
1  5289					 ;=============================================================================
1  5290
1  5291					 ;=============================================================================
1  5292	    2BA9			 int310800:				 ; physical memory mapping
1  5293	    2BA9  66| C1 E3 10			 shl ebx,16			 ; convert BX:CX to EBX
1  5294	    2BAD  66| C1 E6 10			 shl esi,16			 ; convert SI:DI to ESI
1  5295	    2BB1  8B D9				 mov bx,cx
1  5296	    2BB3  8B F7				 mov si,di
1  5297	    2BB5  66| 81 FB 00100000		 cmp ebx,100000h		 ; check if mapping under 1MB limit
1  5298	    2BBC  0F 82	F10E			 jb int31fail8021		 ; if yes, error
1  5299	    2BC0  66| 85 F6			 test esi,esi			 ; check if size is zero
1  5300	    2BC3  0F 84	F107			 jz int31fail8021		 ; if yes, error
1  5301	    2BC7  2E: 80 3E 001Ar 02		 cmp cs:pmodetype,2		 ; check if system is VCPI
1  5302	    2BCD  74 05	90 90			 jz int310800v			 ; if yes, do VCPI memory mapping
1  5303	    2BD1  E9 F16A			 jmp int31ok			 ; if under raw/XMS, do	nothing
1  5304
1  5305
1  5306	    2BD4			 int310800v:
1  5307	    2BD4  2E: 80 3E 0002r 00		 cmp cs:pm32_maxfpages,0	 ; check if any	linear memory avail.
1  5308	    2BDA  0F 84	F0DC			 jz int31fail8012		 ; if not, signal error	8012h
1  5309
1  5310	    2BDE  1E				 push ds
1  5311	    2BDF  07				 pop es
1  5312	    2BE0  66| 2E: 8B 3E	026Cr		 mov edi,cs:phystablebase	 ; get base of pagetables
1  5313	    2BE6  66| 8B C3		 @@0:	 mov eax,ebx			 ; EAX = physical address
1  5314	    2BE9  66| 67| 8D 8E	      +		 lea ecx,[esi+0FFFh]		 ; ECX = size of memory	to map
   5315		  00000FFF
1  5316	    2BF1  25 F000			 and ax,0F000h
1  5317	    2BF4  66| C1 E9 0C			 shr ecx,12
1  5318	    2BF8  66| 8B D7			 mov edx,edi
1  5319	    2BFB  66| 2E: 3B 3E	0270r	 @@1:	 cmp edi,cs:phystabletop	 ; are there any pages mapped left
1  5320	    2C01  73 31	90 90			 jae @@3			 ; no, go on with mapping
1  5321
1  5322	    2C05  66| 67| 8B 2F			 mov ebp,[edi]
1  5323	    2C09  81 E5	F000			 and bp,0F000h
1  5324	    2C0D  66| 3B C5			 cmp eax,ebp			 ; check if page already mapped
1  5325	    2C10  74 08	90 90			 jz @@2				 ; if yes, go to check next page
1  5326	    2C14  66| 83 C7 04			 add edi,4			 ; increment pointer into pagetables
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 95
kernel.asm



1  5327	    2C18  EB CC				 jmp @@0			 ; loop
1  5328
1  5329	    2C1A  66| 83 C7 04		 @@2:	 add edi,4			 ; increment pointer into pagetables
1  5330	    2C1E  66| 05 00001000		 add eax,4096
1  5331	    2C24  66| 49			 dec ecx			 ; decrement amount of pages checked
1  5332	    2C26  75 D3				 jnz @@1			 ; if there are	more left, loop
1  5333	    2C28  66| 8B C3			 mov eax,ebx
1  5334	    2C2B  25 F000			 and ax,0F000h
1  5335	    2C2E  66| 2B D8			 sub ebx,eax
1  5336	    2C31  E9 0081			 jmp @@done			 ; region already mapped, we are done
1  5337
1  5338	    2C34  66| 2E: 8B 3E	026Cr	 @@3:	 mov edi,cs:phystablebase	 ; get base of pagetables
1  5339	    2C3A  66| 2E: 8B 0E	0270r		 mov ecx,cs:phystabletop	 ; get number of available pagetables
1  5340	    2C40  66| 2B CF			 sub ecx,edi
1  5341	    2C43  66| C1 E9 02			 shr ecx,2			 ; convert to 4KB pages
1  5342	    2C47  66| 8B C3			 mov eax,ebx
1  5343	    2C4A  25 F000			 and ax,0F000h
1  5344	    2C4D  66| 67| 8D AC	33    +		 lea ebp,[ebx+esi+0FFFh]	 ; EBP = number	of required 4KB	pages
   5345		  00000FFF
1  5346	    2C56  66| 2B E8			 sub ebp,eax
1  5347	    2C59  66| C1 ED 0C			 shr ebp,12
1  5348
1  5349	    2C5D  66| 85 C9		 @@4:	 test ecx,ecx			 ; check if no linear space left
1  5350	    2C60  0F 84	F06A			 jz int31fail8021		 ; if yes, error
1  5351	    2C64  66| 33 C0			 xor eax,eax
1  5352	    2C67  F2> 66| 67| AF		 repne scas dword ptr es:[edi]	 ; scan	for first free page
1  5353	    2C6B  66| 67| 8D 57	FC		 lea edx,[edi-4]		 ; EDX = first free page address
1  5354	    2C70  F3> 66| 67| AF		 repe scas dword ptr es:[edi]	 ; scan	for amount of free pages
1  5355	    2C74  66| 8B C7			 mov eax,edi
1  5356	    2C77  66| 2B C2			 sub eax,edx
1  5357	    2C7A  66| C1 E8 02			 shr eax,2			 ; EAX = free pages available
1  5358	    2C7E  66| 3B C5			 cmp eax,ebp			 ; check if enough free	pages
1  5359	    2C81  72 DA				 jb @@4				 ; no, must loop
1  5360
1  5361	    2C83  66| 8B C3			 mov eax,ebx			 ; EAX = physical address
1  5362	    2C86  25 F000			 and ax,0F000h
1  5363	    2C89  66| 2B D8			 sub ebx,eax
1  5364	    2C8C  66| 8B FA			 mov edi,edx			 ; EDI = address of first free page
1  5365	    2C8F  66| 8B CD			 mov ecx,ebp
1  5366	    2C92  B0 07				 mov al,07h			 ; set page as user/writeable/present
1  5367	    2C94  2E: 80 3E 0018r 03		 cmp cs:cputype,3		 ; check if CPU	is 486+
1  5368	    2C9A  76 04	90 90			 jbe @@loop			 ; if not, jump
1  5369	    2C9E  B0 1F				 mov al,1Fh			 ; set PCD and PWT bits	(no page cache)
1  5370
1  5371	    2CA0  66| 67| AB		 @@loop: stos dword ptr	es:[edi]	 ; map one 4KB page
1  5372	    2CA3  66| 05 00001000		 add eax,4096			 ; go for next page
1  5373	    2CA9  E2 F5				 loop @@loop			 ; loop	until no pages left
1  5374	    2CAB  67| 80 4A 01 02		 or byte ptr [edx+1],2		 ; mark	start of mapped	block
1  5375	    2CB0  67| 80 4F FD 04		 or byte ptr [edi-3],4		 ; mark	end of mapped block
1  5376
1  5377	    2CB5  66| 2E: 2B 16	026Cr	 @@done: sub edx,cs:phystablebase
1  5378	    2CBB  66| C1 E2 0A			 shl edx,10
1  5379	    2CBF  66| 03 D3			 add edx,ebx
1  5380
1  5381	    2CC2  67| 89 54 24 18		 mov [esp+18h],dx
1  5382	    2CC7  66| C1 EA 10			 shr edx,16
1  5383	    2CCB  81 CA	8000			 or dx,8000h
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 96
kernel.asm



1  5384	    2CCF  67| 89 54 24 10		 mov [esp+10h],dx
1  5385
1  5386	    2CD4  66| 2E: A1 0054r		 mov eax,cs:vcpi_cr3
1  5387	    2CD9  0F 22	D8			 mov cr3,eax
1  5388	    2CDC  66| 33 C0			 xor eax,eax
1  5389	    2CDF  0F 22	D0			 mov cr2,eax
1  5390	    2CE2  E9 F059			 jmp int31ok
1  5391
1  5392
1  5393					 ;=============================================================================
1  5394	    2CE5			 int310801:
1  5395	    2CE5  2E: 80 3E 001Ar 02		 cmp cs:pmodetype,2
1  5396	    2CEB  74 05	90 90			 jz int310801v
1  5397	    2CEF  E9 F04C			 jmp int31ok			 ; if under raw/XMS, do	nothing
1  5398
1  5399
1  5400	    2CF2			 int310801v:
1  5401	    2CF2  2E: 80 3E 0002r 00		 cmp cs:pm32_maxfpages,0	 ; check if any	linear memory avail.
1  5402	    2CF8  0F 84	EFBE			 jz int31fail8012		 ; if not, signal error	8012h
1  5403
1  5404	    2CFC  81 E3	7FFF			 and bx,7FFFh
1  5405	    2D00  66| C1 E3 10			 shl ebx,16
1  5406	    2D04  8B D9				 mov bx,cx
1  5407	    2D06  66| C1 EB 0A			 shr ebx,10
1  5408	    2D0A  80 E3	FC			 and bl,0FCh
1  5409
1  5410	    2D0D  66| 2E: 03 1E	026Cr		 add ebx,cs:phystablebase
1  5411	    2D13  66| 2E: 3B 1E	026Cr		 cmp ebx,cs:phystablebase	 ; check if addr is in range
1  5412	    2D19  0F 82	EFC5			 jb int31fail8025
1  5413	    2D1D  66| 2E: 3B 1E	0270r		 cmp ebx,cs:phystabletop
1  5414	    2D23  0F 83	EFBB			 jae int31fail8025
1  5415	    2D27  67| F6 43 01 02		 test byte ptr [ebx+1],2
1  5416	    2D2C  0F 84	EFB2			 jz int31fail8025
1  5417
1  5418	    2D30  66| 33 C0		 @@loop: xor eax,eax			 ; clear page table entries
1  5419	    2D33  66| 67| 87 03			 xchg eax,[ebx]
1  5420	    2D37  66| 83 C3 04			 add ebx,04h
1  5421	    2D3B  F6 C4	04			 test ah,04h
1  5422	    2D3E  74 F0				 jz @@loop
1  5423
1  5424	    2D40  66| 2E: A1 0054r	 @@1:	 mov eax,cs:vcpi_cr3
1  5425	    2D45  0F 22	D8			 mov cr3,eax
1  5426	    2D48  66| 33 C0			 xor eax,eax
1  5427	    2D4B  0F 22	D0			 mov cr2,eax
1  5428	    2D4E  E9 EFED			 jmp int31ok
1  5429
1  5430
1  5431
1  5432
1  5433
1  5434
1  5435					 ;=============================================================================
1  5436					 ; FPU RELATED FUNCTIONS
1  5437					 ;=============================================================================
1  5438
1  5439					 ;=============================================================================
1  5440	    2D51			 int310E00:
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 97
kernel.asm



1  5441	    2D51  2E: 0F B6 06 0019r		 movzx ax,cs:fputype		 ; get FPU type
1  5442	    2D57  C1 E0	04			 shl ax,4
1  5443	    2D5A  0F 01	E2			 smsw dx
1  5444	    2D5D  F6 C2	04			 test dl,00000100b		 ; check EM bit
1  5445	    2D60  74 04	90 90			 jz @@1
1  5446	    2D64  0C 02				 or al,00000010b
1  5447	    2D66  A8 F0			 @@1:	 test al,0F0h
1  5448	    2D68  74 04	90 90			 jz @@2
1  5449	    2D6C  0C 04				 or al,00000100b
1  5450	    2D6E  2E: 0A 06 001Er	 @@2:	 or al,cs:virtualfpu	 ; put virtual FPU flags in AX
1  5451	    2D73  E9 EFC3			 jmp int31okax
1  5452
1  5453
1  5454					 ;=============================================================================
1  5455	    2D76			 int310E01:
1  5456	    2D76  2E: 8E 1E 0010		 mov ds,cs:seldata
1  5457	    2D7B  80 E3	03			 and bl,00000011b
1  5458	    2D7E  88 1E	001Er			 mov virtualfpu,bl
1  5459	    2D82  0F 01	E0			 smsw ax
1  5460	    2D85  F6 C3	02			 test bl,00000010b
1  5461	    2D88  74 07	90 90			 jz @@1
1  5462	    2D8C  0C 04				 or al,00000100b
1  5463	    2D8E  EB 03	90			 jmp @@2
1  5464	    2D91  24 FB			 @@1:	 and al,11111011b
1  5465	    2D93  0F 01	F0		 @@2:	 lmsw ax
1  5466	    2D96  E9 EFA5			 jmp int31ok
1  5467
1  5468
1  5469					 ;=============================================================================
1  5470	    2D99			 int31EEFF:
1  5471	    2D99  66| 83 C4 26			 add esp,26h			 ; adjust stack
1  5472	    2D9D  1F				 pop ds				 ; restore DS
1  5473	    2D9E  66| B8 44333241		 mov eax,'D32A'
1  5474	    2DA4  0E				 push cs
1  5475	    2DA5  07				 pop es
1  5476	    2DA6  66| BB 00002DA8r		 mov ebx,offs $+2		 ; points to itself
1  5477	    2DAC  2E: 8A 2E 001Ar		 mov ch,cs:pmodetype
1  5478	    2DB1  2E: 8A 0E 0018r		 mov cl,cs:cputype
1  5479	    2DB6  2E: 8B 16 0014r		 mov dx,cs:client_version
1  5480	    2DBB  E9 EF88			 jmp int31oknopop
1  5481
1  5482
1  5483
1  5484
   5485					 If EXEC_TYPE ne 0
   5486					 include TEXT\KERNEL\test.asm
   5487					 EndIf
   5488
   5489	    2DBE  01*(87 DB)			 Align 16
   5490	    2DC0			 @kernel_end	 label byte
   5491
   5492	    2DC0			 _KERNEL      ends
   5493					 end
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 98
Symbol Table




Symbol Name		Type   Value			   Cref	(defined at #)

??DATE			Text   "12/05/21"
??FILENAME		Text   "kernel	"
??TIME			Text   "16:49:27"
??VERSION		Number 040A
@@0			Near   _KERNEL:00A2		   376	#379
@@0			Near   _KERNEL:0442		   835	#839
@@0			Near   _KERNEL:06C9		   1109	 #1111
@@0			Near   _KERNEL:0CC7		   1725	 #1727
@@0			Near   _KERNEL:0DA1		   #1808
@@0			Near   _KERNEL:0E15		   1887	 #1889
@@0			Near   _KERNEL:1087		   2211	 #2213
@@0			Near   _KERNEL:1140		   2316	 #2323
@@0			Near   _KERNEL:170F		   3120	 #3125
@@0			Near   _KERNEL:18B7		   3277	 3279  3282  #3288
@@0			Near   _KERNEL:1A18		   3433	 #3436
@@0			Near   _KERNEL:1ACA		   3513	 #3516
@@0			Near   _KERNEL:1C88		   #3756  3761
@@0			Near   _KERNEL:1DA0		   3891	 #3896
@@0			Near   _KERNEL:1E6D		   #3983  3989
@@0			Near   _KERNEL:2106		   4312	 #4316
@@0			Near   _KERNEL:2181		   4351	 #4355
@@0			Near   _KERNEL:21F1		   4385	 #4389	4401
@@0			Near   _KERNEL:2284		   4425	 #4437	4455  4477  4485  4492	4499  4506
@@0			Near   _KERNEL:2659		   4786	 #4798
@@0			Near   _KERNEL:2906		   5025	 5028  5031  #5036
@@0			Near   _KERNEL:2BE6		   #5313  5327
@@0001			Near   _KERNEL:00DD		   398	#402
@@1			Near   _KERNEL:00E2		   385	#405
@@1			Near   _KERNEL:041F		   807	810  #820
@@1			Near   _KERNEL:0487		   865	#871
@@1			Near   _KERNEL:04AD		   876	882  #884
@@1			Near   _KERNEL:05B4		   #996	 998
@@1			Near   _KERNEL:066B		   #1077  1093
@@1			Near   _KERNEL:06CF		   #1114  1131
@@1			Near   _KERNEL:0744		   #1154  1160
@@1			Near   _KERNEL:07E6		   1218	 #1221
@@1			Near   _KERNEL:085A		   1266	 #1269
@@1			Near   _KERNEL:0A9D		   1454	 1456  #1462
@@1			Near   _KERNEL:0B75		   #1536  1551
@@1			Near   _KERNEL:0C51		   #1630  1640
@@1			Near   _KERNEL:0D42		   #1769  1777
@@1			Near   _KERNEL:0DEA		   #1833  1838
@@1			Near   _KERNEL:0E59		   1901	 1905  #1912
@@1			Near   _KERNEL:0E7D		   1924	 #1926
@@1			Near   _KERNEL:1743		   3142	 #3145
@@1			Near   _KERNEL:17FE		   3221	 #3223
@@1			Near   _KERNEL:18C5		   3272	 3291  #3295
@@1			Near   _KERNEL:1A30		   3440	 #3444
@@1			Near   _KERNEL:1B21		   3535	 #3542
@@1			Near   _KERNEL:1CA0		   3757	 #3763
@@1			Near   _KERNEL:1E7C		   3985	 #3988
@@1			Near   _KERNEL:1F1A		   4057	 #4064
@@1			Near   _KERNEL:1FFF		   4184	 #4189
@@1			Near   _KERNEL:2125		   4314	 #4325
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 99
Symbol Table



@@1			Near   _KERNEL:21A3		   4353	 #4365
@@1			Near   _KERNEL:2210		   4387	 #4398
@@1			Near   _KERNEL:22A6		   4427	 #4446
@@1			Near   _KERNEL:25F7		   4763	 #4765
@@1			Near   _KERNEL:2810		   4955	 #4959
@@1			Near   _KERNEL:2862		   #4984  4991
@@1			Near   _KERNEL:290C		   #5037  5044
@@1			Near   _KERNEL:29C8		   #5104  5118
@@1			Near   _KERNEL:2A56		   5134	 5136  5139  5141  #5143
@@1			Near   _KERNEL:2A85		   #5168  5177
@@1			Near   _KERNEL:2AE0		   5188	 #5195
@@1			Near   _KERNEL:2B37		   #5223  5252
@@1			Near   _KERNEL:2BFB		   #5319  5332
@@1			Near   _KERNEL:2D40		   #5424
@@1			Near   _KERNEL:2D66		   5445	 #5447
@@1			Near   _KERNEL:2D91		   5461	 #5464
@@1BH			Near   _KERNEL:2326		   4429	 #4480
@@1BH0			Near   _KERNEL:2335		   4482	 #4484
@@1CH			Near   _KERNEL:233D		   4431	 #4487
@@1CH0			Near   _KERNEL:234C		   4489	 #4491
@@2			Near   _KERNEL:00F4		   406	#410
@@2			Near   _KERNEL:061B		   1044	 #1046
@@2			Near   _KERNEL:06E0		   1115	 #1121
@@2			Near   _KERNEL:075B		   1158	 #1163
@@2			Near   _KERNEL:0816		   1233	 #1240
@@2			Near   _KERNEL:0B2B		   1500	 #1507
@@2			Near   _KERNEL:0BA1		   1543	 1545  1547  #1549
@@2			Near   _KERNEL:0D62		   1773	 #1775
@@2			Near   _KERNEL:0E08		   1832	 #1841
@@2			Near   _KERNEL:19A1		   3381	 #3384
@@2			Near   _KERNEL:1A46		   3446	 #3453
@@2			Near   _KERNEL:1B8C		   3567	 #3571
@@2			Near   _KERNEL:1CAA		   3759	 #3767
@@2			Near   _KERNEL:1E86		   #3993  3996
@@2			Near   _KERNEL:2231		   4399	 #4407
@@2			Near   _KERNEL:22E5		   4447	 #4463
@@2			Near   _KERNEL:2877		   4986	 #4989
@@2			Near   _KERNEL:2921		   5039	 #5042
@@2			Near   _KERNEL:2AA0		   5170	 5173  #5175
@@2			Near   _KERNEL:2B51		   #5232  5245
@@2			Near   _KERNEL:2C1A		   5325	 #5329
@@2			Near   _KERNEL:2D6E		   5448	 #5450
@@2			Near   _KERNEL:2D93		   5463	 #5465
@@23H			Near   _KERNEL:2354		   4433	 #4494
@@23H0			Near   _KERNEL:2363		   4496	 #4498
@@24H			Near   _KERNEL:236B		   4435	 #4501
@@24H0			Near   _KERNEL:237A		   4503	 #4505
@@3			Near   _KERNEL:00FA		   409	#413
@@3			Near   _KERNEL:0701		   1124	 #1133
@@3			Near   _KERNEL:0779		   1167	 #1174
@@3			Near   _KERNEL:1E95		   3994	 #3999
@@3			Near   _KERNEL:293C		   5041	 #5049
@@3			Near   _KERNEL:2B7A		   5230	 5236  #5243
@@3			Near   _KERNEL:2C34		   5320	 #5338
@@4			Near   _KERNEL:0112		   #422	 592
@@4			Near   _KERNEL:071C		   1135	 1137  #1140
@@4			Near   _KERNEL:078E		   #1182  1194
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 100
Symbol Table



@@4			Near   _KERNEL:0C24		   1604	 #1606
@@4			Near   _KERNEL:2B90		   5225	 5241  #5250
@@4			Near   _KERNEL:2C5D		   #5349  5359
@@5			Near   _KERNEL:079F		   1183	 #1189
@@D0			Near   _KERNEL:0183		   463	#478  489  493
@@DETECT_DPMI		Near   _KERNEL:015A		   408	410  #457
@@DETECT_VCPI		Near   _KERNEL:0185		   407	411  #482
@@DONE			Near   _KERNEL:0144		   #441	 477
@@DONE			Near   _KERNEL:0386		   658	667  688  692  #694
@@DONE			Near   _KERNEL:0522		   893	896  910  912  #921
@@DONE			Near   _KERNEL:0699		   1076	 #1094
@@DONE			Near   _KERNEL:073A		   1112	 1141  #1147
@@DONE			Near   _KERNEL:07B4		   1155	 1161  1172  #1196
@@DONE			Near   _KERNEL:0827		   1223	 1227  1238  #1244
@@DONE			Near   _KERNEL:0B68		   1505	 #1521
@@DONE			Near   _KERNEL:0C16		   1573	 1594  #1598
@@DONE			Near   _KERNEL:0C85		   1622	 #1648
@@DONE			Near   _KERNEL:0D1E		   #1752
@@DONE			Near   _KERNEL:0D76		   1764	 1768  #1782
@@DONE			Near   _KERNEL:0FFD		   2047	 2055  2067  #2085
@@DONE			Near   _KERNEL:1DCF		   3908	 3911  #3913
@@DONE			Near   _KERNEL:214B		   4310	 4323  4329  #4334
@@DONE			Near   _KERNEL:21D9		   4348	 4363  4371  #4378
@@DONE			Near   _KERNEL:223D		   4396	 4406  #4410
@@DONE			Near   _KERNEL:2323		   4444	 4461  #4478
@@DONE			Near   _KERNEL:2A11		   5101	 #5120
@@DONE			Near   _KERNEL:2B9B		   5220	 5248  #5254
@@DONE			Near   _KERNEL:2CB5		   5336	 #5377
@@ENT1			Near   _KERNEL:26BC		   4785	 #4826
@@ENT2			Near   _KERNEL:26B5		   4793	 #4823
@@ERR			Near   _KERNEL:043D		   #836	 847  853  860
@@ERR			Near   _KERNEL:2689		   4788	 4792  #4811
@@ERR			Near   _KERNEL:2A12		   5105	 5108  5110  5115  5117	 #5122
@@EXIT			Near   _KERNEL:0154		   #448	 451
@@EXIT			Near   _KERNEL:039A		   696	#701
@@EXIT			Word   _KERNEL:0D21		   1750	 #1754
@@F0			Near   _KERNEL:0960		   1343	 #1357
@@F0			Near   _KERNEL:0FD4		   2057	 2061  #2065
@@F0			Near   _KERNEL:1E16		   3932	 #3945
@@F0			Near   _KERNEL:1E59		   3968	 #3972
@@F0			Near   _KERNEL:24AE		   4630	 #4634
@@F0			Near   _KERNEL:2552		   4687	 #4693
@@F1			Near   _KERNEL:09C8		   1395	 #1399
@@F1			Near   _KERNEL:1E18		   3934	 #3946
@@F1			Near   _KERNEL:24B5		   4623	 #4638
@@F2			Near   _KERNEL:24EF		   4655	 #4658
@@F3			Near   _KERNEL:2406		   4569	 #4579
@@F4			Near   _KERNEL:2466		   4607	 #4612
@@FAIL			Near   _KERNEL:0157		   370	377  416  #450	467  471  500  502  504	 506  508
@@INIT			Word   _KERNEL:042A		   822	#824
@@L0			Near   _KERNEL:0FD7		   #2066  2081
@@L0			Near   _KERNEL:1002		   #2144  2149
@@L0			Near   _KERNEL:1DE9		   #3931  3948
@@L0			Near   _KERNEL:1E4D		   #3967  3973
@@L0			Near   _KERNEL:1FC8		   #4154  4162
@@L0			Near   _KERNEL:253E		   #4686  4690
@@L1			Near   _KERNEL:0BED		   #1581  1584
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 101
Symbol Table



@@L1			Near   _KERNEL:0FEA		   #2074  2080
@@L1			Near   _KERNEL:1DFB		   #3937  3942
@@L2			Near   _KERNEL:02BC		   611	#613
@@L3			Near   _KERNEL:02DD		   623	#625
@@L3			Near   _KERNEL:0C33		   #1612  1615
@@L4			Near   _KERNEL:0304		   638	#640
@@LOOP			Near   _KERNEL:0393		   #698	 699
@@LOOP			Near   _KERNEL:2CA0		   5368	 #5371	5373
@@LOOP			Near   _KERNEL:2D30		   #5418  5422
@@N			Byte   _KERNEL:1712		   3101	 #3127
@@OK			Near   _KERNEL:0CBA		   1671	 #1675
@@STR1			Byte   _KERNEL:2696		   4781	 #4816
@@STR2			Byte   _KERNEL:26A5		   4790	 #4819
@@SWPM			Near   _KERNEL:09E9		   1409	 #1414
@@V0			Near   _KERNEL:02A4		   #593
@@V1			Near   _KERNEL:01E5		   512	519  #522
@@V1A			Near   _KERNEL:022B		   527	532  #552
@@V1B			Near   _KERNEL:022E		   550	#553
@@V1C			Near   _KERNEL:024E		   560	#562
@@V2			Near   _KERNEL:025D		   563	#568
@@V3			Near   _KERNEL:026A		   570	#573
@@V4			Near   _KERNEL:0286		   580	#582
@@V5			Near   _KERNEL:0288		   574	#583
@@V6			Near   _KERNEL:0290		   584	#586
@@VA			Near   _KERNEL:01E2		   515	#520
@@X1			Near   _KERNEL:0319		   612	624  #647
@@X2			Near   _KERNEL:0311		   639	#644
@AREA1_DB		Byte   _KERNEL:007C		   159	160  193  194  203  #353  796  797
@AREA1_DD		Dword  _KERNEL:007C		   150	151  152  164  165  166	 173  177  178	179  180  181  182  183	  +
							   184	185  186  187  188  189	 190  191  195	196  197  198  199  204	  +
							   205	206  207  208  209  210	 211  212  213	214  215  220  222  #355
@AREA1_DW		Word   _KERNEL:007C		   153	154  161  162  163  171	 172  174  175	192  216  217  218  219	  +
							   221	223  224  #354
@AREA1_END		Byte   _KERNEL:039C		   #704	 797
@CALLBACK_DATA		Byte   _KERNEL:0540		   #949	 1468  1472  1476  1480	 3426  3459
@CPU			Text   0F8FH			   #48	#49
@CURSEG			Text   _KERNEL			   #119
@FILENAME		Text   KERNEL
@IRQ			Near   _KERNEL:198A		   3253	 3369  #3375
@KERNEL_BEG		Byte   _KERNEL:0540		   115	445  446  #948
@KERNEL_END		Byte   _KERNEL:2DC0		   116	445  #5490
@WORDSIZE		Text   2			   #48	#49  #119
A20_STATE		Byte   _KERNEL:001F		   #237	 1206  1792  2046
ALLOCATE_CALLBACKS	Near   _KERNEL:0C3E		   1325	 #1620
API_FUNC00		Near   _KERNEL:26FB		   4827	 #4852
API_FUNC01		Near   _KERNEL:271B		   4829	 #4862
API_FUNC02		Near   _KERNEL:273C		   4831	 #4873
API_FUNC03		Near   _KERNEL:274E		   4833	 #4879
API_FUNC04		Near   _KERNEL:2766		   4835	 #4886
API_FUNC05		Near   _KERNEL:2788		   4837	 #4898
API_FUNC06		Near   _KERNEL:27A6		   4839	 #4906
API_FUNC07		Near   _KERNEL:27BE		   4841	 #4915
API_FUNC08		Near   _KERNEL:27CB		   4843	 #4920
API_FUNC09		Near   _KERNEL:27DD		   4845	 #4928
API_FUNCOK		Near   _KERNEL:27E6		   4860	 4871  4877  4884  4896	 4904  4913  4918  4926	 #4932
BACK_MATRIX		Near   _KERNEL:1610		   #3001  3407	4467
BPTR			Text   byte ptr			   #108
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 102
Symbol Table



CALLBACK		Near   _KERNEL:1A6B		   1637	 #3482
CALLBACKBASE		Number _KERNEL:02C4		   #222	 1320  4683  4720
CALLBACKSEG		Number _KERNEL:02C8		   #223	 1322  4705
CHECKINT		Near   _KERNEL:1DA2		   #3899  4313	4352  4386  4426
CLIENT_CALL		Word   _KERNEL:0010		   #227	 783  868  2195	 2214  3298  3307  4824	 4912  4916  4917  4923	  +
							   4924	 5127
CLIENT_VERSION		Word   _KERNEL:0014		   #228	 782  809  1944	 4803  5479
CODEBASE		Dword  _KERNEL:0020		   #240	 786  1415
CPUTYPE			Byte   _KERNEL:0018		   #230	 373  442  690	4765  4806  5367  5478
CPU_DETECT		Near   _KERNEL:02A6		   372	#600
CR			Text   0Dh, 0Ah			   #105
CRE			Text   0Dh, 0Ah	,0		   #106
CRITICAL_ERROR_PM	Near   _KERNEL:1054		   #2197  3419	3498
CRITICAL_ERROR_RM	Near   _KERNEL:1035		   #2186  3104	3243  3359
DPMIEPMODE		Dword  _KERNEL:0024		   #241	 473  474  933
DPTR			Text   dword ptr		   #110	 1772  3426  3459  4330	 4366  4374  4402  4457	 4472
DVXR_INIT		Near   _KERNEL:0432		   #831	 935  1522
D_EXIT			Near   _KERNEL:0DDE		   1757	 1807  #1827
D_INIT			Near   _KERNEL:0523		   827	#931
ENABLEA20KBWAIT		Near   _KERNEL:1000		   2056	 2060  2064  #2142
ENABLEA20TEST		Near   _KERNEL:100F		   2044	 2054  2066  #2152
ENABLE_A20		Near   _KERNEL:0F99		   1251	 #2041
EXCSET_PM		Number _KERNEL:00D0		   #163	 3295  4325  4365  4373
EXCTAB_PM		Number _KERNEL:0192		   #166	 3319  3321  3323  4330	 4332  4366  4368  4374	 4376
EXC_HANDLER		Near   _KERNEL:18D9		   3045	 3047  3049  3051  3053	 3055  3057  3059  3061	 3063  3065  3067 +
							   3069	 3071  3073  3075  #3302
EXC_MATRIX		Near   _KERNEL:1650		   #3039  3304	4326
EXC_USER		Near   _KERNEL:18EA		   3296	 #3314
EXEC_TYPE		Text   0			   363	5485
FPUTYPE			Byte   _KERNEL:0019		   #231	 380  1424  4807  5441
FPU_DETECT		Near   _KERNEL:031D		   379	#651
GDTBASE			Dword  _KERNEL:0032		   #248	 1331  3874  3925  4096	 4858
GDTLIMIT		Word   _KERNEL:0030		   #247	 270  1335  2338  3872	3926  4854
GDTSEG			Word   _KERNEL:002E		   #246	 1329  3507
ID32_MEM_FREE		Number _KERNEL:024C		   #189	 811  898
ID32_MEM_PTR		Number _KERNEL:0250		   #190	 812  899
ID32_MEM_VCPI		Number _KERNEL:0254		   #191	 813  914
ID32_PROCESS_ID		Number _KERNEL:0258		   #192	 816  887  895	1455  1510  1763  1772	1948  5184
ID32_SPAWNED_ID		Number _KERNEL:025C		   #193	 1904  1931  1935
ID32_TSRMODE_ID		Number _KERNEL:025E		   #194	 1900  1956
IDTBASE			Dword  _KERNEL:003A		   #251	 1295  4318  4357  4391	 4439  4859
IDTLIMIT		Word   _KERNEL:0038		   #250	 271  2337  4856
IDTSEG			Word   _KERNEL:0036		   #249	 1292
INIT_DONE		Near   _KERNEL:0489		   #874	 939  941  1212	 1253
INIT_DONE_ID32		Near   _KERNEL:04B9		   883	#891
INSTALL_INTS		Near   _KERNEL:0B6C		   1288	 #1531
INT15H			Near   _KERNEL:0E09		   1459	 #1886
INT1BH			Near   _KERNEL:0EFA		   1467	 #1981
INT1CH			Near   _KERNEL:0F04		   1471	 #1987
INT21			Near   _KERNEL:0CBD		   1553	 #1724	1927
INT21H			Near   _KERNEL:0E29		   1447	 #1900
INT21H_CALL		Near   _KERNEL:0E9C		   1903	 #1942
INT21H_EXIT		Near   _KERNEL:0E5E		   1907	 #1916
INT21H_SPAWN		Near   _KERNEL:0E82		   1909	 #1930
INT21H_TSR		Near   _KERNEL:0ECB		   1911	 #1955
INT23H			Near   _KERNEL:0F2E		   1475	 #2003
INT24H			Near   _KERNEL:0F50		   1479	 #2017
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 103
Symbol Table



INT31			Near   _KERNEL:1C76		   1554	 #3747
INT310000		Near   _KERNEL:1DD2		   3635	 #3921
INT310001		Near   _KERNEL:1E23		   3637	 #3953	4211
INT310002		Near   _KERNEL:1E62		   3639	 #3978
INT310003		Near   _KERNEL:1ED2		   3641	 #4030
INT310006		Near   _KERNEL:1ED8		   3643	 #4036
INT310007		Near   _KERNEL:1EED		   3645	 #4045
INT310008		Near   _KERNEL:1F02		   3647	 #4054
INT310009		Near   _KERNEL:1F2C		   3649	 #4071
INT31000A		Near   _KERNEL:1F4B		   3651	 #4084
INT31000B		Near   _KERNEL:1F7B		   3653	 #4109
INT31000C		Near   _KERNEL:1F91		   3655	 #4119
INT31000E		Near   _KERNEL:1FB5		   3657	 #4139
INT31000EF		Near   _KERNEL:1FBE		   4141	 #4148
INT31000F		Near   _KERNEL:1FBB		   3659	 #4145
INT310100		Near   _KERNEL:1FE1		   3662	 #4175
INT310101		Near   _KERNEL:2022		   3664	 #4205
INT310102		Near   _KERNEL:2032		   3666	 #4215
INT31010X		Near   _KERNEL:203F		   4201	 #4222
INT31010X_F1		Near   _KERNEL:2059		   4208	 4218  #4234
INT31010X_F2		Near   _KERNEL:206E		   4177	 4186  #4245
INT310200		Near   _KERNEL:20A4		   3669	 #4278
INT310201		Near   _KERNEL:20BB		   3671	 #4288
INT310202		Near   _KERNEL:20DE		   3673	 #4302
INT310203		Near   _KERNEL:2153		   3675	 #4339
INT310204		Near   _KERNEL:21DC		   3677	 #4382
INT310205		Near   _KERNEL:2245		   3679	 #4415
INT3103			Near   _KERNEL:23CE		   4552	 #4561
INT310300		Near   _KERNEL:23C1		   3628	 #4556
INT310301		Near   _KERNEL:23B8		   3630	 #4549
INT310302		Near   _KERNEL:23B8		   3632	 #4550
INT310303		Near   _KERNEL:252A		   3682	 #4678
INT310304		Near   _KERNEL:2573		   3684	 #4704
INT310305		Near   _KERNEL:25AC		   3686	 #4734
INT310306		Near   _KERNEL:25C6		   3688	 #4746
INT310400		Near   _KERNEL:25E0		   3691	 #4757
INT310500		Near   _KERNEL:27E9		   3694	 #4947
INT310501		Near   _KERNEL:2853		   3696	 #4979
INT310502		Near   _KERNEL:2888		   3698	 #4996
INT310503		Near   _KERNEL:28A4		   3700	 #5009
INT31050A		Near   _KERNEL:296B		   3702	 #5066
INT310600		Near   _KERNEL:2B9E		   3705	 #5267
INT310601		Near   _KERNEL:2B9E		   3707	 #5268
INT310602		Near   _KERNEL:2B9E		   3709	 #5269
INT310603		Near   _KERNEL:2B9E		   3711	 #5270
INT310604		Near   _KERNEL:2BA1		   3713	 #5277
INT310702		Near   _KERNEL:2B9E		   3716	 #5271
INT310703		Near   _KERNEL:2B9E		   3718	 #5272
INT310800		Near   _KERNEL:2BA9		   3721	 #5292
INT310800V		Near   _KERNEL:2BD4		   5302	 #5306
INT310801		Near   _KERNEL:2CE5		   3723	 #5394
INT310801V		Near   _KERNEL:2CF2		   5396	 #5400
INT310900		Near   _KERNEL:2382		   3726	 #4511
INT310901		Near   _KERNEL:2394		   3728	 #4521
INT310902		Near   _KERNEL:23A6		   3730	 #4531
INT310A00		Near   _KERNEL:2604		   3733	 #4771
INT310E00		Near   _KERNEL:2D51		   3736	 #5440
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 104
Symbol Table



INT310E01		Near   _KERNEL:2D76		   3738	 #5455
INT31EEFF		Near   _KERNEL:2D99		   3741	 #5470
INT31FAIL		Near   _KERNEL:1D00		   3809	 #3824
INT31FAIL8001		Near   _KERNEL:1CAB		   #3770
INT31FAIL8010		Near   _KERNEL:1CB0		   #3773  3997
INT31FAIL8011		Near   _KERNEL:1CB5		   #3776  3949	4090  4187
INT31FAIL8012		Near   _KERNEL:1CBA		   #3779  4575	5308  5402
INT31FAIL8013		Near   _KERNEL:1CBF		   #3782  4992	5047  5094
INT31FAIL8015		Near   _KERNEL:1CC4		   #3785  4681	4691
INT31FAIL8016		Near   _KERNEL:1CC9		   #3788
INT31FAIL8021		Near   _KERNEL:1CCE		   #3791  3884	3886  3887  3889  3893	3895  3923  4305  4346	5155  5159+
							   5298	 5300  5350
INT31FAIL8022		Near   _KERNEL:1CD3		   #3794  3873	3877  3956  3959
INT31FAIL8023		Near   _KERNEL:1CD8		   #3797  5019	5074  5143
INT31FAIL8024		Near   _KERNEL:1CDD		   #3800  4706	4714  4716  4718
INT31FAIL8025		Near   _KERNEL:1CE2		   #3803  5412	5414  5416
INT31FAILAX		Near   _KERNEL:1CFB		   3816	 #3819	4005  4209  4241  4263
INT31FAILBX		Near   _KERNEL:1CEE		   #3814  4178	4219
INT31FAILCX		Near   _KERNEL:1CF6		   #3817  4157
INT31FAILNOPOP		Near   _KERNEL:1D08		   #3827  4814
INT31FAILX		Near   _KERNEL:1CE4		   3772	 3775  3778  3781  3784	 3787  3790  3793  3796	 3799  3802  #3806
INT31OK			Near   _KERNEL:1D3E		   #3853  3974	4050  4067  4080  4115	4135  4150  4163  4230	4298  4378+
							   4478	 4671  4674  4722  4975	 5005  5273  5303  5390	 5397  5428  5466
INT31OKAX		Near   _KERNEL:1D39		   #3848  3943	3987  4025  4032  4105	5451
INT31OKBX		Near   _KERNEL:1D2F		   #3844  5280
INT31OKCX		Near   _KERNEL:1D34		   3835	 3838  #3846
INT31OKDX		Near   _KERNEL:1D19		   #3836  4041	4284  4700
INT31OKEDX		Near   _KERNEL:1D10		   #3833  4335	4411
INT31OKNOPOP		Near   _KERNEL:1D46		   #3856  4517	4527  4537  4742  4753	4767  4796  4809  5480
INT31OKSI		Near   _KERNEL:1D26		   #3841
INT31OKSINOAX		Near   _KERNEL:1D21		   #3839  5081	5207
INT31TAB		Word   _KERNEL:1BA6		   #3626  3756	3758  3763
INT31TESTACCESS		Near   _KERNEL:1D71		   #3881  4073	4123
INT31TESTSEL		Near   _KERNEL:1D4E		   #3870  3960	4037  4046  4055  4072	4085  4110  4120  4341	4417
INT31_ALLOCBLOCK	Near   _KERNEL:2AAF		   4988	 5021  5034  5062  #5182
INT31_CHECKBLOCKS	Near   _KERNEL:29B4		   4956	 4982  5000  5014  5070	 #5099
INT31_CHECKHANDLE	Near   _KERNEL:2A28		   5001	 5015  5071  #5131
INT31_CHECKIFMEMAVAIL	Near   _KERNEL:299E		   4980	 4999  5012  5069  #5088
INT31_GETFREEMEM	Near   _KERNEL:2A79		   4957	 #5164
INT31_LINKFREEBLOCKS	Near   _KERNEL:2B0F		   1780	 5004  5059  5200  #5211
INT31_TESTBXCXTOEBX	Near   _KERNEL:2A59		   4981	 5013  #5150
INTOLD_RESTORE		Near   _KERNEL:0EF0		   #1973  1984	2000  2014  2034
INTOLD_SAVE		Near   _KERNEL:0ED7		   #1964  1981	1987  2003  2017
INT_MAIN		Near   _KERNEL:1690		   2451	 2453  2455  2457  2459	 2461  2463  2465  2467	 2469  2471  2473 +
							   2475	 2477  2479  2481  2483	 2485  2487  2489  2491	 2493  2495  2497 +
							   2499	 2501  2503  2505  2507	 2509  2511  2513  2515	 2517  2519  2521 +
							   2523	 2525  2527  2529  2531	 2533  2535  2537  2539	 2541  2543  2545 +
							   2547	 2549  2551  2553  2555	 2557  2559  2561  2563	 2565  2567  2569 +
							   2571	 2573  2575  2577  2579	 2581  2583  2585  2587	 2589  2591  2593 +
							   2595	 2597  2599  2601  2603	 2605  2607  2609  2611	 2613  2615  2617 +
							   2619	 2621  2623  2625  2627	 2629  2631  2633  2635	 2637  2639  2641 +
							   2643	 2645  2647  2649  2651	 2653  2655  2657  2659	 2661  2663  2665 +
							   2667	 2669  2671  2673  2675	 2677  2679  2681  2683	 2685  2687  2689 +
							   2691	 2693  2695  2697  2699	 2701  2703  2705  2707	 2709  2711  2713 +
							   2715	 2717  2719  2721  2723	 2725  2727  2729  2731	 2733  2735  2737 +
							   2739	 2741  2743  2745  2747	 2749  2751  2753  2755	 2757  2759  2761 +
							   2763	 2765  2767  2769  2771	 2773  2775  2777  2779	 2781  2783  2785 +
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 105
Symbol Table



							   2787	 2789
INT_MATRIX		Near   _KERNEL:11D0		   1536	 1578  1579  1595  1596	 1607  1609  1726  1752	 #2445	3090  3199+
							   3212	 3269
IRQCALLBACKPTR		Number _KERNEL:02CC		   #224	 3425  3427  3457  3458
IRQSET_PM		Number _KERNEL:00CE		   #162	 3223  4398  4449  4464
IRQSET_RM		Number _KERNEL:00CC		   #161	 4448  4463  4875
IRQTAB_PM		Number _KERNEL:0112		   #165	 3178  3180  3182  3442	 4402  4404  4457  4459	 4472  4474
IRQTAB_RM		Number _KERNEL:00D2		   #164	 1561  3362  4450  4876
IRQ_CALLBACK		Near   _KERNEL:19B7		   3007	 3009  3011  3013  3015	 3017  3019  3021  3023	 3025  3027  3029 +
							   3031	 3033  3035  3037  #3404
IRQ_DOWN		Near   _KERNEL:1807		   3201	 #3229
IRQ_FAIL		Near   _KERNEL:1871		   1577	 3210  #3267
IRQ_NORMAL		Near   _KERNEL:17CC		   1595	 1605  #3196
IRQ_SOFT		Near   _KERNEL:17EB		   #3215  3293
IRQ_STANDARD		Near   _KERNEL:1918		   2969	 2971  2973  2975  2977	 2979  2981  2983  2985	 2987  2989  2991 +
							   2993	 2995  2997  2999  #3341
IRQ_TESTER		Near   _KERNEL:17D7		   1603	 #3204
IRQ_USER		Near   _KERNEL:179B		   #3173  3224
KERNEL_CODE		Word   _KERNEL:0016		   #229	 781  1445  1457  1625	2199  2270  3411  4738	4751  4910
LAST_INT		Number _KERNEL:00CA		   #159	 3107  3297  3306
MEM_DEALLOC		Near   _KERNEL:0D29		   1747	 #1762
MEM_FREE		Number _KERNEL:0080		   #151	 877  902  1142	 1243  1273  1492  1503	 1518  1766  1946  4881	  +
							   4954	 4961  5092  5125
MEM_PTR			Number _KERNEL:007C		   #150	 878  903  1146	 1240  1241  1272  1491	 1501  1516  1765  1947	  +
							   4882	 4953  4983  5036  5091	 5103  5114  5124  5133	 5167  5213
MEM_TOP			Number _KERNEL:0084		   #152	 906  1514  1776  4883	4990  5024  5043  5116	5135  5176  5214
MEM_USED		Number _KERNEL:0088		   #153	 1275  1891
NEWINT1BH		Number _KERNEL:023C		   #185	 1487  4481
NEWINT1CH		Number _KERNEL:0240		   #186	 1486  1996  4488
NEWINT23H		Number _KERNEL:0244		   #187	 1485  4495
NEWINT24H		Number _KERNEL:0248		   #188	 1484  4502
OFFS			Alias  OFFSET			   #107	 254  254  255	255  270  270  271  271	 274  274  280	280  445  +
							   445	446  796  797  797  1066  1067	1279  1280  1409  1447	1459  1467+
							   1468	 1471  1472  1475  1476	 1479  1480  1536  1553	 1554  1561  1577 +
							   1578	 1579  1595  1595  1603	 1605  1607  1609  1637	 1924  2211  2316 +
							   3090	 3120  3142  3199  3212	 3253  3269  3304  3344	 3369  3381  3407 +
							   3433	 3440  3440  3446  3513	 3535  3535  3567  3982	 3992  4623  4630 +
							   4655	 4739  4741  4781  4785	 4790  4793  4875  4876	 4930  5476
OLDCR0			Number _KERNEL:021C		   #177	 1421  1732
OLDINT15H		Number _KERNEL:0220		   #178	 1451  1786  1888  1890
OLDINT1BH		Number _KERNEL:0224		   #179	 1428  1735  4483
OLDINT1CH		Number _KERNEL:0228		   #180	 1431  1737  1990  2190	 2202  4490
OLDINT21H		Number _KERNEL:022C		   #181	 1434  1739  1912  1934	 1958
OLDINT23H		Number _KERNEL:0230		   #182	 1437  1741  4497
OLDINT24H		Number _KERNEL:0234		   #183	 1440  1743  4504
OLDINT2FH		Number _KERNEL:0238		   #184	 1443  1745
PAGETABLEBASE		Number _KERNEL:0260		   #195	 961  1047  1144  4868
PAGETABLEFREE		Number _KERNEL:0268		   #197	 915  1048  1143  1831	1951
PAGETABLES		Byte   _KERNEL:001B		   #233	 586  963  1026	 1100  1950  4864
PAGETABLETOP		Number _KERNEL:0264		   #196	 966
PHYSTABLEBASE		Number _KERNEL:026C		   #198	 967  4869  5312  5338	5377  5410  5411
PHYSTABLETOP		Number _KERNEL:0270		   #199	 971  5319  5339  5413
PICMASTER		Byte   _KERNEL:001D		   #235	 496  1588  1593  3219	3906
PICSLAVE		Byte   _KERNEL:001C		   #234	 497  1278  1534  1590	3909  4766  4808
PM32_CALLBACKS		Byte   _KERNEL:0003		   #134	 430  1621  4679  4717
PM32_DATA		Byte   _KERNEL:0000		   114	#122
PM32_INFO		Near   _KERNEL:007C		   112	#357
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 106
Symbol Table



PM32_INIT		Near   _KERNEL:039C		   113	#773
PM32_MAXEXTMEM		Dword  _KERNEL:000C		   #140	 790  817  1107	 1215  1265  1267
PM32_MAXFPAGES		Byte   _KERNEL:0002		   #133	 587  968  1037	 4866  5307  5401
PM32_MAXPAGES		Byte   _KERNEL:0001		   #132	 568
PM32_MODE		Byte   _KERNEL:0000		   #123	 405  514  526	1043  1136  1572  3271	4311  4350  4384  4424	  +
							   4787	 4804  5100
PM32_PMSTACKLEN		Word   _KERNEL:000A		   #139	 427  1312
PM32_PMSTACKS		Byte   _KERNEL:0007		   #137	 426  1311
PM32_RMSTACKLEN		Word   _KERNEL:0008		   #138	 423  1301
PM32_RMSTACKS		Byte   _KERNEL:0006		   #136	 422  1300
PM32_SELECTORS		Word   _KERNEL:0004		   #135	 436  1332
PMODETYPE		Byte   _KERNEL:001A		   #232	 443  820  864	892  908  1342	1453  1748  4762  4805	5301  5395+
							   5477
PMSTACKBASE		Number _KERNEL:02A0		   #213	 1309  3418  3497  4902
PMSTACKLEN		Number _KERNEL:029C		   #212	 1314  3417  3453  3495	 3572  4900
PMSTACKTOP		Number _KERNEL:02A4		   #214	 1317  1922  2205  3415	 3420  3454  3493  3496	 3573  4901
PMSTACKTOP2		Number _KERNEL:02A8		   #215	 1318  2204  4903
PMTORMSWROUT		Dword  _KERNEL:0046		   #255	 1067  1280  3123  3257	 3373  3451  3569  4632	 4750
RMIDTBASE		Dword  _KERNEL:0040		   #253
RMIDTLIMIT		Word   _KERNEL:003E		   #252	 2377
RMSTACKBASE		Number _KERNEL:02AE		   #217	 1298  3103  3242  3358	 4574  4892
RMSTACKESP		Number _KERNEL:02BC		   #220	 4587  4651  4660
RMSTACKLEN		Number _KERNEL:02AC		   #216	 1302  3098  3145  3237	 3353  3384  4572  4672	 4888
RMSTACKSS		Number _KERNEL:02C0		   #221	 4584  4650  4661
RMSTACKTOP		Number _KERNEL:02B0		   #218	 1305  2193  3097  3105	 3146  3235  3244  3351	 3360  3385  4571 +
							   4576	 4673  4890
RMSTACKTOP2		Number _KERNEL:02B2		   #219	 1306  2192  4894
RMTOPMSWROUT		Word   _KERNEL:0044		   #254	 1066  1279  1410  1925	 2212  3143  3382  3434	 3514  4656  4752
R_EXIT			Near   _KERNEL:0D77		   1754	 #1786
R_INIT			Near   _KERNEL:082A		   824	#1251
SEGMENTBASES		Number _KERNEL:008A		   #154	 3982  3992
SELBIOSDATA		Number 0040			   #60	1373
SELCALLBACK		Number 0048			   #61	245  1359  1362	 3509  3529
SELCODE			Number 0008			   #53	275  1365  1408	 1536  1923  2210  2343	 3141  3380  3429  3439	  +
							   3512	 4328  4370  4409  4446	 4480  4487  4494  4501	 4654  4907
SELDATA			Number 0010			   #54	244  867  894  1369  1465  1483	 1730  1919  2188  2207	 2366	  +
							   2370	 3095  3140  3232  3348	 3376  3979  4303  4344	 4383  4420  4562 +
							   4653	 4874  4908  4922  4929	 5122  5456
SELVCPICOD2		Number 0030			   #58
SELVCPICOD3		Number 0038			   #59
SELVCPICODE		Number 0028			   #57	278  1351
SELVCPITSS		Number 0020			   #56	273  1346  1347	 1348
SELZERO			Number 0018			   #55	243  916  917  1358  1361  1406	 1731  1921  1989  1995	 2189	  +
							   2209	 2300  2319  3108  3109	 3139  3246  3364  3430	 3510  3546  3754 +
							   4319	 4358  4392  4421  4652	 4853  4863  4880  4887	 4899  4909
SETUP_IRQS		Near   _KERNEL:0C17		   1589	 1591  #1601
STD_MATRIX		Near   _KERNEL:15D0		   #2963  3344	4407
SYSSELECTORS		Number 000A			   #63	437  1333  1376	 3947
TEMPD1			Number _KERNEL:0218		   #173	 2289
TEMPW0			Number _KERNEL:0214		   #171	 2271  2286  2367  2384
TEMPW1			Number _KERNEL:0216		   #172	 2272  2280  2368  2389
TEMPW2			Number _KERNEL:0218		   #174	 2273
TEMPW3			Number _KERNEL:021A		   #175
TEMP_INT		Number _KERNEL:00CB		   #160	 3414  3436
VCPISTRUCADDX		Dword  _KERNEL:0072		   #280	 789  2274
VCPISWITCHSTACK		Dword  _KERNEL:0076		   #281	 1350  2302
VCPI_ALLOCMEM		Word   _KERNEL:0070		   #279	 1133  1830
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 107
Symbol Table



VCPI_ALLOC_EMS		Near   _KERNEL:069B		   1051	 #1097
VCPI_ALLOC_XMS		Near   _KERNEL:073B		   1138	 #1149
VCPI_CALLCS		Word   _KERNEL:006E		   #278
VCPI_CALLEIP		Dword  _KERNEL:006A		   #277	 995  1837  2322
VCPI_CR3		Dword  _KERNEL:0054		   #269	 280  1005  1059  1416	1839  5386  5424
VCPI_CS			Word   _KERNEL:0068		   #275
VCPI_DEALLOC		Near   _KERNEL:0DDF		   1799	 #1829
VCPI_EIP		Dword  _KERNEL:0064		   #274
VCPI_GDTADDX		Dword  _KERNEL:0058		   #270	 787
VCPI_IDTADDX		Dword  _KERNEL:005C		   #271	 788
VCPI_SELLDT		Word   _KERNEL:0060		   #272
VCPI_SELTSS		Word   _KERNEL:0062		   #273
VCPI_SETUP_PAGETABLES	Near   _KERNEL:0661		   1028	 1039  #1072
VIRTUALFPU		Byte   _KERNEL:001E		   #236	 1425  5450  5458
VXR_INIT		Near   _KERNEL:088E		   1069	 #1287
VXR_INITSETDSC		Near   _KERNEL:0C86		   1368	 1371  1374  1380  1383	 1397  1400  #1652
VXR_SAVERESTOREPM	Near   _KERNEL:11CB		   #2397  4741
VXR_SAVERESTORERM	Near   _KERNEL:11CC		   #2399  4739
V_EXIT			Near   _KERNEL:0D94		   1756	 #1799
V_INIT			Near   _KERNEL:0540		   826	#952
V_PMTORMSW		Near   _KERNEL:10D4		   255	1067  #2296
V_RMTOPMSW		Near   _KERNEL:1090		   254	1066  #2267
V_RMTOPMSWPM		Near   _KERNEL:10AC		   274	#2277
WPTR			Text   word ptr			   #109	 4332  4368  4376  4404	 4459  4474
XMS_ALLOCMEM		Near   _KERNEL:0CA0		   516	1156  1225  #1665
XMS_CALL		Word   _KERNEL:004A		   #261	 390  391  396	400  567  1165	1171  1205  1208  1231	1237  1669+
							   1674	 1819
XMS_CALL_PM		Near   _KERNEL:0DA8		   1796	 1809  #1811
XMS_DATA		Dword  _KERNEL:004E		   #262	 402  418  510	1214
XMS_DEALLOC		Near   _KERNEL:0D97		   1791	 #1804
XMS_HANDLE		Word   _KERNEL:0052		   #263	 1163  1169  1228  1235	 1805
XR_INIT			Near   _KERNEL:0879		   1244	 1259  #1277
XR_PMTORMSW		Near   _KERNEL:1180		   1280	 #2362
XR_RMTOPMSW		Near   _KERNEL:1144		   1279	 #2333
X_EXIT			Near   _KERNEL:0D81		   1755	 #1791
X_INIT			Near   _KERNEL:07B7		   825	#1204
_PC_BASE		Number _KERNEL:027C		   #203	 4930
_PC_CBPMTORM		Number _KERNEL:0298		   #211	 3574
_PC_CBRMTOPM		Number _KERNEL:0294		   #210	 3492
_PC_INTPMTORM		Number _KERNEL:0280		   #205	 3096
_PC_INTRMTOPM		Number _KERNEL:027C		   #204	 3153
_PC_IRQCBPMTORM		Number _KERNEL:0290		   #209	 3455
_PC_IRQCBRMTOPM		Number _KERNEL:028C		   #208	 3413
_PC_IRQPMTORM		Number _KERNEL:0288		   #207	 3233  3349
_PC_IRQRMTOPM		Number _KERNEL:0284		   #206	 3386

Groups & Segments	Bit Size Align	Combine	Class	   Cref	(defined at #)

_KERNEL			16  2DC0 Para	Public	CODE1	   #119	 120  120  2314	 2382  3119  3251  3367	 3444  3566  4465  4621	  +
							   4629
Turbo Assembler	 Version 4.1	    12/05/21 16:49:30	    Page 108
Error Summary



**Error** kernel.asm(197) Symbol already different kind: SELZERO
**Error** kernel.asm(198) Symbol already different kind: SELDATA
**Error** kernel.asm(199) Symbol already different kind: SELCALLBACK
**Error** TEXT\KERNEL\init.asm(207) Illegal use	of segment register
**Error** TEXT\KERNEL\init.asm(208) Illegal use	of segment register
**Error** TEXT\KERNEL\init.asm(741) Illegal use	of segment register
**Error** TEXT\KERNEL\init.asm(759) Illegal use	of segment register
**Error** TEXT\KERNEL\init.asm(760) Forward reference needs override
**Error** TEXT\KERNEL\init.asm(761) Forward reference needs override
**Error** TEXT\KERNEL\init.asm(762) Forward reference needs override
**Error** TEXT\KERNEL\init.asm(763) Forward reference needs override
**Error** TEXT\KERNEL\exit.asm(51) Illegal use of segment register
**Error** TEXT\KERNEL\misc.asm(340) Illegal use	of segment register
**Error** TEXT\KERNEL\mode.asm(67) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(85) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(97) Illegal use of segment register
**Error** TEXT\KERNEL\intr.asm(98) Illegal use of segment register
**Error** TEXT\KERNEL\intr.asm(142) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(222) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(235) Illegal use	of segment register
**Error** TEXT\KERNEL\intr.asm(336) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(350) Illegal use	of segment register
**Error** TEXT\KERNEL\intr.asm(371) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(398) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(440) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(477) Forward reference needs override
**Error** TEXT\KERNEL\intr.asm(558) Forward reference needs override
**Error** TEXT\KERNEL\int31h.asm(729) Illegal use of segment register
**Error** TEXT\KERNEL\int31h.asm(765) Illegal use of segment register
**Error** TEXT\KERNEL\int31h.asm(795) Illegal use of segment register
**Error** TEXT\KERNEL\int31h.asm(821) Illegal use of segment register
**Error** TEXT\KERNEL\int31h.asm(1042) Forward reference needs override
